module FsSqlDom.Dom
open System
open Microsoft.SqlServer.TransactSql

#nowarn "25"   // Turn off bogus missing pattern match cases warning
#nowarn "1182" // Turn off unused variables warning

type FragmentMapping = System.Collections.Generic.IDictionary<obj, ScriptDom.TSqlFragment>

type [<RequireQualifiedAccess>] TSqlFragment = (* IsAbstract = true *)
  | AdHocDataSource of InitString:StringLiteral option * ProviderName:StringLiteral option
  | AddFileSpec of File:ScalarExpression option * FileName:Literal option
  | AlterAvailabilityGroupAction of AlterAvailabilityGroupAction
  | AlterAvailabilityGroupFailoverOption of OptionKind:ScriptDom.FailoverActionOptionKind * Value:Literal option
  | AlterDatabaseTermination of ImmediateRollback:bool * NoWait:bool * RollbackAfter:Literal option
  | AlterFullTextIndexAction of AlterFullTextIndexAction
  | AlterRoleAction of AlterRoleAction
  | AlterServerConfigurationBufferPoolExtensionOption of AlterServerConfigurationBufferPoolExtensionOption
  | AlterServerConfigurationDiagnosticsLogOption of AlterServerConfigurationDiagnosticsLogOption
  | AlterServerConfigurationExternalAuthenticationOption of AlterServerConfigurationExternalAuthenticationOption
  | AlterServerConfigurationFailoverClusterPropertyOption of OptionKind:ScriptDom.AlterServerConfigurationFailoverClusterPropertyOptionKind * OptionValue:OptionValue option
  | AlterServerConfigurationHadrClusterOption of IsLocal:bool * OptionKind:ScriptDom.AlterServerConfigurationHadrClusterOptionKind * OptionValue:OptionValue option
  | AlterServerConfigurationSoftNumaOption of OptionKind:ScriptDom.AlterServerConfigurationSoftNumaOptionKind * OptionValue:OptionValue option
  | AlterTableDropTableElement of DropClusteredConstraintOptions:(DropClusteredConstraintOption) list * IsIfExists:bool * Name:Identifier option * TableElementType:ScriptDom.TableElementType
  | ApplicationRoleOption of OptionKind:ScriptDom.ApplicationRoleOptionKind * Value:IdentifierOrValueExpression option
  | AssemblyName of ClassName:Identifier option * Name:Identifier option
  | AssemblyOption of AssemblyOption
  | AtomicBlockOption of AtomicBlockOption
  | AuditOption of AuditOption
  | AuditSpecificationDetail of AuditSpecificationDetail
  | AuditSpecificationPart of Details:AuditSpecificationDetail option * IsDrop:bool
  | AuditTarget of TargetKind:ScriptDom.AuditTargetKind * TargetOptions:(AuditTargetOption) list
  | AuditTargetOption of AuditTargetOption
  | AutomaticTuningOption of AutomaticTuningOption
  | AvailabilityGroupOption of AvailabilityGroupOption
  | AvailabilityReplica of Options:(AvailabilityReplicaOption) list * ServerName:StringLiteral option
  | AvailabilityReplicaOption of AvailabilityReplicaOption
  | BackupOption of BackupOption
  | BackupRestoreFileInfo of ItemKind:ScriptDom.BackupRestoreItemKind * Items:(ValueExpression) list
  | BooleanExpression of BooleanExpression
  | BoundingBoxParameter of Parameter:ScriptDom.BoundingBoxParameterType * Value:ScalarExpression option
  | BrokerPriorityParameter of IsDefaultOrAny:ScriptDom.BrokerPriorityParameterSpecialType * ParameterType:ScriptDom.BrokerPriorityParameterType * ParameterValue:IdentifierOrValueExpression option
  | BulkInsertOption of BulkInsertOption
  | CallTarget of CallTarget
  | CertificateOption of Kind:ScriptDom.CertificateOptionKinds * Value:Literal option
  | ChangeTrackingOptionDetail of ChangeTrackingOptionDetail
  | ColumnDefinitionBase of ColumnDefinitionBase
  | ColumnEncryptionDefinition of Parameters:(ColumnEncryptionDefinitionParameter) list
  | ColumnEncryptionDefinitionParameter of ColumnEncryptionDefinitionParameter
  | ColumnEncryptionKeyValue of Parameters:(ColumnEncryptionKeyValueParameter) list
  | ColumnEncryptionKeyValueParameter of ColumnEncryptionKeyValueParameter
  | ColumnMasterKeyParameter of ColumnMasterKeyParameter
  | ColumnStorageOptions of IsFileStream:bool * SparseOption:ScriptDom.SparseColumnOption
  | ColumnWithSortOrder of Column:ColumnReferenceExpression option * SortOrder:ScriptDom.SortOrder
  | CommonTableExpression of Columns:(Identifier) list * ExpressionName:Identifier option * QueryExpression:QueryExpression option
  | CompressionPartitionRange of From:ScalarExpression option * To:ScalarExpression option
  | ComputeClause of ByExpressions:(ScalarExpression) list * ComputeFunctions:(ComputeFunction) list
  | ComputeFunction of ComputeFunctionType:ScriptDom.ComputeFunctionType * Expression:ScalarExpression option
  | ConstraintDefinition of ConstraintDefinition
  | ContractMessage of Name:Identifier option * SentBy:ScriptDom.MessageSender
  | CopyOption of Kind:ScriptDom.CopyOptionKind * Value:CopyStatementOptionBase option
  | CopyStatementOptionBase of CopyStatementOptionBase
  | CreateLoginSource of CreateLoginSource
  | CryptoMechanism of CryptoMechanismType:ScriptDom.CryptoMechanismType * Identifier:Identifier option * PasswordOrSignature:Literal option
  | CursorDefinition of Options:(CursorOption) list * Select:SelectStatement option
  | CursorId of IsGlobal:bool * Name:IdentifierOrValueExpression option
  | CursorOption of OptionKind:ScriptDom.CursorOptionKind
  | DataModificationSpecification of DataModificationSpecification
  | DataTypeReference of DataTypeReference
  | DatabaseAuditAction of ActionKind:ScriptDom.DatabaseAuditActionKind
  | DatabaseConfigurationClearOption of OptionKind:ScriptDom.DatabaseConfigClearOptionKind * PlanHandle:BinaryLiteral option
  | DatabaseConfigurationSetOption of DatabaseConfigurationSetOption
  | DatabaseOption of DatabaseOption
  | DbccNamedLiteral of Name:String option * Value:ScalarExpression option
  | DbccOption of OptionKind:ScriptDom.DbccOptionKind
  | DeclareTableVariableBody of AsDefined:bool * Definition:TableDefinition option * VariableName:Identifier option
  | DeclareVariableElement of DeclareVariableElement
  | DeviceInfo of DeviceType:ScriptDom.DeviceType * LogicalDevice:IdentifierOrValueExpression option * PhysicalDevice:ValueExpression option
  | DialogOption of DialogOption
  | DiskStatementOption of OptionKind:ScriptDom.DiskStatementOptionKind * Value:IdentifierOrValueExpression option
  | DropClusteredConstraintOption of DropClusteredConstraintOption
  | DropIndexClauseBase of DropIndexClauseBase
  | EncryptionSource of EncryptionSource
  | EndpointAffinity of Kind:ScriptDom.AffinityKind * Value:Literal option
  | EndpointProtocolOption of EndpointProtocolOption
  | EventDeclaration of EventDeclarationActionParameters:(EventSessionObjectName) list * EventDeclarationPredicateParameter:BooleanExpression option * EventDeclarationSetParameters:(EventDeclarationSetParameter) list * ObjectName:EventSessionObjectName option
  | EventDeclarationSetParameter of EventField:Identifier option * EventValue:ScalarExpression option
  | EventNotificationObjectScope of QueueName:SchemaObjectName option * Target:ScriptDom.EventNotificationTarget
  | EventSessionObjectName of MultiPartIdentifier:MultiPartIdentifier option
  | EventTypeGroupContainer of EventTypeGroupContainer
  | ExecutableEntity of ExecutableEntity
  | ExecuteAsClause of ExecuteAsOption:ScriptDom.ExecuteAsOption * Literal:Literal option
  | ExecuteContext of Kind:ScriptDom.ExecuteAsOption * Principal:ScalarExpression option
  | ExecuteOption of ExecuteOption
  | ExecuteParameter of IsOutput:bool * ParameterValue:ScalarExpression option * Variable:VariableReference option
  | ExecuteSpecification of ExecutableEntity:ExecutableEntity option * ExecuteContext:ExecuteContext option * LinkedServer:Identifier option * Variable:VariableReference option
  | ExpressionWithSortOrder of Expression:ScalarExpression option * SortOrder:ScriptDom.SortOrder
  | ExternalDataSourceOption of ExternalDataSourceOption
  | ExternalFileFormatOption of ExternalFileFormatOption
  | ExternalResourcePoolAffinitySpecification of AffinityType:ScriptDom.ExternalResourcePoolAffinityType * IsAuto:bool * ParameterValue:Literal option * PoolAffinityRanges:(LiteralRange) list
  | ExternalResourcePoolParameter of AffinitySpecification:ExternalResourcePoolAffinitySpecification option * ParameterType:ScriptDom.ExternalResourcePoolParameterType * ParameterValue:Literal option
  | ExternalTableColumnDefinition of ColumnDefinition:ColumnDefinitionBase option * NullableConstraint:NullableConstraintDefinition option
  | ExternalTableDistributionPolicy of ExternalTableDistributionPolicy
  | ExternalTableOption of ExternalTableOption
  | FederationScheme of ColumnName:Identifier option * DistributionName:Identifier option
  | FetchType of Orientation:ScriptDom.FetchOrientation * RowOffset:ScalarExpression option
  | FileDeclaration of IsPrimary:bool * Options:(FileDeclarationOption) list
  | FileDeclarationOption of FileDeclarationOption
  | FileGroupDefinition of ContainsFileStream:bool * ContainsMemoryOptimizedData:bool * FileDeclarations:(FileDeclaration) list * IsDefault:bool * Name:Identifier option
  | FileGroupOrPartitionScheme of Name:IdentifierOrValueExpression option * PartitionSchemeColumns:(Identifier) list
  | ForClause of ForClause
  | FromClause of TableReferences:(TableReference) list
  | FullTextCatalogAndFileGroup of CatalogName:Identifier option * FileGroupIsFirst:bool * FileGroupName:Identifier option
  | FullTextCatalogOption of FullTextCatalogOption
  | FullTextIndexColumn of LanguageTerm:IdentifierOrValueExpression option * Name:Identifier option * StatisticalSemantics:bool * TypeColumn:Identifier option
  | FullTextIndexOption of FullTextIndexOption
  | FullTextStopListAction of IsAdd:bool * IsAll:bool * LanguageTerm:IdentifierOrValueExpression option * StopWord:Literal option
  | FunctionOption of FunctionOption
  | FunctionReturnType of FunctionReturnType
  | GraphConnectionBetweenNodes of FromNode:SchemaObjectName option * ToNode:SchemaObjectName option
  | GridParameter of Parameter:ScriptDom.GridParameterType * Value:ScriptDom.ImportanceParameterType
  | GroupByClause of All:bool * GroupByOption:ScriptDom.GroupByOption * GroupingSpecifications:(GroupingSpecification) list
  | GroupingSpecification of GroupingSpecification
  | HavingClause of SearchCondition:BooleanExpression option
  | IPv4 of OctetFour:Literal option * OctetOne:Literal option * OctetThree:Literal option * OctetTwo:Literal option
  | Identifier of Identifier
  | IdentifierOrScalarExpression of Identifier:Identifier option * ScalarExpression:ScalarExpression option
  | IdentifierOrValueExpression of Identifier:Identifier option * Value:String option * ValueExpression:ValueExpression option
  | IdentityOptions of IdentityIncrement:ScalarExpression option * IdentitySeed:ScalarExpression option * IsIdentityNotForReplication:bool
  | IndexOption of IndexOption
  | IndexType of IndexTypeKind:(ScriptDom.IndexTypeKind) option
  | InsertBulkColumnDefinition of Column:ColumnDefinitionBase option * NullNotNull:ScriptDom.NullNotNull
  | InsertSource of InsertSource
  | KeyOption of KeyOption
  | LiteralRange of LiteralRange
  | LowPriorityLockWaitOption of LowPriorityLockWaitOption
  | MergeAction of MergeAction
  | MergeActionClause of Action:MergeAction option * Condition:ScriptDom.MergeCondition * SearchCondition:BooleanExpression option
  | MethodSpecifier of AssemblyName:Identifier option * ClassName:Identifier option * MethodName:Identifier option
  | MirrorToClause of Devices:(DeviceInfo) list
  | MultiPartIdentifier of MultiPartIdentifier
  | OffsetClause of FetchExpression:ScalarExpression option * OffsetExpression:ScalarExpression option
  | OnlineIndexLowPriorityLockWaitOption of Options:(LowPriorityLockWaitOption) list
  | OptimizerHint of OptimizerHint
  | OptionValue of OptionValue
  | OrderByClause of OrderByElements:(ExpressionWithSortOrder) list
  | OutputClause of SelectColumns:(SelectElement) list
  | OutputIntoClause of IntoTable:TableReference option * IntoTableColumns:(ColumnReferenceExpression) list * SelectColumns:(SelectElement) list
  | OverClause of OrderByClause:OrderByClause option * Partitions:(ScalarExpression) list * WindowFrameClause:WindowFrameClause option
  | PartitionParameterType of Collation:Identifier option * DataType:DataTypeReference option
  | PartitionSpecifications of PartitionSpecifications
  | PartitionSpecifier of All:bool * Number:ScalarExpression option
  | PayloadOption of PayloadOption
  | Permission of Columns:(Identifier) list * Identifiers:(Identifier) list
  | PrincipalOption of PrincipalOption
  | Privilege80 of Columns:(Identifier) list * PrivilegeType80:ScriptDom.PrivilegeType80
  | ProcedureOption of ProcedureOption
  | ProcedureReference of Name:SchemaObjectName option * Number:Literal option
  | ProcedureReferenceName of ProcedureReference:ProcedureReference option * ProcedureVariable:VariableReference option
  | QueryExpression of QueryExpression
  | QueryStoreOption of QueryStoreOption
  | QueueOption of QueueOption
  | RemoteDataArchiveDatabaseSetting of RemoteDataArchiveDatabaseSetting
  | RemoteServiceBindingOption of RemoteServiceBindingOption
  | ResourcePoolAffinitySpecification of AffinityType:ScriptDom.ResourcePoolAffinityType * IsAuto:bool * ParameterValue:Literal option * PoolAffinityRanges:(LiteralRange) list
  | ResourcePoolParameter of AffinitySpecification:ResourcePoolAffinitySpecification option * ParameterType:ScriptDom.ResourcePoolParameterType * ParameterValue:Literal option
  | RestoreOption of RestoreOption
  | ResultColumnDefinition of ColumnDefinition:ColumnDefinitionBase option * Nullable:NullableConstraintDefinition option
  | ResultSetDefinition of ResultSetDefinition
  | RetentionPeriodDefinition of Duration:IntegerLiteral option * IsInfinity:bool * Units:ScriptDom.TemporalRetentionPeriodUnit
  | RouteOption of Literal:Literal option * OptionKind:ScriptDom.RouteOptionKind
  | RowValue of ColumnValues:(ScalarExpression) list
  | ScalarExpression of ScalarExpression
  | SchemaDeclarationItem of SchemaDeclarationItem
  | SchemaObjectNameOrValueExpression of SchemaObjectName:SchemaObjectName option * ValueExpression:ValueExpression option
  | SearchPropertyListAction of SearchPropertyListAction
  | SecurityElement80 of SecurityElement80
  | SecurityPolicyOption of OptionKind:ScriptDom.SecurityPolicyOptionKind * OptionState:ScriptDom.OptionState
  | SecurityPredicateAction of ActionType:ScriptDom.SecurityPredicateActionType * FunctionCall:FunctionCall option * SecurityPredicateOperation:ScriptDom.SecurityPredicateOperation * SecurityPredicateType:ScriptDom.SecurityPredicateType * TargetObjectName:SchemaObjectName option
  | SecurityPrincipal of Identifier:Identifier option * PrincipalType:ScriptDom.PrincipalType
  | SecurityTargetObject of Columns:(Identifier) list * ObjectKind:ScriptDom.SecurityObjectKind * ObjectName:SecurityTargetObjectName option
  | SecurityTargetObjectName of MultiPartIdentifier:MultiPartIdentifier option
  | SecurityUserClause80 of UserType80:ScriptDom.UserType80 * Users:(Identifier) list
  | SelectElement of SelectElement
  | SelectiveXmlIndexPromotedPath of IsSingleton:bool * MaxLength:IntegerLiteral option * Name:Identifier option * Path:Literal option * SQLDataType:DataTypeReference option * XQueryDataType:Literal option
  | SensitivityClassificationOption of ``Type``:ScriptDom.SensitivityClassification.OptionType * Value:Literal option
  | SequenceOption of SequenceOption
  | ServiceContract of Action:ScriptDom.AlterAction * Name:Identifier option
  | SessionOption of SessionOption
  | SetClause of SetClause
  | SetCommand of SetCommand
  | SpatialIndexOption of SpatialIndexOption
  | StatementList of StatementList
  | StatisticsOption of StatisticsOption
  | StatisticsPartitionRange of From:IntegerLiteral option * To:IntegerLiteral option
  | SystemTimePeriodDefinition of EndTimeColumn:Identifier option * StartTimeColumn:Identifier option
  | TSqlBatch of Statements:(TSqlStatement) list
  | TSqlFragmentSnippet of Script:String option
  | TSqlScript of Batches:(TSqlBatch) list
  | TSqlStatement of TSqlStatement
  | TableDefinition of ColumnDefinitions:(ColumnDefinition) list * Indexes:(IndexDefinition) list * SystemTimePeriod:SystemTimePeriodDefinition option * TableConstraints:(ConstraintDefinition) list
  | TableDistributionPolicy of TableDistributionPolicy
  | TableHint of TableHint
  | TableIndexType of TableIndexType
  | TableOption of TableOption
  | TableReference of TableReference
  | TableSampleClause of RepeatSeed:ScalarExpression option * SampleNumber:ScalarExpression option * System:bool * TableSampleClauseOption:ScriptDom.TableSampleClauseOption
  | TableSwitchOption of TableSwitchOption
  | TargetDeclaration of ObjectName:EventSessionObjectName option * TargetDeclarationParameters:(EventDeclarationSetParameter) list
  | TemporalClause of EndTime:ScalarExpression option * StartTime:ScalarExpression option * TemporalClauseType:ScriptDom.TemporalClauseType
  | TopRowFilter of Expression:ScalarExpression option * Percent:bool * WithTies:bool
  | TriggerAction of EventTypeGroup:EventTypeGroupContainer option * TriggerActionType:ScriptDom.TriggerActionType
  | TriggerObject of Name:SchemaObjectName option * TriggerScope:ScriptDom.TriggerScope
  | TriggerOption of TriggerOption
  | UserLoginOption of Identifier:Identifier option * UserLoginOptionType:ScriptDom.UserLoginOptionType
  | VariableValuePair of IsForUnknown:bool * Value:ScalarExpression option * Variable:VariableReference option
  | ViewDistributionPolicy of ViewDistributionPolicy
  | ViewOption of ViewOption
  | WhenClause of WhenClause
  | WhereClause of Cursor:CursorId option * SearchCondition:BooleanExpression option
  | WindowDelimiter of OffsetValue:ScalarExpression option * WindowDelimiterType:ScriptDom.WindowDelimiterType
  | WindowFrameClause of Bottom:WindowDelimiter option * Top:WindowDelimiter option * WindowFrameType:ScriptDom.WindowFrameType
  | WithCtesAndXmlNamespaces of ChangeTrackingContext:ValueExpression option * CommonTableExpressions:(CommonTableExpression) list * XmlNamespaces:XmlNamespaces option
  | WithinGroupClause of HasGraphPath:bool * OrderByClause:OrderByClause option
  | WlmTimeLiteral of TimeString:StringLiteral option
  | WorkloadClassifierOption of WorkloadClassifierOption
  | WorkloadGroupParameter of WorkloadGroupParameter
  | XmlNamespaces of XmlNamespacesElements:(XmlNamespacesElement) list
  | XmlNamespacesElement of XmlNamespacesElement
  member this.ToCs() : ScriptDom.TSqlFragment =
    match this with
    | AdHocDataSource(InitString=aInitString; ProviderName=aProviderName) ->
      let ret = ScriptDom.AdHocDataSource()
      ret.InitString <- aInitString |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ProviderName <- aProviderName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | AddFileSpec(File=aFile; FileName=aFileName) ->
      let ret = ScriptDom.AddFileSpec()
      ret.File <- aFile |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FileName <- aFileName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | AlterAvailabilityGroupAction(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | AlterAvailabilityGroupFailoverOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.AlterAvailabilityGroupFailoverOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | AlterDatabaseTermination(ImmediateRollback=aImmediateRollback; NoWait=aNoWait; RollbackAfter=aRollbackAfter) ->
      let ret = ScriptDom.AlterDatabaseTermination()
      ret.ImmediateRollback <- aImmediateRollback
      ret.NoWait <- aNoWait
      ret.RollbackAfter <- aRollbackAfter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | AlterFullTextIndexAction(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | AlterRoleAction(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | AlterServerConfigurationBufferPoolExtensionOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | AlterServerConfigurationDiagnosticsLogOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | AlterServerConfigurationExternalAuthenticationOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | AlterServerConfigurationFailoverClusterPropertyOption(OptionKind=aOptionKind; OptionValue=aOptionValue) ->
      let ret = ScriptDom.AlterServerConfigurationFailoverClusterPropertyOption()
      ret.OptionKind <- aOptionKind
      ret.OptionValue <- aOptionValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | AlterServerConfigurationHadrClusterOption(IsLocal=aIsLocal; OptionKind=aOptionKind; OptionValue=aOptionValue) ->
      let ret = ScriptDom.AlterServerConfigurationHadrClusterOption()
      ret.IsLocal <- aIsLocal
      ret.OptionKind <- aOptionKind
      ret.OptionValue <- aOptionValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | AlterServerConfigurationSoftNumaOption(OptionKind=aOptionKind; OptionValue=aOptionValue) ->
      let ret = ScriptDom.AlterServerConfigurationSoftNumaOption()
      ret.OptionKind <- aOptionKind
      ret.OptionValue <- aOptionValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | AlterTableDropTableElement(DropClusteredConstraintOptions=aDropClusteredConstraintOptions; IsIfExists=aIsIfExists; Name=aName; TableElementType=aTableElementType) ->
      let ret = ScriptDom.AlterTableDropTableElement()
      for e in aDropClusteredConstraintOptions do ret.DropClusteredConstraintOptions.Add (e.ToCs())
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TableElementType <- aTableElementType
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | ApplicationRoleOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.ApplicationRoleOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | AssemblyName(ClassName=aClassName; Name=aName) ->
      let ret = ScriptDom.AssemblyName()
      ret.ClassName <- aClassName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | AssemblyOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | AtomicBlockOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | AuditOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | AuditSpecificationDetail(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | AuditSpecificationPart(Details=aDetails; IsDrop=aIsDrop) ->
      let ret = ScriptDom.AuditSpecificationPart()
      ret.Details <- aDetails |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsDrop <- aIsDrop
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | AuditTarget(TargetKind=aTargetKind; TargetOptions=aTargetOptions) ->
      let ret = ScriptDom.AuditTarget()
      ret.TargetKind <- aTargetKind
      for e in aTargetOptions do ret.TargetOptions.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | AuditTargetOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | AutomaticTuningOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | AvailabilityGroupOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | AvailabilityReplica(Options=aOptions; ServerName=aServerName) ->
      let ret = ScriptDom.AvailabilityReplica()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.ServerName <- aServerName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | AvailabilityReplicaOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | BackupOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | BackupRestoreFileInfo(ItemKind=aItemKind; Items=aItems) ->
      let ret = ScriptDom.BackupRestoreFileInfo()
      ret.ItemKind <- aItemKind
      for e in aItems do ret.Items.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | BooleanExpression(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | BoundingBoxParameter(Parameter=aParameter; Value=aValue) ->
      let ret = ScriptDom.BoundingBoxParameter()
      ret.Parameter <- aParameter
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | BrokerPriorityParameter(IsDefaultOrAny=aIsDefaultOrAny; ParameterType=aParameterType; ParameterValue=aParameterValue) ->
      let ret = ScriptDom.BrokerPriorityParameter()
      ret.IsDefaultOrAny <- aIsDefaultOrAny
      ret.ParameterType <- aParameterType
      ret.ParameterValue <- aParameterValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | BulkInsertOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | CallTarget(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | CertificateOption(Kind=aKind; Value=aValue) ->
      let ret = ScriptDom.CertificateOption()
      ret.Kind <- aKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | ChangeTrackingOptionDetail(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | ColumnDefinitionBase(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | ColumnEncryptionDefinition(Parameters=aParameters) ->
      let ret = ScriptDom.ColumnEncryptionDefinition()
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | ColumnEncryptionDefinitionParameter(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | ColumnEncryptionKeyValue(Parameters=aParameters) ->
      let ret = ScriptDom.ColumnEncryptionKeyValue()
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | ColumnEncryptionKeyValueParameter(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | ColumnMasterKeyParameter(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | ColumnStorageOptions(IsFileStream=aIsFileStream; SparseOption=aSparseOption) ->
      let ret = ScriptDom.ColumnStorageOptions()
      ret.IsFileStream <- aIsFileStream
      ret.SparseOption <- aSparseOption
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | ColumnWithSortOrder(Column=aColumn; SortOrder=aSortOrder) ->
      let ret = ScriptDom.ColumnWithSortOrder()
      ret.Column <- aColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SortOrder <- aSortOrder
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | CommonTableExpression(Columns=aColumns; ExpressionName=aExpressionName; QueryExpression=aQueryExpression) ->
      let ret = ScriptDom.CommonTableExpression()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.ExpressionName <- aExpressionName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.QueryExpression <- aQueryExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | CompressionPartitionRange(From=aFrom; To=aTo) ->
      let ret = ScriptDom.CompressionPartitionRange()
      ret.From <- aFrom |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.To <- aTo |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | ComputeClause(ByExpressions=aByExpressions; ComputeFunctions=aComputeFunctions) ->
      let ret = ScriptDom.ComputeClause()
      for e in aByExpressions do ret.ByExpressions.Add (e.ToCs())
      for e in aComputeFunctions do ret.ComputeFunctions.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | ComputeFunction(ComputeFunctionType=aComputeFunctionType; Expression=aExpression) ->
      let ret = ScriptDom.ComputeFunction()
      ret.ComputeFunctionType <- aComputeFunctionType
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | ConstraintDefinition(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | ContractMessage(Name=aName; SentBy=aSentBy) ->
      let ret = ScriptDom.ContractMessage()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SentBy <- aSentBy
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | CopyOption(Kind=aKind; Value=aValue) ->
      let ret = ScriptDom.CopyOption()
      ret.Kind <- aKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | CopyStatementOptionBase(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | CreateLoginSource(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | CryptoMechanism(CryptoMechanismType=aCryptoMechanismType; Identifier=aIdentifier; PasswordOrSignature=aPasswordOrSignature) ->
      let ret = ScriptDom.CryptoMechanism()
      ret.CryptoMechanismType <- aCryptoMechanismType
      ret.Identifier <- aIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PasswordOrSignature <- aPasswordOrSignature |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | CursorDefinition(Options=aOptions; Select=aSelect) ->
      let ret = ScriptDom.CursorDefinition()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.Select <- aSelect |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | CursorId(IsGlobal=aIsGlobal; Name=aName) ->
      let ret = ScriptDom.CursorId()
      ret.IsGlobal <- aIsGlobal
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | CursorOption(OptionKind=aOptionKind) ->
      let ret = ScriptDom.CursorOption()
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | DataModificationSpecification(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | DataTypeReference(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | DatabaseAuditAction(ActionKind=aActionKind) ->
      let ret = ScriptDom.DatabaseAuditAction()
      ret.ActionKind <- aActionKind
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | DatabaseConfigurationClearOption(OptionKind=aOptionKind; PlanHandle=aPlanHandle) ->
      let ret = ScriptDom.DatabaseConfigurationClearOption()
      ret.OptionKind <- aOptionKind
      ret.PlanHandle <- aPlanHandle |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | DatabaseConfigurationSetOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | DatabaseOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | DbccNamedLiteral(Name=aName; Value=aValue) ->
      let ret = ScriptDom.DbccNamedLiteral()
      ret.Name <- aName |> Option.toObj
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | DbccOption(OptionKind=aOptionKind) ->
      let ret = ScriptDom.DbccOption()
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | DeclareTableVariableBody(AsDefined=aAsDefined; Definition=aDefinition; VariableName=aVariableName) ->
      let ret = ScriptDom.DeclareTableVariableBody()
      ret.AsDefined <- aAsDefined
      ret.Definition <- aDefinition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.VariableName <- aVariableName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | DeclareVariableElement(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | DeviceInfo(DeviceType=aDeviceType; LogicalDevice=aLogicalDevice; PhysicalDevice=aPhysicalDevice) ->
      let ret = ScriptDom.DeviceInfo()
      ret.DeviceType <- aDeviceType
      ret.LogicalDevice <- aLogicalDevice |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PhysicalDevice <- aPhysicalDevice |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | DialogOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | DiskStatementOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.DiskStatementOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | DropClusteredConstraintOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | DropIndexClauseBase(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | EncryptionSource(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | EndpointAffinity(Kind=aKind; Value=aValue) ->
      let ret = ScriptDom.EndpointAffinity()
      ret.Kind <- aKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | EndpointProtocolOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | EventDeclaration(EventDeclarationActionParameters=aEventDeclarationActionParameters; EventDeclarationPredicateParameter=aEventDeclarationPredicateParameter; EventDeclarationSetParameters=aEventDeclarationSetParameters; ObjectName=aObjectName) ->
      let ret = ScriptDom.EventDeclaration()
      for e in aEventDeclarationActionParameters do ret.EventDeclarationActionParameters.Add (e.ToCs())
      ret.EventDeclarationPredicateParameter <- aEventDeclarationPredicateParameter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aEventDeclarationSetParameters do ret.EventDeclarationSetParameters.Add (e.ToCs())
      ret.ObjectName <- aObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | EventDeclarationSetParameter(EventField=aEventField; EventValue=aEventValue) ->
      let ret = ScriptDom.EventDeclarationSetParameter()
      ret.EventField <- aEventField |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.EventValue <- aEventValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | EventNotificationObjectScope(QueueName=aQueueName; Target=aTarget) ->
      let ret = ScriptDom.EventNotificationObjectScope()
      ret.QueueName <- aQueueName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Target <- aTarget
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | EventSessionObjectName(MultiPartIdentifier=aMultiPartIdentifier) ->
      let ret = ScriptDom.EventSessionObjectName()
      ret.MultiPartIdentifier <- aMultiPartIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | EventTypeGroupContainer(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | ExecutableEntity(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | ExecuteAsClause(ExecuteAsOption=aExecuteAsOption; Literal=aLiteral) ->
      let ret = ScriptDom.ExecuteAsClause()
      ret.ExecuteAsOption <- aExecuteAsOption
      ret.Literal <- aLiteral |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | ExecuteContext(Kind=aKind; Principal=aPrincipal) ->
      let ret = ScriptDom.ExecuteContext()
      ret.Kind <- aKind
      ret.Principal <- aPrincipal |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | ExecuteOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | ExecuteParameter(IsOutput=aIsOutput; ParameterValue=aParameterValue; Variable=aVariable) ->
      let ret = ScriptDom.ExecuteParameter()
      ret.IsOutput <- aIsOutput
      ret.ParameterValue <- aParameterValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Variable <- aVariable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | ExecuteSpecification(ExecutableEntity=aExecutableEntity; ExecuteContext=aExecuteContext; LinkedServer=aLinkedServer; Variable=aVariable) ->
      let ret = ScriptDom.ExecuteSpecification()
      ret.ExecutableEntity <- aExecutableEntity |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ExecuteContext <- aExecuteContext |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.LinkedServer <- aLinkedServer |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Variable <- aVariable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | ExpressionWithSortOrder(Expression=aExpression; SortOrder=aSortOrder) ->
      let ret = ScriptDom.ExpressionWithSortOrder()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SortOrder <- aSortOrder
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | ExternalDataSourceOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | ExternalFileFormatOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | ExternalResourcePoolAffinitySpecification(AffinityType=aAffinityType; IsAuto=aIsAuto; ParameterValue=aParameterValue; PoolAffinityRanges=aPoolAffinityRanges) ->
      let ret = ScriptDom.ExternalResourcePoolAffinitySpecification()
      ret.AffinityType <- aAffinityType
      ret.IsAuto <- aIsAuto
      ret.ParameterValue <- aParameterValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aPoolAffinityRanges do ret.PoolAffinityRanges.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | ExternalResourcePoolParameter(AffinitySpecification=aAffinitySpecification; ParameterType=aParameterType; ParameterValue=aParameterValue) ->
      let ret = ScriptDom.ExternalResourcePoolParameter()
      ret.AffinitySpecification <- aAffinitySpecification |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ParameterType <- aParameterType
      ret.ParameterValue <- aParameterValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | ExternalTableColumnDefinition(ColumnDefinition=aColumnDefinition; NullableConstraint=aNullableConstraint) ->
      let ret = ScriptDom.ExternalTableColumnDefinition()
      ret.ColumnDefinition <- aColumnDefinition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.NullableConstraint <- aNullableConstraint |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | ExternalTableDistributionPolicy(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | ExternalTableOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | FederationScheme(ColumnName=aColumnName; DistributionName=aDistributionName) ->
      let ret = ScriptDom.FederationScheme()
      ret.ColumnName <- aColumnName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DistributionName <- aDistributionName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | FetchType(Orientation=aOrientation; RowOffset=aRowOffset) ->
      let ret = ScriptDom.FetchType()
      ret.Orientation <- aOrientation
      ret.RowOffset <- aRowOffset |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | FileDeclaration(IsPrimary=aIsPrimary; Options=aOptions) ->
      let ret = ScriptDom.FileDeclaration()
      ret.IsPrimary <- aIsPrimary
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | FileDeclarationOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | FileGroupDefinition(ContainsFileStream=aContainsFileStream; ContainsMemoryOptimizedData=aContainsMemoryOptimizedData; FileDeclarations=aFileDeclarations; IsDefault=aIsDefault; Name=aName) ->
      let ret = ScriptDom.FileGroupDefinition()
      ret.ContainsFileStream <- aContainsFileStream
      ret.ContainsMemoryOptimizedData <- aContainsMemoryOptimizedData
      for e in aFileDeclarations do ret.FileDeclarations.Add (e.ToCs())
      ret.IsDefault <- aIsDefault
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | FileGroupOrPartitionScheme(Name=aName; PartitionSchemeColumns=aPartitionSchemeColumns) ->
      let ret = ScriptDom.FileGroupOrPartitionScheme()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aPartitionSchemeColumns do ret.PartitionSchemeColumns.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | ForClause(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | FromClause(TableReferences=aTableReferences) ->
      let ret = ScriptDom.FromClause()
      for e in aTableReferences do ret.TableReferences.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | FullTextCatalogAndFileGroup(CatalogName=aCatalogName; FileGroupIsFirst=aFileGroupIsFirst; FileGroupName=aFileGroupName) ->
      let ret = ScriptDom.FullTextCatalogAndFileGroup()
      ret.CatalogName <- aCatalogName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FileGroupIsFirst <- aFileGroupIsFirst
      ret.FileGroupName <- aFileGroupName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | FullTextCatalogOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | FullTextIndexColumn(LanguageTerm=aLanguageTerm; Name=aName; StatisticalSemantics=aStatisticalSemantics; TypeColumn=aTypeColumn) ->
      let ret = ScriptDom.FullTextIndexColumn()
      ret.LanguageTerm <- aLanguageTerm |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StatisticalSemantics <- aStatisticalSemantics
      ret.TypeColumn <- aTypeColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | FullTextIndexOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | FullTextStopListAction(IsAdd=aIsAdd; IsAll=aIsAll; LanguageTerm=aLanguageTerm; StopWord=aStopWord) ->
      let ret = ScriptDom.FullTextStopListAction()
      ret.IsAdd <- aIsAdd
      ret.IsAll <- aIsAll
      ret.LanguageTerm <- aLanguageTerm |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StopWord <- aStopWord |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | FunctionOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | FunctionReturnType(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | GraphConnectionBetweenNodes(FromNode=aFromNode; ToNode=aToNode) ->
      let ret = ScriptDom.GraphConnectionBetweenNodes()
      ret.FromNode <- aFromNode |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ToNode <- aToNode |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | GridParameter(Parameter=aParameter; Value=aValue) ->
      let ret = ScriptDom.GridParameter()
      ret.Parameter <- aParameter
      ret.Value <- aValue
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | GroupByClause(All=aAll; GroupByOption=aGroupByOption; GroupingSpecifications=aGroupingSpecifications) ->
      let ret = ScriptDom.GroupByClause()
      ret.All <- aAll
      ret.GroupByOption <- aGroupByOption
      for e in aGroupingSpecifications do ret.GroupingSpecifications.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | GroupingSpecification(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | HavingClause(SearchCondition=aSearchCondition) ->
      let ret = ScriptDom.HavingClause()
      ret.SearchCondition <- aSearchCondition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | IPv4(OctetFour=aOctetFour; OctetOne=aOctetOne; OctetThree=aOctetThree; OctetTwo=aOctetTwo) ->
      let ret = ScriptDom.IPv4()
      ret.OctetFour <- aOctetFour |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OctetOne <- aOctetOne |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OctetThree <- aOctetThree |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OctetTwo <- aOctetTwo |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | Identifier(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | IdentifierOrScalarExpression(Identifier=aIdentifier; ScalarExpression=aScalarExpression) ->
      let ret = ScriptDom.IdentifierOrScalarExpression()
      ret.Identifier <- aIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ScalarExpression <- aScalarExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | IdentifierOrValueExpression(Identifier=aIdentifier; Value=aValue; ValueExpression=aValueExpression) ->
      let ret = ScriptDom.IdentifierOrValueExpression()
      ret.Identifier <- aIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
       // Skipping prop Value - it is Readonly
      ret.ValueExpression <- aValueExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | IdentityOptions(IdentityIncrement=aIdentityIncrement; IdentitySeed=aIdentitySeed; IsIdentityNotForReplication=aIsIdentityNotForReplication) ->
      let ret = ScriptDom.IdentityOptions()
      ret.IdentityIncrement <- aIdentityIncrement |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IdentitySeed <- aIdentitySeed |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsIdentityNotForReplication <- aIsIdentityNotForReplication
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | IndexOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | IndexType(IndexTypeKind=aIndexTypeKind) ->
      let ret = ScriptDom.IndexType()
      ret.IndexTypeKind <- Option.toNullable aIndexTypeKind
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | InsertBulkColumnDefinition(Column=aColumn; NullNotNull=aNullNotNull) ->
      let ret = ScriptDom.InsertBulkColumnDefinition()
      ret.Column <- aColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.NullNotNull <- aNullNotNull
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | InsertSource(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | KeyOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | LiteralRange(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | LowPriorityLockWaitOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | MergeAction(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | MergeActionClause(Action=aAction; Condition=aCondition; SearchCondition=aSearchCondition) ->
      let ret = ScriptDom.MergeActionClause()
      ret.Action <- aAction |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Condition <- aCondition
      ret.SearchCondition <- aSearchCondition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | MethodSpecifier(AssemblyName=aAssemblyName; ClassName=aClassName; MethodName=aMethodName) ->
      let ret = ScriptDom.MethodSpecifier()
      ret.AssemblyName <- aAssemblyName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ClassName <- aClassName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.MethodName <- aMethodName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | MirrorToClause(Devices=aDevices) ->
      let ret = ScriptDom.MirrorToClause()
      for e in aDevices do ret.Devices.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | MultiPartIdentifier(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | OffsetClause(FetchExpression=aFetchExpression; OffsetExpression=aOffsetExpression) ->
      let ret = ScriptDom.OffsetClause()
      ret.FetchExpression <- aFetchExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OffsetExpression <- aOffsetExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | OnlineIndexLowPriorityLockWaitOption(Options=aOptions) ->
      let ret = ScriptDom.OnlineIndexLowPriorityLockWaitOption()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | OptimizerHint(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | OptionValue(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | OrderByClause(OrderByElements=aOrderByElements) ->
      let ret = ScriptDom.OrderByClause()
      for e in aOrderByElements do ret.OrderByElements.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | OutputClause(SelectColumns=aSelectColumns) ->
      let ret = ScriptDom.OutputClause()
      for e in aSelectColumns do ret.SelectColumns.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | OutputIntoClause(IntoTable=aIntoTable; IntoTableColumns=aIntoTableColumns; SelectColumns=aSelectColumns) ->
      let ret = ScriptDom.OutputIntoClause()
      ret.IntoTable <- aIntoTable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aIntoTableColumns do ret.IntoTableColumns.Add (e.ToCs())
      for e in aSelectColumns do ret.SelectColumns.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | OverClause(OrderByClause=aOrderByClause; Partitions=aPartitions; WindowFrameClause=aWindowFrameClause) ->
      let ret = ScriptDom.OverClause()
      ret.OrderByClause <- aOrderByClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aPartitions do ret.Partitions.Add (e.ToCs())
      ret.WindowFrameClause <- aWindowFrameClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | PartitionParameterType(Collation=aCollation; DataType=aDataType) ->
      let ret = ScriptDom.PartitionParameterType()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | PartitionSpecifications(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | PartitionSpecifier(All=aAll; Number=aNumber) ->
      let ret = ScriptDom.PartitionSpecifier()
      ret.All <- aAll
      ret.Number <- aNumber |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | PayloadOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | Permission(Columns=aColumns; Identifiers=aIdentifiers) ->
      let ret = ScriptDom.Permission()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      for e in aIdentifiers do ret.Identifiers.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | PrincipalOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | Privilege80(Columns=aColumns; PrivilegeType80=aPrivilegeType80) ->
      let ret = ScriptDom.Privilege80()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.PrivilegeType80 <- aPrivilegeType80
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | ProcedureOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | ProcedureReference(Name=aName; Number=aNumber) ->
      let ret = ScriptDom.ProcedureReference()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Number <- aNumber |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | ProcedureReferenceName(ProcedureReference=aProcedureReference; ProcedureVariable=aProcedureVariable) ->
      let ret = ScriptDom.ProcedureReferenceName()
      ret.ProcedureReference <- aProcedureReference |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ProcedureVariable <- aProcedureVariable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | QueryExpression(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | QueryStoreOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | QueueOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | RemoteDataArchiveDatabaseSetting(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | RemoteServiceBindingOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | ResourcePoolAffinitySpecification(AffinityType=aAffinityType; IsAuto=aIsAuto; ParameterValue=aParameterValue; PoolAffinityRanges=aPoolAffinityRanges) ->
      let ret = ScriptDom.ResourcePoolAffinitySpecification()
      ret.AffinityType <- aAffinityType
      ret.IsAuto <- aIsAuto
      ret.ParameterValue <- aParameterValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aPoolAffinityRanges do ret.PoolAffinityRanges.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | ResourcePoolParameter(AffinitySpecification=aAffinitySpecification; ParameterType=aParameterType; ParameterValue=aParameterValue) ->
      let ret = ScriptDom.ResourcePoolParameter()
      ret.AffinitySpecification <- aAffinitySpecification |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ParameterType <- aParameterType
      ret.ParameterValue <- aParameterValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | RestoreOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | ResultColumnDefinition(ColumnDefinition=aColumnDefinition; Nullable=aNullable) ->
      let ret = ScriptDom.ResultColumnDefinition()
      ret.ColumnDefinition <- aColumnDefinition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Nullable <- aNullable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | ResultSetDefinition(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | RetentionPeriodDefinition(Duration=aDuration; IsInfinity=aIsInfinity; Units=aUnits) ->
      let ret = ScriptDom.RetentionPeriodDefinition()
      ret.Duration <- aDuration |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsInfinity <- aIsInfinity
      ret.Units <- aUnits
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | RouteOption(Literal=aLiteral; OptionKind=aOptionKind) ->
      let ret = ScriptDom.RouteOption()
      ret.Literal <- aLiteral |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | RowValue(ColumnValues=aColumnValues) ->
      let ret = ScriptDom.RowValue()
      for e in aColumnValues do ret.ColumnValues.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | ScalarExpression(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | SchemaDeclarationItem(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | SchemaObjectNameOrValueExpression(SchemaObjectName=aSchemaObjectName; ValueExpression=aValueExpression) ->
      let ret = ScriptDom.SchemaObjectNameOrValueExpression()
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ValueExpression <- aValueExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | SearchPropertyListAction(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | SecurityElement80(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | SecurityPolicyOption(OptionKind=aOptionKind; OptionState=aOptionState) ->
      let ret = ScriptDom.SecurityPolicyOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | SecurityPredicateAction(ActionType=aActionType; FunctionCall=aFunctionCall; SecurityPredicateOperation=aSecurityPredicateOperation; SecurityPredicateType=aSecurityPredicateType; TargetObjectName=aTargetObjectName) ->
      let ret = ScriptDom.SecurityPredicateAction()
      ret.ActionType <- aActionType
      ret.FunctionCall <- aFunctionCall |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SecurityPredicateOperation <- aSecurityPredicateOperation
      ret.SecurityPredicateType <- aSecurityPredicateType
      ret.TargetObjectName <- aTargetObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | SecurityPrincipal(Identifier=aIdentifier; PrincipalType=aPrincipalType) ->
      let ret = ScriptDom.SecurityPrincipal()
      ret.Identifier <- aIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PrincipalType <- aPrincipalType
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | SecurityTargetObject(Columns=aColumns; ObjectKind=aObjectKind; ObjectName=aObjectName) ->
      let ret = ScriptDom.SecurityTargetObject()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.ObjectKind <- aObjectKind
      ret.ObjectName <- aObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | SecurityTargetObjectName(MultiPartIdentifier=aMultiPartIdentifier) ->
      let ret = ScriptDom.SecurityTargetObjectName()
      ret.MultiPartIdentifier <- aMultiPartIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | SecurityUserClause80(UserType80=aUserType80; Users=aUsers) ->
      let ret = ScriptDom.SecurityUserClause80()
      ret.UserType80 <- aUserType80
      for e in aUsers do ret.Users.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | SelectElement(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | SelectiveXmlIndexPromotedPath(IsSingleton=aIsSingleton; MaxLength=aMaxLength; Name=aName; Path=aPath; SQLDataType=aSQLDataType; XQueryDataType=aXQueryDataType) ->
      let ret = ScriptDom.SelectiveXmlIndexPromotedPath()
      ret.IsSingleton <- aIsSingleton
      ret.MaxLength <- aMaxLength |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Path <- aPath |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SQLDataType <- aSQLDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.XQueryDataType <- aXQueryDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | SensitivityClassificationOption(Type=aType; Value=aValue) ->
      let ret = ScriptDom.SensitivityClassificationOption()
      ret.Type <- aType
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | SequenceOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | ServiceContract(Action=aAction; Name=aName) ->
      let ret = ScriptDom.ServiceContract()
      ret.Action <- aAction
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | SessionOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | SetClause(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | SetCommand(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | SpatialIndexOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | StatementList(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | StatisticsOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | StatisticsPartitionRange(From=aFrom; To=aTo) ->
      let ret = ScriptDom.StatisticsPartitionRange()
      ret.From <- aFrom |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.To <- aTo |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | SystemTimePeriodDefinition(EndTimeColumn=aEndTimeColumn; StartTimeColumn=aStartTimeColumn) ->
      let ret = ScriptDom.SystemTimePeriodDefinition()
      ret.EndTimeColumn <- aEndTimeColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StartTimeColumn <- aStartTimeColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | TSqlBatch(Statements=aStatements) ->
      let ret = ScriptDom.TSqlBatch()
      for e in aStatements do ret.Statements.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | TSqlFragmentSnippet(Script=aScript) ->
      let ret = ScriptDom.TSqlFragmentSnippet()
      ret.Script <- aScript |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | TSqlScript(Batches=aBatches) ->
      let ret = ScriptDom.TSqlScript()
      for e in aBatches do ret.Batches.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | TSqlStatement(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | TableDefinition(ColumnDefinitions=aColumnDefinitions; Indexes=aIndexes; SystemTimePeriod=aSystemTimePeriod; TableConstraints=aTableConstraints) ->
      let ret = ScriptDom.TableDefinition()
      for e in aColumnDefinitions do ret.ColumnDefinitions.Add (e.ToCs())
      for e in aIndexes do ret.Indexes.Add (e.ToCs())
      ret.SystemTimePeriod <- aSystemTimePeriod |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aTableConstraints do ret.TableConstraints.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | TableDistributionPolicy(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | TableHint(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | TableIndexType(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | TableOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | TableReference(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | TableSampleClause(RepeatSeed=aRepeatSeed; SampleNumber=aSampleNumber; System=aSystem; TableSampleClauseOption=aTableSampleClauseOption) ->
      let ret = ScriptDom.TableSampleClause()
      ret.RepeatSeed <- aRepeatSeed |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SampleNumber <- aSampleNumber |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.System <- aSystem
      ret.TableSampleClauseOption <- aTableSampleClauseOption
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | TableSwitchOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | TargetDeclaration(ObjectName=aObjectName; TargetDeclarationParameters=aTargetDeclarationParameters) ->
      let ret = ScriptDom.TargetDeclaration()
      ret.ObjectName <- aObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aTargetDeclarationParameters do ret.TargetDeclarationParameters.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | TemporalClause(EndTime=aEndTime; StartTime=aStartTime; TemporalClauseType=aTemporalClauseType) ->
      let ret = ScriptDom.TemporalClause()
      ret.EndTime <- aEndTime |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StartTime <- aStartTime |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TemporalClauseType <- aTemporalClauseType
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | TopRowFilter(Expression=aExpression; Percent=aPercent; WithTies=aWithTies) ->
      let ret = ScriptDom.TopRowFilter()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Percent <- aPercent
      ret.WithTies <- aWithTies
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | TriggerAction(EventTypeGroup=aEventTypeGroup; TriggerActionType=aTriggerActionType) ->
      let ret = ScriptDom.TriggerAction()
      ret.EventTypeGroup <- aEventTypeGroup |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TriggerActionType <- aTriggerActionType
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | TriggerObject(Name=aName; TriggerScope=aTriggerScope) ->
      let ret = ScriptDom.TriggerObject()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TriggerScope <- aTriggerScope
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | TriggerOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | UserLoginOption(Identifier=aIdentifier; UserLoginOptionType=aUserLoginOptionType) ->
      let ret = ScriptDom.UserLoginOption()
      ret.Identifier <- aIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UserLoginOptionType <- aUserLoginOptionType
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | VariableValuePair(IsForUnknown=aIsForUnknown; Value=aValue; Variable=aVariable) ->
      let ret = ScriptDom.VariableValuePair()
      ret.IsForUnknown <- aIsForUnknown
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Variable <- aVariable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | ViewDistributionPolicy(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | ViewOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | WhenClause(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | WhereClause(Cursor=aCursor; SearchCondition=aSearchCondition) ->
      let ret = ScriptDom.WhereClause()
      ret.Cursor <- aCursor |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SearchCondition <- aSearchCondition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | WindowDelimiter(OffsetValue=aOffsetValue; WindowDelimiterType=aWindowDelimiterType) ->
      let ret = ScriptDom.WindowDelimiter()
      ret.OffsetValue <- aOffsetValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WindowDelimiterType <- aWindowDelimiterType
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | WindowFrameClause(Bottom=aBottom; Top=aTop; WindowFrameType=aWindowFrameType) ->
      let ret = ScriptDom.WindowFrameClause()
      ret.Bottom <- aBottom |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Top <- aTop |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WindowFrameType <- aWindowFrameType
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | WithCtesAndXmlNamespaces(ChangeTrackingContext=aChangeTrackingContext; CommonTableExpressions=aCommonTableExpressions; XmlNamespaces=aXmlNamespaces) ->
      let ret = ScriptDom.WithCtesAndXmlNamespaces()
      ret.ChangeTrackingContext <- aChangeTrackingContext |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aCommonTableExpressions do ret.CommonTableExpressions.Add (e.ToCs())
      ret.XmlNamespaces <- aXmlNamespaces |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | WithinGroupClause(HasGraphPath=aHasGraphPath; OrderByClause=aOrderByClause) ->
      let ret = ScriptDom.WithinGroupClause()
      ret.HasGraphPath <- aHasGraphPath
      ret.OrderByClause <- aOrderByClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | WlmTimeLiteral(TimeString=aTimeString) ->
      let ret = ScriptDom.WlmTimeLiteral()
      ret.TimeString <- aTimeString |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | WorkloadClassifierOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | WorkloadGroupParameter(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
    | XmlNamespaces(XmlNamespacesElements=aXmlNamespacesElements) ->
      let ret = ScriptDom.XmlNamespaces()
      for e in aXmlNamespacesElements do ret.XmlNamespacesElements.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 335 *)
    | XmlNamespacesElement(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 345 *)
  static member FromCs(src:ScriptDom.TSqlFragment, fragmentMapping:FragmentMapping) : TSqlFragment =
    let ret =
      match src with
      | :? ScriptDom.AdHocDataSource as src ->
        TSqlFragment.AdHocDataSource((src.InitString |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))),(src.ProviderName |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))))
      | :? ScriptDom.AddFileSpec as src ->
        TSqlFragment.AddFileSpec((src.File |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.FileName |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.AlterAvailabilityGroupAction as src ->
        match src with
        | :? ScriptDom.AlterAvailabilityGroupFailoverAction as src->
          TSqlFragment.AlterAvailabilityGroupAction((AlterAvailabilityGroupAction.AlterAvailabilityGroupFailoverAction((src.ActionType), (src.Options |> Seq.map (fun src -> AlterAvailabilityGroupFailoverOption.AlterAvailabilityGroupFailoverOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq))  ))
        | _ -> (* :? ScriptDom.AlterAvailabilityGroupAction as src *)
          TSqlFragment.AlterAvailabilityGroupAction((AlterAvailabilityGroupAction.Base((src.ActionType))))
      | :? ScriptDom.AlterAvailabilityGroupFailoverOption as src ->
        TSqlFragment.AlterAvailabilityGroupFailoverOption((src.OptionKind),(src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.AlterDatabaseTermination as src ->
        TSqlFragment.AlterDatabaseTermination((src.ImmediateRollback),(src.NoWait),(src.RollbackAfter |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.AlterFullTextIndexAction as src ->
        match src with
        | :? ScriptDom.AddAlterFullTextIndexAction as src->
          TSqlFragment.AlterFullTextIndexAction((AlterFullTextIndexAction.AddAlterFullTextIndexAction((src.Columns |> Seq.map (fun src -> FullTextIndexColumn.FullTextIndexColumn((src.LanguageTerm |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.StatisticalSemantics), (src.TypeColumn |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.WithNoPopulation))  ))
        | :? ScriptDom.AlterColumnAlterFullTextIndexAction as src->
          TSqlFragment.AlterFullTextIndexAction((AlterFullTextIndexAction.AlterColumnAlterFullTextIndexAction((src.Column |> Option.ofObj |> Option.map (fun x -> FullTextIndexColumn.FromCs(x, fragmentMapping))), (src.WithNoPopulation))  ))
        | :? ScriptDom.DropAlterFullTextIndexAction as src->
          TSqlFragment.AlterFullTextIndexAction((AlterFullTextIndexAction.DropAlterFullTextIndexAction((src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.WithNoPopulation))  ))
        | :? ScriptDom.SetSearchPropertyListAlterFullTextIndexAction as src->
          TSqlFragment.AlterFullTextIndexAction((AlterFullTextIndexAction.SetSearchPropertyListAlterFullTextIndexAction((src.SearchPropertyListOption |> Option.ofObj |> Option.map (fun x -> SearchPropertyListFullTextIndexOption.FromCs(x, fragmentMapping))), (src.WithNoPopulation))  ))
        | :? ScriptDom.SetStopListAlterFullTextIndexAction as src->
          TSqlFragment.AlterFullTextIndexAction((AlterFullTextIndexAction.SetStopListAlterFullTextIndexAction((src.StopListOption |> Option.ofObj |> Option.map (fun x -> StopListFullTextIndexOption.FromCs(x, fragmentMapping))), (src.WithNoPopulation))  ))
        | :? ScriptDom.SimpleAlterFullTextIndexAction as src->
          TSqlFragment.AlterFullTextIndexAction((AlterFullTextIndexAction.SimpleAlterFullTextIndexAction((src.ActionKind))  ))
      | :? ScriptDom.AlterRoleAction as src ->
        match src with
        | :? ScriptDom.AddMemberAlterRoleAction as src->
          TSqlFragment.AlterRoleAction((AlterRoleAction.AddMemberAlterRoleAction((src.Member |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropMemberAlterRoleAction as src->
          TSqlFragment.AlterRoleAction((AlterRoleAction.DropMemberAlterRoleAction((src.Member |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.RenameAlterRoleAction as src->
          TSqlFragment.AlterRoleAction((AlterRoleAction.RenameAlterRoleAction((src.NewName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.AlterServerConfigurationBufferPoolExtensionOption as src ->
        match src with
        | :? ScriptDom.AlterServerConfigurationBufferPoolExtensionContainerOption as src->
          TSqlFragment.AlterServerConfigurationBufferPoolExtensionOption((AlterServerConfigurationBufferPoolExtensionOption.AlterServerConfigurationBufferPoolExtensionContainerOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (fun x -> OptionValue.FromCs(x, fragmentMapping))), (src.Suboptions |> Seq.map (fun x -> AlterServerConfigurationBufferPoolExtensionOption.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.AlterServerConfigurationBufferPoolExtensionSizeOption as src->
          TSqlFragment.AlterServerConfigurationBufferPoolExtensionOption((AlterServerConfigurationBufferPoolExtensionOption.AlterServerConfigurationBufferPoolExtensionSizeOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (fun x -> OptionValue.FromCs(x, fragmentMapping))), (src.SizeUnit))  ))
        | _ -> (* :? ScriptDom.AlterServerConfigurationBufferPoolExtensionOption as src *)
          TSqlFragment.AlterServerConfigurationBufferPoolExtensionOption((AlterServerConfigurationBufferPoolExtensionOption.Base((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (fun x -> OptionValue.FromCs(x, fragmentMapping))))))
      | :? ScriptDom.AlterServerConfigurationDiagnosticsLogOption as src ->
        match src with
        | :? ScriptDom.AlterServerConfigurationDiagnosticsLogMaxSizeOption as src->
          TSqlFragment.AlterServerConfigurationDiagnosticsLogOption((AlterServerConfigurationDiagnosticsLogOption.AlterServerConfigurationDiagnosticsLogMaxSizeOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (fun x -> OptionValue.FromCs(x, fragmentMapping))), (src.SizeUnit))  ))
        | _ -> (* :? ScriptDom.AlterServerConfigurationDiagnosticsLogOption as src *)
          TSqlFragment.AlterServerConfigurationDiagnosticsLogOption((AlterServerConfigurationDiagnosticsLogOption.Base((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (fun x -> OptionValue.FromCs(x, fragmentMapping))))))
      | :? ScriptDom.AlterServerConfigurationExternalAuthenticationOption as src ->
        match src with
        | :? ScriptDom.AlterServerConfigurationExternalAuthenticationContainerOption as src->
          TSqlFragment.AlterServerConfigurationExternalAuthenticationOption((AlterServerConfigurationExternalAuthenticationOption.AlterServerConfigurationExternalAuthenticationContainerOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (fun x -> OptionValue.FromCs(x, fragmentMapping))), (src.Suboptions |> Seq.map (fun x -> AlterServerConfigurationExternalAuthenticationOption.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | _ -> (* :? ScriptDom.AlterServerConfigurationExternalAuthenticationOption as src *)
          TSqlFragment.AlterServerConfigurationExternalAuthenticationOption((AlterServerConfigurationExternalAuthenticationOption.Base((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (fun x -> OptionValue.FromCs(x, fragmentMapping))))))
      | :? ScriptDom.AlterServerConfigurationFailoverClusterPropertyOption as src ->
        TSqlFragment.AlterServerConfigurationFailoverClusterPropertyOption((src.OptionKind),(src.OptionValue |> Option.ofObj |> Option.map (fun x -> OptionValue.FromCs(x, fragmentMapping))))
      | :? ScriptDom.AlterServerConfigurationHadrClusterOption as src ->
        TSqlFragment.AlterServerConfigurationHadrClusterOption((src.IsLocal),(src.OptionKind),(src.OptionValue |> Option.ofObj |> Option.map (fun x -> OptionValue.FromCs(x, fragmentMapping))))
      | :? ScriptDom.AlterServerConfigurationSoftNumaOption as src ->
        TSqlFragment.AlterServerConfigurationSoftNumaOption((src.OptionKind),(src.OptionValue |> Option.ofObj |> Option.map (fun x -> OptionValue.FromCs(x, fragmentMapping))))
      | :? ScriptDom.AlterTableDropTableElement as src ->
        TSqlFragment.AlterTableDropTableElement((src.DropClusteredConstraintOptions |> Seq.map (fun x -> DropClusteredConstraintOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.TableElementType))
      | :? ScriptDom.ApplicationRoleOption as src ->
        TSqlFragment.ApplicationRoleOption((src.OptionKind),(src.Value |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.AssemblyName as src ->
        TSqlFragment.AssemblyName((src.ClassName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.AssemblyOption as src ->
        match src with
        | :? ScriptDom.OnOffAssemblyOption as src->
          TSqlFragment.AssemblyOption((AssemblyOption.OnOffAssemblyOption((src.OptionKind), (src.OptionState))  ))
        | :? ScriptDom.PermissionSetAssemblyOption as src->
          TSqlFragment.AssemblyOption((AssemblyOption.PermissionSetAssemblyOption((src.OptionKind), (src.PermissionSetOption))  ))
        | _ -> (* :? ScriptDom.AssemblyOption as src *)
          TSqlFragment.AssemblyOption((AssemblyOption.Base((src.OptionKind))))
      | :? ScriptDom.AtomicBlockOption as src ->
        match src with
        | :? ScriptDom.IdentifierAtomicBlockOption as src->
          TSqlFragment.AtomicBlockOption((AtomicBlockOption.IdentifierAtomicBlockOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.LiteralAtomicBlockOption as src->
          TSqlFragment.AtomicBlockOption((AtomicBlockOption.LiteralAtomicBlockOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.OnOffAtomicBlockOption as src->
          TSqlFragment.AtomicBlockOption((AtomicBlockOption.OnOffAtomicBlockOption((src.OptionKind), (src.OptionState))  ))
      | :? ScriptDom.AuditOption as src ->
        match src with
        | :? ScriptDom.AuditGuidAuditOption as src->
          TSqlFragment.AuditOption((AuditOption.AuditGuidAuditOption((src.Guid |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.OptionKind))  ))
        | :? ScriptDom.OnFailureAuditOption as src->
          TSqlFragment.AuditOption((AuditOption.OnFailureAuditOption((src.OnFailureAction), (src.OptionKind))  ))
        | :? ScriptDom.QueueDelayAuditOption as src->
          TSqlFragment.AuditOption((AuditOption.QueueDelayAuditOption((src.Delay |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.OptionKind))  ))
        | :? ScriptDom.StateAuditOption as src->
          TSqlFragment.AuditOption((AuditOption.StateAuditOption((src.OptionKind), (src.Value))  ))
      | :? ScriptDom.AuditSpecificationDetail as src ->
        match src with
        | :? ScriptDom.AuditActionGroupReference as src->
          TSqlFragment.AuditSpecificationDetail((AuditSpecificationDetail.AuditActionGroupReference((src.Group))  ))
        | :? ScriptDom.AuditActionSpecification as src->
          TSqlFragment.AuditSpecificationDetail((AuditSpecificationDetail.AuditActionSpecification((src.Actions |> Seq.map (fun src -> DatabaseAuditAction.DatabaseAuditAction((src.ActionKind))) |> List.ofSeq), (src.Principals |> Seq.map (fun src -> SecurityPrincipal.SecurityPrincipal((src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.PrincipalType))) |> List.ofSeq), (src.TargetObject |> Option.ofObj |> Option.map (fun x -> SecurityTargetObject.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.AuditSpecificationPart as src ->
        TSqlFragment.AuditSpecificationPart((src.Details |> Option.ofObj |> Option.map (fun x -> AuditSpecificationDetail.FromCs(x, fragmentMapping))),(src.IsDrop))
      | :? ScriptDom.AuditTarget as src ->
        TSqlFragment.AuditTarget((src.TargetKind),(src.TargetOptions |> Seq.map (fun x -> AuditTargetOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.AuditTargetOption as src ->
        match src with
        | :? ScriptDom.LiteralAuditTargetOption as src->
          TSqlFragment.AuditTargetOption((AuditTargetOption.LiteralAuditTargetOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.MaxRolloverFilesAuditTargetOption as src->
          TSqlFragment.AuditTargetOption((AuditTargetOption.MaxRolloverFilesAuditTargetOption((src.IsUnlimited), (src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.MaxSizeAuditTargetOption as src->
          TSqlFragment.AuditTargetOption((AuditTargetOption.MaxSizeAuditTargetOption((src.IsUnlimited), (src.OptionKind), (src.Size |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.Unit))  ))
        | :? ScriptDom.OnOffAuditTargetOption as src->
          TSqlFragment.AuditTargetOption((AuditTargetOption.OnOffAuditTargetOption((src.OptionKind), (src.Value))  ))
        | :? ScriptDom.RetentionDaysAuditTargetOption as src->
          TSqlFragment.AuditTargetOption((AuditTargetOption.RetentionDaysAuditTargetOption((src.Days |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.OptionKind))  ))
      | :? ScriptDom.AutomaticTuningOption as src ->
        match src with
        | :? ScriptDom.AutomaticTuningCreateIndexOption as src->
          TSqlFragment.AutomaticTuningOption((AutomaticTuningOption.AutomaticTuningCreateIndexOption((src.OptionKind), (src.Value))  ))
        | :? ScriptDom.AutomaticTuningDropIndexOption as src->
          TSqlFragment.AutomaticTuningOption((AutomaticTuningOption.AutomaticTuningDropIndexOption((src.OptionKind), (src.Value))  ))
        | :? ScriptDom.AutomaticTuningForceLastGoodPlanOption as src->
          TSqlFragment.AutomaticTuningOption((AutomaticTuningOption.AutomaticTuningForceLastGoodPlanOption((src.OptionKind), (src.Value))  ))
        | :? ScriptDom.AutomaticTuningMaintainIndexOption as src->
          TSqlFragment.AutomaticTuningOption((AutomaticTuningOption.AutomaticTuningMaintainIndexOption((src.OptionKind), (src.Value))  ))
        | _ -> (* :? ScriptDom.AutomaticTuningOption as src *)
          TSqlFragment.AutomaticTuningOption((AutomaticTuningOption.Base((src.OptionKind), (src.Value))))
      | :? ScriptDom.AvailabilityGroupOption as src ->
        match src with
        | :? ScriptDom.LiteralAvailabilityGroupOption as src->
          TSqlFragment.AvailabilityGroupOption((AvailabilityGroupOption.LiteralAvailabilityGroupOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.AvailabilityReplica as src ->
        TSqlFragment.AvailabilityReplica((src.Options |> Seq.map (fun x -> AvailabilityReplicaOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.ServerName |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))))
      | :? ScriptDom.AvailabilityReplicaOption as src ->
        match src with
        | :? ScriptDom.AvailabilityModeReplicaOption as src->
          TSqlFragment.AvailabilityReplicaOption((AvailabilityReplicaOption.AvailabilityModeReplicaOption((src.OptionKind), (src.Value))  ))
        | :? ScriptDom.FailoverModeReplicaOption as src->
          TSqlFragment.AvailabilityReplicaOption((AvailabilityReplicaOption.FailoverModeReplicaOption((src.OptionKind), (src.Value))  ))
        | :? ScriptDom.LiteralReplicaOption as src->
          TSqlFragment.AvailabilityReplicaOption((AvailabilityReplicaOption.LiteralReplicaOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.PrimaryRoleReplicaOption as src->
          TSqlFragment.AvailabilityReplicaOption((AvailabilityReplicaOption.PrimaryRoleReplicaOption((src.AllowConnections), (src.OptionKind))  ))
        | :? ScriptDom.SecondaryRoleReplicaOption as src->
          TSqlFragment.AvailabilityReplicaOption((AvailabilityReplicaOption.SecondaryRoleReplicaOption((src.AllowConnections), (src.OptionKind))  ))
      | :? ScriptDom.BackupOption as src ->
        match src with
        | :? ScriptDom.BackupEncryptionOption as src->
          TSqlFragment.BackupOption((BackupOption.BackupEncryptionOption((src.Algorithm), (src.Encryptor |> Option.ofObj |> Option.map (fun x -> CryptoMechanism.FromCs(x, fragmentMapping))), (src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  ))
        | _ -> (* :? ScriptDom.BackupOption as src *)
          TSqlFragment.BackupOption((BackupOption.Base((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))))
      | :? ScriptDom.BackupRestoreFileInfo as src ->
        TSqlFragment.BackupRestoreFileInfo((src.ItemKind),(src.Items |> Seq.map (fun x -> ValueExpression.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.BooleanExpression as src ->
        match src with
        | :? ScriptDom.BooleanBinaryExpression as src->
          TSqlFragment.BooleanExpression((BooleanExpression.BooleanBinaryExpression((src.BinaryExpressionType), (src.FirstExpression |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))), (src.SecondExpression |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.BooleanComparisonExpression as src->
          TSqlFragment.BooleanExpression((BooleanExpression.BooleanComparisonExpression((src.ComparisonType), (src.FirstExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.SecondExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.BooleanExpressionSnippet as src->
          TSqlFragment.BooleanExpression((BooleanExpression.BooleanExpressionSnippet((Option.ofObj (src.Script)))  ))
        | :? ScriptDom.BooleanIsNullExpression as src->
          TSqlFragment.BooleanExpression((BooleanExpression.BooleanIsNullExpression((src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.IsNot))  ))
        | :? ScriptDom.BooleanNotExpression as src->
          TSqlFragment.BooleanExpression((BooleanExpression.BooleanNotExpression((src.Expression |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.BooleanParenthesisExpression as src->
          TSqlFragment.BooleanExpression((BooleanExpression.BooleanParenthesisExpression((src.Expression |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.BooleanTernaryExpression as src->
          TSqlFragment.BooleanExpression((BooleanExpression.BooleanTernaryExpression((src.FirstExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.SecondExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.TernaryExpressionType), (src.ThirdExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.EventDeclarationCompareFunctionParameter as src->
          TSqlFragment.BooleanExpression((BooleanExpression.EventDeclarationCompareFunctionParameter((src.EventValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> EventSessionObjectName.FromCs(x, fragmentMapping))), (src.SourceDeclaration |> Option.ofObj |> Option.map (fun x -> SourceDeclaration.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.ExistsPredicate as src->
          TSqlFragment.BooleanExpression((BooleanExpression.ExistsPredicate((src.Subquery |> Option.ofObj |> Option.map (fun x -> ScalarSubquery.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.FullTextPredicate as src->
          TSqlFragment.BooleanExpression((BooleanExpression.FullTextPredicate((src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.FullTextFunctionType), (src.LanguageTerm |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))), (src.PropertyName |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))), (src.Value |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.GraphMatchCompositeExpression as src->
          TSqlFragment.BooleanExpression((BooleanExpression.GraphMatchCompositeExpression((src.ArrowOnRight), (src.Edge |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.LeftNode |> Option.ofObj |> Option.map (fun x -> GraphMatchNodeExpression.FromCs(x, fragmentMapping))), (src.RightNode |> Option.ofObj |> Option.map (fun x -> GraphMatchNodeExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.GraphMatchExpression as src->
          TSqlFragment.BooleanExpression((BooleanExpression.GraphMatchExpression((src.ArrowOnRight), (src.Edge |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.LeftNode |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.RightNode |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.GraphMatchLastNodePredicate as src->
          TSqlFragment.BooleanExpression((BooleanExpression.GraphMatchLastNodePredicate((src.LeftExpression |> Option.ofObj |> Option.map (fun x -> GraphMatchNodeExpression.FromCs(x, fragmentMapping))), (src.RightExpression |> Option.ofObj |> Option.map (fun x -> GraphMatchNodeExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.GraphMatchNodeExpression as src->
          TSqlFragment.BooleanExpression((BooleanExpression.GraphMatchNodeExpression((src.Node |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.UsesLastNode))  ))
        | :? ScriptDom.GraphMatchPredicate as src->
          TSqlFragment.BooleanExpression((BooleanExpression.GraphMatchPredicate((src.Expression |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.GraphMatchRecursivePredicate as src->
          TSqlFragment.BooleanExpression((BooleanExpression.GraphMatchRecursivePredicate((src.AnchorOnLeft), (src.Expression |> Seq.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Function), (src.OuterNodeExpression |> Option.ofObj |> Option.map (fun x -> GraphMatchNodeExpression.FromCs(x, fragmentMapping))), (src.RecursiveQuantifier |> Option.ofObj |> Option.map (fun x -> GraphRecursiveMatchQuantifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.GraphRecursiveMatchQuantifier as src->
          TSqlFragment.BooleanExpression((BooleanExpression.GraphRecursiveMatchQuantifier((src.IsPlusSign), (src.LowerLimit |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.UpperLimit |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.InPredicate as src->
          TSqlFragment.BooleanExpression((BooleanExpression.InPredicate((src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.NotDefined), (src.Subquery |> Option.ofObj |> Option.map (fun x -> ScalarSubquery.FromCs(x, fragmentMapping))), (src.Values |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.LikePredicate as src->
          TSqlFragment.BooleanExpression((BooleanExpression.LikePredicate((src.EscapeExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.FirstExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.NotDefined), (src.OdbcEscape), (src.SecondExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.SubqueryComparisonPredicate as src->
          TSqlFragment.BooleanExpression((BooleanExpression.SubqueryComparisonPredicate((src.ComparisonType), (src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.Subquery |> Option.ofObj |> Option.map (fun x -> ScalarSubquery.FromCs(x, fragmentMapping))), (src.SubqueryComparisonPredicateType))  ))
        | :? ScriptDom.TSEqualCall as src->
          TSqlFragment.BooleanExpression((BooleanExpression.TSEqualCall((src.FirstExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.SecondExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.UpdateCall as src->
          TSqlFragment.BooleanExpression((BooleanExpression.UpdateCall((src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.BoundingBoxParameter as src ->
        TSqlFragment.BoundingBoxParameter((src.Parameter),(src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.BrokerPriorityParameter as src ->
        TSqlFragment.BrokerPriorityParameter((src.IsDefaultOrAny),(src.ParameterType),(src.ParameterValue |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.BulkInsertOption as src ->
        match src with
        | :? ScriptDom.LiteralBulkInsertOption as src->
          TSqlFragment.BulkInsertOption((BulkInsertOption.LiteralBulkInsertOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.OrderBulkInsertOption as src->
          TSqlFragment.BulkInsertOption((BulkInsertOption.OrderBulkInsertOption((src.Columns |> Seq.map (fun src -> ColumnWithSortOrder.ColumnWithSortOrder((src.Column |> Option.ofObj |> Option.map (fun x -> ColumnReferenceExpression.FromCs(x, fragmentMapping))), (src.SortOrder))) |> List.ofSeq), (src.IsUnique), (src.OptionKind))  ))
        | _ -> (* :? ScriptDom.BulkInsertOption as src *)
          TSqlFragment.BulkInsertOption((BulkInsertOption.Base((src.OptionKind))))
      | :? ScriptDom.CallTarget as src ->
        match src with
        | :? ScriptDom.ExpressionCallTarget as src->
          TSqlFragment.CallTarget((CallTarget.ExpressionCallTarget((src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.MultiPartIdentifierCallTarget as src->
          TSqlFragment.CallTarget((CallTarget.MultiPartIdentifierCallTarget((src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.UserDefinedTypeCallTarget as src->
          TSqlFragment.CallTarget((CallTarget.UserDefinedTypeCallTarget((src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.CertificateOption as src ->
        TSqlFragment.CertificateOption((src.Kind),(src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ChangeTrackingOptionDetail as src ->
        match src with
        | :? ScriptDom.AutoCleanupChangeTrackingOptionDetail as src->
          TSqlFragment.ChangeTrackingOptionDetail((ChangeTrackingOptionDetail.AutoCleanupChangeTrackingOptionDetail((src.IsOn))  ))
        | :? ScriptDom.ChangeRetentionChangeTrackingOptionDetail as src->
          TSqlFragment.ChangeTrackingOptionDetail((ChangeTrackingOptionDetail.ChangeRetentionChangeTrackingOptionDetail((src.RetentionPeriod |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.Unit))  ))
      | :? ScriptDom.ColumnDefinitionBase as src ->
        match src with
        | :? ScriptDom.ColumnDefinition as src->
          TSqlFragment.ColumnDefinitionBase((ColumnDefinitionBase.ColumnDefinition((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ComputedColumnExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.Constraints |> Seq.map (fun x -> ConstraintDefinition.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.DefaultConstraint |> Option.ofObj |> Option.map (fun x -> DefaultConstraintDefinition.FromCs(x, fragmentMapping))), (src.Encryption |> Option.ofObj |> Option.map (fun x -> ColumnEncryptionDefinition.FromCs(x, fragmentMapping))), (Option.ofNullable (src.GeneratedAlways)), (src.IdentityOptions |> Option.ofObj |> Option.map (fun x -> IdentityOptions.FromCs(x, fragmentMapping))), (src.Index |> Option.ofObj |> Option.map (fun x -> IndexDefinition.FromCs(x, fragmentMapping))), (src.IsHidden), (src.IsMasked), (src.IsPersisted), (src.IsRowGuidCol), (src.MaskingFunction |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))), (src.StorageOptions |> Option.ofObj |> Option.map (fun x -> ColumnStorageOptions.FromCs(x, fragmentMapping))))  ))
        | _ -> (* :? ScriptDom.ColumnDefinitionBase as src *)
          TSqlFragment.ColumnDefinitionBase((ColumnDefinitionBase.Base((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))))))
      | :? ScriptDom.ColumnEncryptionDefinition as src ->
        TSqlFragment.ColumnEncryptionDefinition((src.Parameters |> Seq.map (fun x -> ColumnEncryptionDefinitionParameter.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.ColumnEncryptionDefinitionParameter as src ->
        match src with
        | :? ScriptDom.ColumnEncryptionAlgorithmParameter as src->
          TSqlFragment.ColumnEncryptionDefinitionParameter((ColumnEncryptionDefinitionParameter.ColumnEncryptionAlgorithmParameter((src.EncryptionAlgorithm |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))), (src.ParameterKind))  ))
        | :? ScriptDom.ColumnEncryptionKeyNameParameter as src->
          TSqlFragment.ColumnEncryptionDefinitionParameter((ColumnEncryptionDefinitionParameter.ColumnEncryptionKeyNameParameter((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ParameterKind))  ))
        | :? ScriptDom.ColumnEncryptionTypeParameter as src->
          TSqlFragment.ColumnEncryptionDefinitionParameter((ColumnEncryptionDefinitionParameter.ColumnEncryptionTypeParameter((src.EncryptionType), (src.ParameterKind))  ))
      | :? ScriptDom.ColumnEncryptionKeyValue as src ->
        TSqlFragment.ColumnEncryptionKeyValue((src.Parameters |> Seq.map (fun x -> ColumnEncryptionKeyValueParameter.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.ColumnEncryptionKeyValueParameter as src ->
        match src with
        | :? ScriptDom.ColumnEncryptionAlgorithmNameParameter as src->
          TSqlFragment.ColumnEncryptionKeyValueParameter((ColumnEncryptionKeyValueParameter.ColumnEncryptionAlgorithmNameParameter((src.Algorithm |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))), (src.ParameterKind))  ))
        | :? ScriptDom.ColumnMasterKeyNameParameter as src->
          TSqlFragment.ColumnEncryptionKeyValueParameter((ColumnEncryptionKeyValueParameter.ColumnMasterKeyNameParameter((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ParameterKind))  ))
        | :? ScriptDom.EncryptedValueParameter as src->
          TSqlFragment.ColumnEncryptionKeyValueParameter((ColumnEncryptionKeyValueParameter.EncryptedValueParameter((src.ParameterKind), (src.Value |> Option.ofObj |> Option.map (fun x -> BinaryLiteral.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.ColumnMasterKeyParameter as src ->
        match src with
        | :? ScriptDom.ColumnMasterKeyEnclaveComputationsParameter as src->
          TSqlFragment.ColumnMasterKeyParameter((ColumnMasterKeyParameter.ColumnMasterKeyEnclaveComputationsParameter((src.ParameterKind), (src.Signature |> Option.ofObj |> Option.map (fun x -> BinaryLiteral.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.ColumnMasterKeyPathParameter as src->
          TSqlFragment.ColumnMasterKeyParameter((ColumnMasterKeyParameter.ColumnMasterKeyPathParameter((src.ParameterKind), (src.Path |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.ColumnMasterKeyStoreProviderNameParameter as src->
          TSqlFragment.ColumnMasterKeyParameter((ColumnMasterKeyParameter.ColumnMasterKeyStoreProviderNameParameter((src.Name |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))), (src.ParameterKind))  ))
      | :? ScriptDom.ColumnStorageOptions as src ->
        TSqlFragment.ColumnStorageOptions((src.IsFileStream),(src.SparseOption))
      | :? ScriptDom.ColumnWithSortOrder as src ->
        TSqlFragment.ColumnWithSortOrder((src.Column |> Option.ofObj |> Option.map (fun x -> ColumnReferenceExpression.FromCs(x, fragmentMapping))),(src.SortOrder))
      | :? ScriptDom.CommonTableExpression as src ->
        TSqlFragment.CommonTableExpression((src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.ExpressionName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.QueryExpression |> Option.ofObj |> Option.map (fun x -> QueryExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CompressionPartitionRange as src ->
        TSqlFragment.CompressionPartitionRange((src.From |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.To |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ComputeClause as src ->
        TSqlFragment.ComputeClause((src.ByExpressions |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.ComputeFunctions |> Seq.map (fun src -> ComputeFunction.ComputeFunction((src.ComputeFunctionType), (src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq))
      | :? ScriptDom.ComputeFunction as src ->
        TSqlFragment.ComputeFunction((src.ComputeFunctionType),(src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ConstraintDefinition as src ->
        match src with
        | :? ScriptDom.CheckConstraintDefinition as src->
          TSqlFragment.ConstraintDefinition((ConstraintDefinition.CheckConstraintDefinition((src.CheckCondition |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))), (src.ConstraintIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.NotForReplication))  ))
        | :? ScriptDom.DefaultConstraintDefinition as src->
          TSqlFragment.ConstraintDefinition((ConstraintDefinition.DefaultConstraintDefinition((src.Column |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ConstraintIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.WithValues))  ))
        | :? ScriptDom.ForeignKeyConstraintDefinition as src->
          TSqlFragment.ConstraintDefinition((ConstraintDefinition.ForeignKeyConstraintDefinition((src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.ConstraintIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.DeleteAction), (src.NotForReplication), (src.ReferenceTableName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.ReferencedTableColumns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.UpdateAction))  ))
        | :? ScriptDom.GraphConnectionConstraintDefinition as src->
          TSqlFragment.ConstraintDefinition((ConstraintDefinition.GraphConnectionConstraintDefinition((src.ConstraintIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.DeleteAction), (src.FromNodeToNodeList |> Seq.map (fun src -> GraphConnectionBetweenNodes.GraphConnectionBetweenNodes((src.FromNode |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.ToNode |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))) |> List.ofSeq))  ))
        | :? ScriptDom.NullableConstraintDefinition as src->
          TSqlFragment.ConstraintDefinition((ConstraintDefinition.NullableConstraintDefinition((src.ConstraintIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Nullable))  ))
        | :? ScriptDom.UniqueConstraintDefinition as src->
          TSqlFragment.ConstraintDefinition((ConstraintDefinition.UniqueConstraintDefinition((Option.ofNullable (src.Clustered)), (src.Columns |> Seq.map (fun src -> ColumnWithSortOrder.ColumnWithSortOrder((src.Column |> Option.ofObj |> Option.map (fun x -> ColumnReferenceExpression.FromCs(x, fragmentMapping))), (src.SortOrder))) |> List.ofSeq), (src.ConstraintIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.FileStreamOn |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.IndexOptions |> Seq.map (fun x -> IndexOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.IndexType |> Option.ofObj |> Option.map (fun x -> IndexType.FromCs(x, fragmentMapping))), (Option.ofNullable (src.IsEnforced)), (src.IsPrimaryKey), (src.OnFileGroupOrPartitionScheme |> Option.ofObj |> Option.map (fun x -> FileGroupOrPartitionScheme.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.ContractMessage as src ->
        TSqlFragment.ContractMessage((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.SentBy))
      | :? ScriptDom.CopyOption as src ->
        TSqlFragment.CopyOption((src.Kind),(src.Value |> Option.ofObj |> Option.map (fun x -> CopyStatementOptionBase.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CopyStatementOptionBase as src ->
        match src with
        | :? ScriptDom.CopyColumnOption as src->
          TSqlFragment.CopyStatementOptionBase((CopyStatementOptionBase.CopyColumnOption((src.ColumnName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.DefaultValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.FieldNumber |> Option.ofObj |> Option.map (fun x -> IntegerLiteral.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CopyCredentialOption as src->
          TSqlFragment.CopyStatementOptionBase((CopyStatementOptionBase.CopyCredentialOption((src.Identity |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))), (src.Secret |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.ListTypeCopyOption as src->
          TSqlFragment.CopyStatementOptionBase((CopyStatementOptionBase.ListTypeCopyOption((src.Options |> Seq.map (fun x -> CopyStatementOptionBase.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.SingleValueTypeCopyOption as src->
          TSqlFragment.CopyStatementOptionBase((CopyStatementOptionBase.SingleValueTypeCopyOption((src.SingleValue |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.CreateLoginSource as src ->
        match src with
        | :? ScriptDom.AsymmetricKeyCreateLoginSource as src->
          TSqlFragment.CreateLoginSource((CreateLoginSource.AsymmetricKeyCreateLoginSource((src.Credential |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Key |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CertificateCreateLoginSource as src->
          TSqlFragment.CreateLoginSource((CreateLoginSource.CertificateCreateLoginSource((src.Certificate |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Credential |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.ExternalCreateLoginSource as src->
          TSqlFragment.CreateLoginSource((CreateLoginSource.ExternalCreateLoginSource((src.Options |> Seq.map (fun x -> PrincipalOption.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.PasswordCreateLoginSource as src->
          TSqlFragment.CreateLoginSource((CreateLoginSource.PasswordCreateLoginSource((src.Hashed), (src.MustChange), (src.Options |> Seq.map (fun x -> PrincipalOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Password |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.WindowsCreateLoginSource as src->
          TSqlFragment.CreateLoginSource((CreateLoginSource.WindowsCreateLoginSource((src.Options |> Seq.map (fun x -> PrincipalOption.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
      | :? ScriptDom.CryptoMechanism as src ->
        TSqlFragment.CryptoMechanism((src.CryptoMechanismType),(src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.PasswordOrSignature |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CursorDefinition as src ->
        TSqlFragment.CursorDefinition((src.Options |> Seq.map (fun src -> CursorOption.CursorOption((src.OptionKind))) |> List.ofSeq),(src.Select |> Option.ofObj |> Option.map (fun x -> SelectStatement.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CursorId as src ->
        TSqlFragment.CursorId((src.IsGlobal),(src.Name |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CursorOption as src ->
        TSqlFragment.CursorOption((src.OptionKind))
      | :? ScriptDom.DataModificationSpecification as src ->
        match src with
        | :? ScriptDom.InsertSpecification as src->
          TSqlFragment.DataModificationSpecification((DataModificationSpecification.InsertSpecification((src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.InsertOption), (src.InsertSource |> Option.ofObj |> Option.map (fun x -> InsertSource.FromCs(x, fragmentMapping))), (src.OutputClause |> Option.ofObj |> Option.map (fun x -> OutputClause.FromCs(x, fragmentMapping))), (src.OutputIntoClause |> Option.ofObj |> Option.map (fun x -> OutputIntoClause.FromCs(x, fragmentMapping))), (src.Target |> Option.ofObj |> Option.map (fun x -> TableReference.FromCs(x, fragmentMapping))), (src.TopRowFilter |> Option.ofObj |> Option.map (fun x -> TopRowFilter.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.MergeSpecification as src->
          TSqlFragment.DataModificationSpecification((DataModificationSpecification.MergeSpecification((src.ActionClauses |> Seq.map (fun src -> MergeActionClause.MergeActionClause((src.Action |> Option.ofObj |> Option.map (fun x -> MergeAction.FromCs(x, fragmentMapping))), (src.Condition), (src.SearchCondition |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.OutputClause |> Option.ofObj |> Option.map (fun x -> OutputClause.FromCs(x, fragmentMapping))), (src.OutputIntoClause |> Option.ofObj |> Option.map (fun x -> OutputIntoClause.FromCs(x, fragmentMapping))), (src.SearchCondition |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))), (src.TableAlias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.TableReference |> Option.ofObj |> Option.map (fun x -> TableReference.FromCs(x, fragmentMapping))), (src.Target |> Option.ofObj |> Option.map (fun x -> TableReference.FromCs(x, fragmentMapping))), (src.TopRowFilter |> Option.ofObj |> Option.map (fun x -> TopRowFilter.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.UpdateDeleteSpecificationBase as src->
          TSqlFragment.DataModificationSpecification((DataModificationSpecification.UpdateDeleteSpecificationBase((UpdateDeleteSpecificationBase.FromCs(src, fragmentMapping)))  ))
      | :? ScriptDom.DataTypeReference as src ->
        match src with
        | :? ScriptDom.ParameterizedDataTypeReference as src->
          TSqlFragment.DataTypeReference((DataTypeReference.ParameterizedDataTypeReference((ParameterizedDataTypeReference.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.XmlDataTypeReference as src->
          TSqlFragment.DataTypeReference((DataTypeReference.XmlDataTypeReference((src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.XmlDataTypeOption), (src.XmlSchemaCollection |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.DatabaseAuditAction as src ->
        TSqlFragment.DatabaseAuditAction((src.ActionKind))
      | :? ScriptDom.DatabaseConfigurationClearOption as src ->
        TSqlFragment.DatabaseConfigurationClearOption((src.OptionKind),(src.PlanHandle |> Option.ofObj |> Option.map (fun x -> BinaryLiteral.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DatabaseConfigurationSetOption as src ->
        match src with
        | :? ScriptDom.GenericConfigurationOption as src->
          TSqlFragment.DatabaseConfigurationSetOption((DatabaseConfigurationSetOption.GenericConfigurationOption((src.GenericOptionKind |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.GenericOptionState |> Option.ofObj |> Option.map (fun x -> IdentifierOrScalarExpression.FromCs(x, fragmentMapping))), (src.OptionKind))  ))
        | :? ScriptDom.MaxDopConfigurationOption as src->
          TSqlFragment.DatabaseConfigurationSetOption((DatabaseConfigurationSetOption.MaxDopConfigurationOption((src.GenericOptionKind |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.OptionKind), (src.Primary), (src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.OnOffPrimaryConfigurationOption as src->
          TSqlFragment.DatabaseConfigurationSetOption((DatabaseConfigurationSetOption.OnOffPrimaryConfigurationOption((src.GenericOptionKind |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.OptionKind), (src.OptionState))  ))
        | _ -> (* :? ScriptDom.DatabaseConfigurationSetOption as src *)
          TSqlFragment.DatabaseConfigurationSetOption((DatabaseConfigurationSetOption.Base((src.GenericOptionKind |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.OptionKind))))
      | :? ScriptDom.DatabaseOption as src ->
        match src with
        | :? ScriptDom.AcceleratedDatabaseRecoveryDatabaseOption as src->
          TSqlFragment.DatabaseOption((DatabaseOption.AcceleratedDatabaseRecoveryDatabaseOption((src.OptionKind), (src.OptionState))  ))
        | :? ScriptDom.AutomaticTuningDatabaseOption as src->
          TSqlFragment.DatabaseOption((DatabaseOption.AutomaticTuningDatabaseOption((src.AutomaticTuningState), (src.OptionKind), (src.Options |> Seq.map (fun x -> AutomaticTuningOption.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.CatalogCollationOption as src->
          TSqlFragment.DatabaseOption((DatabaseOption.CatalogCollationOption((Option.ofNullable (src.CatalogCollation)), (src.OptionKind))  ))
        | :? ScriptDom.ChangeTrackingDatabaseOption as src->
          TSqlFragment.DatabaseOption((DatabaseOption.ChangeTrackingDatabaseOption((src.Details |> Seq.map (fun x -> ChangeTrackingOptionDetail.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.OptionKind), (src.OptionState))  ))
        | :? ScriptDom.ContainmentDatabaseOption as src->
          TSqlFragment.DatabaseOption((DatabaseOption.ContainmentDatabaseOption((src.OptionKind), (src.Value))  ))
        | :? ScriptDom.CursorDefaultDatabaseOption as src->
          TSqlFragment.DatabaseOption((DatabaseOption.CursorDefaultDatabaseOption((src.IsLocal), (src.OptionKind))  ))
        | :? ScriptDom.DelayedDurabilityDatabaseOption as src->
          TSqlFragment.DatabaseOption((DatabaseOption.DelayedDurabilityDatabaseOption((src.OptionKind), (src.Value))  ))
        | :? ScriptDom.FileStreamDatabaseOption as src->
          TSqlFragment.DatabaseOption((DatabaseOption.FileStreamDatabaseOption((src.DirectoryName |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (Option.ofNullable (src.NonTransactedAccess)), (src.OptionKind))  ))
        | :? ScriptDom.HadrDatabaseOption as src->
          TSqlFragment.DatabaseOption((DatabaseOption.HadrDatabaseOption((HadrDatabaseOption.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.IdentifierDatabaseOption as src->
          TSqlFragment.DatabaseOption((DatabaseOption.IdentifierDatabaseOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.LiteralDatabaseOption as src->
          TSqlFragment.DatabaseOption((DatabaseOption.LiteralDatabaseOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.MaxSizeDatabaseOption as src->
          TSqlFragment.DatabaseOption((DatabaseOption.MaxSizeDatabaseOption((src.MaxSize |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.OptionKind), (src.Units))  ))
        | :? ScriptDom.OnOffDatabaseOption as src->
          TSqlFragment.DatabaseOption((DatabaseOption.OnOffDatabaseOption((OnOffDatabaseOption.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.PageVerifyDatabaseOption as src->
          TSqlFragment.DatabaseOption((DatabaseOption.PageVerifyDatabaseOption((src.OptionKind), (src.Value))  ))
        | :? ScriptDom.ParameterizationDatabaseOption as src->
          TSqlFragment.DatabaseOption((DatabaseOption.ParameterizationDatabaseOption((src.IsSimple), (src.OptionKind))  ))
        | :? ScriptDom.PartnerDatabaseOption as src->
          TSqlFragment.DatabaseOption((DatabaseOption.PartnerDatabaseOption((src.OptionKind), (src.PartnerOption), (src.PartnerServer |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.Timeout |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.QueryStoreDatabaseOption as src->
          TSqlFragment.DatabaseOption((DatabaseOption.QueryStoreDatabaseOption((src.Clear), (src.ClearAll), (src.OptionKind), (src.OptionState), (src.Options |> Seq.map (fun x -> QueryStoreOption.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.RecoveryDatabaseOption as src->
          TSqlFragment.DatabaseOption((DatabaseOption.RecoveryDatabaseOption((src.OptionKind), (src.Value))  ))
        | :? ScriptDom.RemoteDataArchiveDatabaseOption as src->
          TSqlFragment.DatabaseOption((DatabaseOption.RemoteDataArchiveDatabaseOption((src.OptionKind), (src.OptionState), (src.Settings |> Seq.map (fun x -> RemoteDataArchiveDatabaseSetting.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.TargetRecoveryTimeDatabaseOption as src->
          TSqlFragment.DatabaseOption((DatabaseOption.TargetRecoveryTimeDatabaseOption((src.OptionKind), (src.RecoveryTime |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.Unit))  ))
        | :? ScriptDom.WitnessDatabaseOption as src->
          TSqlFragment.DatabaseOption((DatabaseOption.WitnessDatabaseOption((src.IsOff), (src.OptionKind), (src.WitnessServer |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | _ -> (* :? ScriptDom.DatabaseOption as src *)
          TSqlFragment.DatabaseOption((DatabaseOption.Base((src.OptionKind))))
      | :? ScriptDom.DbccNamedLiteral as src ->
        TSqlFragment.DbccNamedLiteral((Option.ofObj (src.Name)),(src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DbccOption as src ->
        TSqlFragment.DbccOption((src.OptionKind))
      | :? ScriptDom.DeclareTableVariableBody as src ->
        TSqlFragment.DeclareTableVariableBody((src.AsDefined),(src.Definition |> Option.ofObj |> Option.map (fun x -> TableDefinition.FromCs(x, fragmentMapping))),(src.VariableName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DeclareVariableElement as src ->
        match src with
        | :? ScriptDom.ProcedureParameter as src->
          TSqlFragment.DeclareVariableElement((DeclareVariableElement.ProcedureParameter((src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.IsVarying), (src.Modifier), (src.Nullable |> Option.ofObj |> Option.map (fun x -> NullableConstraintDefinition.FromCs(x, fragmentMapping))), (src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.VariableName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | _ -> (* :? ScriptDom.DeclareVariableElement as src *)
          TSqlFragment.DeclareVariableElement((DeclareVariableElement.Base((src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.Nullable |> Option.ofObj |> Option.map (fun x -> NullableConstraintDefinition.FromCs(x, fragmentMapping))), (src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.VariableName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))))
      | :? ScriptDom.DeviceInfo as src ->
        TSqlFragment.DeviceInfo((src.DeviceType),(src.LogicalDevice |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))),(src.PhysicalDevice |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DialogOption as src ->
        match src with
        | :? ScriptDom.OnOffDialogOption as src->
          TSqlFragment.DialogOption((DialogOption.OnOffDialogOption((src.OptionKind), (src.OptionState))  ))
        | :? ScriptDom.ScalarExpressionDialogOption as src->
          TSqlFragment.DialogOption((DialogOption.ScalarExpressionDialogOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.DiskStatementOption as src ->
        TSqlFragment.DiskStatementOption((src.OptionKind),(src.Value |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropClusteredConstraintOption as src ->
        match src with
        | :? ScriptDom.DropClusteredConstraintMoveOption as src->
          TSqlFragment.DropClusteredConstraintOption((DropClusteredConstraintOption.DropClusteredConstraintMoveOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (fun x -> FileGroupOrPartitionScheme.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropClusteredConstraintStateOption as src->
          TSqlFragment.DropClusteredConstraintOption((DropClusteredConstraintOption.DropClusteredConstraintStateOption((src.OptionKind), (src.OptionState))  ))
        | :? ScriptDom.DropClusteredConstraintValueOption as src->
          TSqlFragment.DropClusteredConstraintOption((DropClusteredConstraintOption.DropClusteredConstraintValueOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropClusteredConstraintWaitAtLowPriorityLockOption as src->
          TSqlFragment.DropClusteredConstraintOption((DropClusteredConstraintOption.DropClusteredConstraintWaitAtLowPriorityLockOption((src.OptionKind), (src.Options |> Seq.map (fun x -> LowPriorityLockWaitOption.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
      | :? ScriptDom.DropIndexClauseBase as src ->
        match src with
        | :? ScriptDom.BackwardsCompatibleDropIndexClause as src->
          TSqlFragment.DropIndexClauseBase((DropIndexClauseBase.BackwardsCompatibleDropIndexClause((src.Index |> Option.ofObj |> Option.map (fun x -> ChildObjectName.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropIndexClause as src->
          TSqlFragment.DropIndexClauseBase((DropIndexClauseBase.DropIndexClause((src.Index |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Object |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.Options |> Seq.map (fun x -> IndexOption.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
      | :? ScriptDom.EncryptionSource as src ->
        match src with
        | :? ScriptDom.AssemblyEncryptionSource as src->
          TSqlFragment.EncryptionSource((EncryptionSource.AssemblyEncryptionSource((src.Assembly |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.FileEncryptionSource as src->
          TSqlFragment.EncryptionSource((EncryptionSource.FileEncryptionSource((src.File |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.IsExecutable))  ))
        | :? ScriptDom.ProviderEncryptionSource as src->
          TSqlFragment.EncryptionSource((EncryptionSource.ProviderEncryptionSource((src.KeyOptions |> Seq.map (fun x -> KeyOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.EndpointAffinity as src ->
        TSqlFragment.EndpointAffinity((src.Kind),(src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.EndpointProtocolOption as src ->
        match src with
        | :? ScriptDom.AuthenticationEndpointProtocolOption as src->
          TSqlFragment.EndpointProtocolOption((EndpointProtocolOption.AuthenticationEndpointProtocolOption((src.AuthenticationTypes), (src.Kind))  ))
        | :? ScriptDom.CompressionEndpointProtocolOption as src->
          TSqlFragment.EndpointProtocolOption((EndpointProtocolOption.CompressionEndpointProtocolOption((src.IsEnabled), (src.Kind))  ))
        | :? ScriptDom.ListenerIPEndpointProtocolOption as src->
          TSqlFragment.EndpointProtocolOption((EndpointProtocolOption.ListenerIPEndpointProtocolOption((src.IPv4PartOne |> Option.ofObj |> Option.map (fun x -> IPv4.FromCs(x, fragmentMapping))), (src.IPv4PartTwo |> Option.ofObj |> Option.map (fun x -> IPv4.FromCs(x, fragmentMapping))), (src.IPv6 |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.IsAll), (src.Kind))  ))
        | :? ScriptDom.LiteralEndpointProtocolOption as src->
          TSqlFragment.EndpointProtocolOption((EndpointProtocolOption.LiteralEndpointProtocolOption((src.Kind), (src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.PortsEndpointProtocolOption as src->
          TSqlFragment.EndpointProtocolOption((EndpointProtocolOption.PortsEndpointProtocolOption((src.Kind), (src.PortTypes))  ))
      | :? ScriptDom.EventDeclaration as src ->
        TSqlFragment.EventDeclaration((src.EventDeclarationActionParameters |> Seq.map (fun src -> EventSessionObjectName.EventSessionObjectName((src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.EventDeclarationPredicateParameter |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))),(src.EventDeclarationSetParameters |> Seq.map (fun src -> EventDeclarationSetParameter.EventDeclarationSetParameter((src.EventField |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.EventValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.ObjectName |> Option.ofObj |> Option.map (fun x -> EventSessionObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.EventDeclarationSetParameter as src ->
        TSqlFragment.EventDeclarationSetParameter((src.EventField |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.EventValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.EventNotificationObjectScope as src ->
        TSqlFragment.EventNotificationObjectScope((src.QueueName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.Target))
      | :? ScriptDom.EventSessionObjectName as src ->
        TSqlFragment.EventSessionObjectName((src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.EventTypeGroupContainer as src ->
        match src with
        | :? ScriptDom.EventGroupContainer as src->
          TSqlFragment.EventTypeGroupContainer((EventTypeGroupContainer.EventGroupContainer((src.EventGroup))  ))
        | :? ScriptDom.EventTypeContainer as src->
          TSqlFragment.EventTypeGroupContainer((EventTypeGroupContainer.EventTypeContainer((src.EventType))  ))
      | :? ScriptDom.ExecutableEntity as src ->
        match src with
        | :? ScriptDom.ExecutableProcedureReference as src->
          TSqlFragment.ExecutableEntity((ExecutableEntity.ExecutableProcedureReference((src.AdHocDataSource |> Option.ofObj |> Option.map (fun x -> AdHocDataSource.FromCs(x, fragmentMapping))), (src.Parameters |> Seq.map (fun src -> ExecuteParameter.ExecuteParameter((src.IsOutput), (src.ParameterValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.Variable |> Option.ofObj |> Option.map (fun x -> VariableReference.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.ProcedureReference |> Option.ofObj |> Option.map (fun x -> ProcedureReferenceName.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.ExecutableStringList as src->
          TSqlFragment.ExecutableEntity((ExecutableEntity.ExecutableStringList((src.Parameters |> Seq.map (fun src -> ExecuteParameter.ExecuteParameter((src.IsOutput), (src.ParameterValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.Variable |> Option.ofObj |> Option.map (fun x -> VariableReference.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.Strings |> Seq.map (fun x -> ValueExpression.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
      | :? ScriptDom.ExecuteAsClause as src ->
        TSqlFragment.ExecuteAsClause((src.ExecuteAsOption),(src.Literal |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ExecuteContext as src ->
        TSqlFragment.ExecuteContext((src.Kind),(src.Principal |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ExecuteOption as src ->
        match src with
        | :? ScriptDom.ResultSetsExecuteOption as src->
          TSqlFragment.ExecuteOption((ExecuteOption.ResultSetsExecuteOption((src.Definitions |> Seq.map (fun x -> ResultSetDefinition.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.OptionKind), (src.ResultSetsOptionKind))  ))
        | _ -> (* :? ScriptDom.ExecuteOption as src *)
          TSqlFragment.ExecuteOption((ExecuteOption.Base((src.OptionKind))))
      | :? ScriptDom.ExecuteParameter as src ->
        TSqlFragment.ExecuteParameter((src.IsOutput),(src.ParameterValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.Variable |> Option.ofObj |> Option.map (fun x -> VariableReference.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ExecuteSpecification as src ->
        TSqlFragment.ExecuteSpecification((src.ExecutableEntity |> Option.ofObj |> Option.map (fun x -> ExecutableEntity.FromCs(x, fragmentMapping))),(src.ExecuteContext |> Option.ofObj |> Option.map (fun x -> ExecuteContext.FromCs(x, fragmentMapping))),(src.LinkedServer |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Variable |> Option.ofObj |> Option.map (fun x -> VariableReference.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ExpressionWithSortOrder as src ->
        TSqlFragment.ExpressionWithSortOrder((src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.SortOrder))
      | :? ScriptDom.ExternalDataSourceOption as src ->
        match src with
        | :? ScriptDom.ExternalDataSourceLiteralOrIdentifierOption as src->
          TSqlFragment.ExternalDataSourceOption((ExternalDataSourceOption.ExternalDataSourceLiteralOrIdentifierOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.ExternalFileFormatOption as src ->
        match src with
        | :? ScriptDom.ExternalFileFormatContainerOption as src->
          TSqlFragment.ExternalFileFormatOption((ExternalFileFormatOption.ExternalFileFormatContainerOption((src.OptionKind), (src.Suboptions |> Seq.map (fun x -> ExternalFileFormatOption.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.ExternalFileFormatLiteralOption as src->
          TSqlFragment.ExternalFileFormatOption((ExternalFileFormatOption.ExternalFileFormatLiteralOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.ExternalFileFormatUseDefaultTypeOption as src->
          TSqlFragment.ExternalFileFormatOption((ExternalFileFormatOption.ExternalFileFormatUseDefaultTypeOption((src.ExternalFileFormatUseDefaultType), (src.OptionKind))  ))
      | :? ScriptDom.ExternalResourcePoolAffinitySpecification as src ->
        TSqlFragment.ExternalResourcePoolAffinitySpecification((src.AffinityType),(src.IsAuto),(src.ParameterValue |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.PoolAffinityRanges |> Seq.map (fun x -> LiteralRange.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.ExternalResourcePoolParameter as src ->
        TSqlFragment.ExternalResourcePoolParameter((src.AffinitySpecification |> Option.ofObj |> Option.map (fun x -> ExternalResourcePoolAffinitySpecification.FromCs(x, fragmentMapping))),(src.ParameterType),(src.ParameterValue |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ExternalTableColumnDefinition as src ->
        TSqlFragment.ExternalTableColumnDefinition((src.ColumnDefinition |> Option.ofObj |> Option.map (fun x -> ColumnDefinitionBase.FromCs(x, fragmentMapping))),(src.NullableConstraint |> Option.ofObj |> Option.map (fun x -> NullableConstraintDefinition.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ExternalTableDistributionPolicy as src ->
        match src with
        | :? ScriptDom.ExternalTableReplicatedDistributionPolicy as src->
          TSqlFragment.ExternalTableDistributionPolicy((ExternalTableDistributionPolicy.ExternalTableReplicatedDistributionPolicy  ))
        | :? ScriptDom.ExternalTableRoundRobinDistributionPolicy as src->
          TSqlFragment.ExternalTableDistributionPolicy((ExternalTableDistributionPolicy.ExternalTableRoundRobinDistributionPolicy  ))
        | :? ScriptDom.ExternalTableShardedDistributionPolicy as src->
          TSqlFragment.ExternalTableDistributionPolicy((ExternalTableDistributionPolicy.ExternalTableShardedDistributionPolicy((src.ShardingColumn |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.ExternalTableOption as src ->
        match src with
        | :? ScriptDom.ExternalTableDistributionOption as src->
          TSqlFragment.ExternalTableOption((ExternalTableOption.ExternalTableDistributionOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> ExternalTableDistributionPolicy.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.ExternalTableLiteralOrIdentifierOption as src->
          TSqlFragment.ExternalTableOption((ExternalTableOption.ExternalTableLiteralOrIdentifierOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.ExternalTableRejectTypeOption as src->
          TSqlFragment.ExternalTableOption((ExternalTableOption.ExternalTableRejectTypeOption((src.OptionKind), (src.Value))  ))
      | :? ScriptDom.FederationScheme as src ->
        TSqlFragment.FederationScheme((src.ColumnName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.DistributionName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.FetchType as src ->
        TSqlFragment.FetchType((src.Orientation),(src.RowOffset |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.FileDeclaration as src ->
        TSqlFragment.FileDeclaration((src.IsPrimary),(src.Options |> Seq.map (fun x -> FileDeclarationOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.FileDeclarationOption as src ->
        match src with
        | :? ScriptDom.FileGrowthFileDeclarationOption as src->
          TSqlFragment.FileDeclarationOption((FileDeclarationOption.FileGrowthFileDeclarationOption((src.GrowthIncrement |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.OptionKind), (src.Units))  ))
        | :? ScriptDom.FileNameFileDeclarationOption as src->
          TSqlFragment.FileDeclarationOption((FileDeclarationOption.FileNameFileDeclarationOption((src.OSFileName |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.OptionKind))  ))
        | :? ScriptDom.MaxSizeFileDeclarationOption as src->
          TSqlFragment.FileDeclarationOption((FileDeclarationOption.MaxSizeFileDeclarationOption((src.MaxSize |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.OptionKind), (src.Units), (src.Unlimited))  ))
        | :? ScriptDom.NameFileDeclarationOption as src->
          TSqlFragment.FileDeclarationOption((FileDeclarationOption.NameFileDeclarationOption((src.IsNewName), (src.LogicalFileName |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.OptionKind))  ))
        | :? ScriptDom.SizeFileDeclarationOption as src->
          TSqlFragment.FileDeclarationOption((FileDeclarationOption.SizeFileDeclarationOption((src.OptionKind), (src.Size |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.Units))  ))
        | _ -> (* :? ScriptDom.FileDeclarationOption as src *)
          TSqlFragment.FileDeclarationOption((FileDeclarationOption.Base((src.OptionKind))))
      | :? ScriptDom.FileGroupDefinition as src ->
        TSqlFragment.FileGroupDefinition((src.ContainsFileStream),(src.ContainsMemoryOptimizedData),(src.FileDeclarations |> Seq.map (fun src -> FileDeclaration.FileDeclaration((src.IsPrimary), (src.Options |> Seq.map (fun x -> FileDeclarationOption.FromCs(x, fragmentMapping)) |> List.ofSeq))) |> List.ofSeq),(src.IsDefault),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.FileGroupOrPartitionScheme as src ->
        TSqlFragment.FileGroupOrPartitionScheme((src.Name |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))),(src.PartitionSchemeColumns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.ForClause as src ->
        match src with
        | :? ScriptDom.BrowseForClause as src->
          TSqlFragment.ForClause((ForClause.BrowseForClause  ))
        | :? ScriptDom.JsonForClause as src->
          TSqlFragment.ForClause((ForClause.JsonForClause((src.Options |> Seq.map (fun src -> JsonForClauseOption.JsonForClauseOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq))  ))
        | :? ScriptDom.JsonForClauseOption as src->
          TSqlFragment.ForClause((ForClause.JsonForClauseOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.ReadOnlyForClause as src->
          TSqlFragment.ForClause((ForClause.ReadOnlyForClause  ))
        | :? ScriptDom.UpdateForClause as src->
          TSqlFragment.ForClause((ForClause.UpdateForClause((src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq))  ))
        | :? ScriptDom.XmlForClause as src->
          TSqlFragment.ForClause((ForClause.XmlForClause((src.Options |> Seq.map (fun src -> XmlForClauseOption.XmlForClauseOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq))  ))
        | :? ScriptDom.XmlForClauseOption as src->
          TSqlFragment.ForClause((ForClause.XmlForClauseOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.FromClause as src ->
        TSqlFragment.FromClause((src.TableReferences |> Seq.map (fun x -> TableReference.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.FullTextCatalogAndFileGroup as src ->
        TSqlFragment.FullTextCatalogAndFileGroup((src.CatalogName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.FileGroupIsFirst),(src.FileGroupName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.FullTextCatalogOption as src ->
        match src with
        | :? ScriptDom.OnOffFullTextCatalogOption as src->
          TSqlFragment.FullTextCatalogOption((FullTextCatalogOption.OnOffFullTextCatalogOption((src.OptionKind), (src.OptionState))  ))
      | :? ScriptDom.FullTextIndexColumn as src ->
        TSqlFragment.FullTextIndexColumn((src.LanguageTerm |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.StatisticalSemantics),(src.TypeColumn |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.FullTextIndexOption as src ->
        match src with
        | :? ScriptDom.ChangeTrackingFullTextIndexOption as src->
          TSqlFragment.FullTextIndexOption((FullTextIndexOption.ChangeTrackingFullTextIndexOption((src.OptionKind), (src.Value))  ))
        | :? ScriptDom.SearchPropertyListFullTextIndexOption as src->
          TSqlFragment.FullTextIndexOption((FullTextIndexOption.SearchPropertyListFullTextIndexOption((src.IsOff), (src.OptionKind), (src.PropertyListName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.StopListFullTextIndexOption as src->
          TSqlFragment.FullTextIndexOption((FullTextIndexOption.StopListFullTextIndexOption((src.IsOff), (src.OptionKind), (src.StopListName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.FullTextStopListAction as src ->
        TSqlFragment.FullTextStopListAction((src.IsAdd),(src.IsAll),(src.LanguageTerm |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))),(src.StopWord |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.FunctionOption as src ->
        match src with
        | :? ScriptDom.ExecuteAsFunctionOption as src->
          TSqlFragment.FunctionOption((FunctionOption.ExecuteAsFunctionOption((src.ExecuteAs |> Option.ofObj |> Option.map (fun x -> ExecuteAsClause.FromCs(x, fragmentMapping))), (src.OptionKind))  ))
        | :? ScriptDom.InlineFunctionOption as src->
          TSqlFragment.FunctionOption((FunctionOption.InlineFunctionOption((src.OptionKind), (src.OptionState))  ))
        | _ -> (* :? ScriptDom.FunctionOption as src *)
          TSqlFragment.FunctionOption((FunctionOption.Base((src.OptionKind))))
      | :? ScriptDom.FunctionReturnType as src ->
        match src with
        | :? ScriptDom.ScalarFunctionReturnType as src->
          TSqlFragment.FunctionReturnType((FunctionReturnType.ScalarFunctionReturnType((src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.SelectFunctionReturnType as src->
          TSqlFragment.FunctionReturnType((FunctionReturnType.SelectFunctionReturnType((src.SelectStatement |> Option.ofObj |> Option.map (fun x -> SelectStatement.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.TableValuedFunctionReturnType as src->
          TSqlFragment.FunctionReturnType((FunctionReturnType.TableValuedFunctionReturnType((src.DeclareTableVariableBody |> Option.ofObj |> Option.map (fun x -> DeclareTableVariableBody.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.GraphConnectionBetweenNodes as src ->
        TSqlFragment.GraphConnectionBetweenNodes((src.FromNode |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.ToNode |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.GridParameter as src ->
        TSqlFragment.GridParameter((src.Parameter),(src.Value))
      | :? ScriptDom.GroupByClause as src ->
        TSqlFragment.GroupByClause((src.All),(src.GroupByOption),(src.GroupingSpecifications |> Seq.map (fun x -> GroupingSpecification.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.GroupingSpecification as src ->
        match src with
        | :? ScriptDom.CompositeGroupingSpecification as src->
          TSqlFragment.GroupingSpecification((GroupingSpecification.CompositeGroupingSpecification((src.Items |> Seq.map (fun x -> GroupingSpecification.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.CubeGroupingSpecification as src->
          TSqlFragment.GroupingSpecification((GroupingSpecification.CubeGroupingSpecification((src.Arguments |> Seq.map (fun x -> GroupingSpecification.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.ExpressionGroupingSpecification as src->
          TSqlFragment.GroupingSpecification((GroupingSpecification.ExpressionGroupingSpecification((src.DistributedAggregation), (src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.GrandTotalGroupingSpecification as src->
          TSqlFragment.GroupingSpecification((GroupingSpecification.GrandTotalGroupingSpecification  ))
        | :? ScriptDom.GroupingSetsGroupingSpecification as src->
          TSqlFragment.GroupingSpecification((GroupingSpecification.GroupingSetsGroupingSpecification((src.Sets |> Seq.map (fun x -> GroupingSpecification.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.RollupGroupingSpecification as src->
          TSqlFragment.GroupingSpecification((GroupingSpecification.RollupGroupingSpecification((src.Arguments |> Seq.map (fun x -> GroupingSpecification.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
      | :? ScriptDom.HavingClause as src ->
        TSqlFragment.HavingClause((src.SearchCondition |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.IPv4 as src ->
        TSqlFragment.IPv4((src.OctetFour |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.OctetOne |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.OctetThree |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.OctetTwo |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.Identifier as src ->
        match src with
        | :? ScriptDom.IdentifierSnippet as src->
          TSqlFragment.Identifier((Identifier.IdentifierSnippet((src.QuoteType), (Option.ofObj (src.Script)), (Option.ofObj (src.Value)))  ))
        | :? ScriptDom.SqlCommandIdentifier as src->
          TSqlFragment.Identifier((Identifier.SqlCommandIdentifier((src.QuoteType), (Option.ofObj (src.Value)))  ))
        | _ -> (* :? ScriptDom.Identifier as src *)
          TSqlFragment.Identifier((Identifier.Base((src.QuoteType), (Option.ofObj (src.Value)))))
      | :? ScriptDom.IdentifierOrScalarExpression as src ->
        TSqlFragment.IdentifierOrScalarExpression((src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.ScalarExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.IdentifierOrValueExpression as src ->
        TSqlFragment.IdentifierOrValueExpression((src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(Option.ofObj (src.Value)),(src.ValueExpression |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.IdentityOptions as src ->
        TSqlFragment.IdentityOptions((src.IdentityIncrement |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.IdentitySeed |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.IsIdentityNotForReplication))
      | :? ScriptDom.IndexOption as src ->
        match src with
        | :? ScriptDom.CompressionDelayIndexOption as src->
          TSqlFragment.IndexOption((IndexOption.CompressionDelayIndexOption((src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.OptionKind), (src.TimeUnit))  ))
        | :? ScriptDom.DataCompressionOption as src->
          TSqlFragment.IndexOption((IndexOption.DataCompressionOption((src.CompressionLevel), (src.OptionKind), (src.PartitionRanges |> Seq.map (fun src -> CompressionPartitionRange.CompressionPartitionRange((src.From |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.To |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq))  ))
        | :? ScriptDom.FileStreamOnDropIndexOption as src->
          TSqlFragment.IndexOption((IndexOption.FileStreamOnDropIndexOption((src.FileStreamOn |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.OptionKind))  ))
        | :? ScriptDom.IndexExpressionOption as src->
          TSqlFragment.IndexOption((IndexOption.IndexExpressionOption((src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.OptionKind))  ))
        | :? ScriptDom.IndexStateOption as src->
          TSqlFragment.IndexOption((IndexOption.IndexStateOption((IndexStateOption.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.MaxDurationOption as src->
          TSqlFragment.IndexOption((IndexOption.MaxDurationOption((src.MaxDuration |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.OptionKind), (Option.ofNullable (src.Unit)))  ))
        | :? ScriptDom.MoveToDropIndexOption as src->
          TSqlFragment.IndexOption((IndexOption.MoveToDropIndexOption((src.MoveTo |> Option.ofObj |> Option.map (fun x -> FileGroupOrPartitionScheme.FromCs(x, fragmentMapping))), (src.OptionKind))  ))
        | :? ScriptDom.OrderIndexOption as src->
          TSqlFragment.IndexOption((IndexOption.OrderIndexOption((src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.OptionKind))  ))
        | :? ScriptDom.WaitAtLowPriorityOption as src->
          TSqlFragment.IndexOption((IndexOption.WaitAtLowPriorityOption((src.OptionKind), (src.Options |> Seq.map (fun x -> LowPriorityLockWaitOption.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
      | :? ScriptDom.IndexType as src ->
        TSqlFragment.IndexType((Option.ofNullable (src.IndexTypeKind)))
      | :? ScriptDom.InsertBulkColumnDefinition as src ->
        TSqlFragment.InsertBulkColumnDefinition((src.Column |> Option.ofObj |> Option.map (fun x -> ColumnDefinitionBase.FromCs(x, fragmentMapping))),(src.NullNotNull))
      | :? ScriptDom.InsertSource as src ->
        match src with
        | :? ScriptDom.ExecuteInsertSource as src->
          TSqlFragment.InsertSource((InsertSource.ExecuteInsertSource((src.Execute |> Option.ofObj |> Option.map (fun x -> ExecuteSpecification.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.SelectInsertSource as src->
          TSqlFragment.InsertSource((InsertSource.SelectInsertSource((src.Select |> Option.ofObj |> Option.map (fun x -> QueryExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.ValuesInsertSource as src->
          TSqlFragment.InsertSource((InsertSource.ValuesInsertSource((src.IsDefaultValues), (src.RowValues |> Seq.map (fun src -> RowValue.RowValue((src.ColumnValues |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq))) |> List.ofSeq))  ))
      | :? ScriptDom.KeyOption as src ->
        match src with
        | :? ScriptDom.AlgorithmKeyOption as src->
          TSqlFragment.KeyOption((KeyOption.AlgorithmKeyOption((src.Algorithm), (src.OptionKind))  ))
        | :? ScriptDom.CreationDispositionKeyOption as src->
          TSqlFragment.KeyOption((KeyOption.CreationDispositionKeyOption((src.IsCreateNew), (src.OptionKind))  ))
        | :? ScriptDom.IdentityValueKeyOption as src->
          TSqlFragment.KeyOption((KeyOption.IdentityValueKeyOption((src.IdentityPhrase |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.OptionKind))  ))
        | :? ScriptDom.KeySourceKeyOption as src->
          TSqlFragment.KeyOption((KeyOption.KeySourceKeyOption((src.OptionKind), (src.PassPhrase |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.ProviderKeyNameKeyOption as src->
          TSqlFragment.KeyOption((KeyOption.ProviderKeyNameKeyOption((src.KeyName |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.OptionKind))  ))
      | :? ScriptDom.LiteralRange as src ->
        match src with
        | :? ScriptDom.ProcessAffinityRange as src->
          TSqlFragment.LiteralRange((LiteralRange.ProcessAffinityRange((src.From |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.To |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | _ -> (* :? ScriptDom.LiteralRange as src *)
          TSqlFragment.LiteralRange((LiteralRange.Base((src.From |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.To |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))))
      | :? ScriptDom.LowPriorityLockWaitOption as src ->
        match src with
        | :? ScriptDom.LowPriorityLockWaitAbortAfterWaitOption as src->
          TSqlFragment.LowPriorityLockWaitOption((LowPriorityLockWaitOption.LowPriorityLockWaitAbortAfterWaitOption((src.AbortAfterWait), (src.OptionKind))  ))
        | :? ScriptDom.LowPriorityLockWaitMaxDurationOption as src->
          TSqlFragment.LowPriorityLockWaitOption((LowPriorityLockWaitOption.LowPriorityLockWaitMaxDurationOption((src.MaxDuration |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.OptionKind), (Option.ofNullable (src.Unit)))  ))
      | :? ScriptDom.MergeAction as src ->
        match src with
        | :? ScriptDom.DeleteMergeAction as src->
          TSqlFragment.MergeAction((MergeAction.DeleteMergeAction  ))
        | :? ScriptDom.InsertMergeAction as src->
          TSqlFragment.MergeAction((MergeAction.InsertMergeAction((src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.Source |> Option.ofObj |> Option.map (fun x -> ValuesInsertSource.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.UpdateMergeAction as src->
          TSqlFragment.MergeAction((MergeAction.UpdateMergeAction((src.SetClauses |> Seq.map (fun x -> SetClause.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
      | :? ScriptDom.MergeActionClause as src ->
        TSqlFragment.MergeActionClause((src.Action |> Option.ofObj |> Option.map (fun x -> MergeAction.FromCs(x, fragmentMapping))),(src.Condition),(src.SearchCondition |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.MethodSpecifier as src ->
        TSqlFragment.MethodSpecifier((src.AssemblyName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.ClassName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.MethodName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.MirrorToClause as src ->
        TSqlFragment.MirrorToClause((src.Devices |> Seq.map (fun src -> DeviceInfo.DeviceInfo((src.DeviceType), (src.LogicalDevice |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.PhysicalDevice |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq))
      | :? ScriptDom.MultiPartIdentifier as src ->
        match src with
        | :? ScriptDom.SchemaObjectName as src->
          TSqlFragment.MultiPartIdentifier((MultiPartIdentifier.SchemaObjectName((SchemaObjectName.FromCs(src, fragmentMapping)))  ))
        | _ -> (* :? ScriptDom.MultiPartIdentifier as src *)
          TSqlFragment.MultiPartIdentifier((MultiPartIdentifier.Base((src.Count), (src.Identifiers |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq))))
      | :? ScriptDom.OffsetClause as src ->
        TSqlFragment.OffsetClause((src.FetchExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.OffsetExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.OnlineIndexLowPriorityLockWaitOption as src ->
        TSqlFragment.OnlineIndexLowPriorityLockWaitOption((src.Options |> Seq.map (fun x -> LowPriorityLockWaitOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.OptimizerHint as src ->
        match src with
        | :? ScriptDom.LiteralOptimizerHint as src->
          TSqlFragment.OptimizerHint((OptimizerHint.LiteralOptimizerHint((src.HintKind), (src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.OptimizeForOptimizerHint as src->
          TSqlFragment.OptimizerHint((OptimizerHint.OptimizeForOptimizerHint((src.HintKind), (src.IsForUnknown), (src.Pairs |> Seq.map (fun src -> VariableValuePair.VariableValuePair((src.IsForUnknown), (src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.Variable |> Option.ofObj |> Option.map (fun x -> VariableReference.FromCs(x, fragmentMapping))))) |> List.ofSeq))  ))
        | :? ScriptDom.TableHintsOptimizerHint as src->
          TSqlFragment.OptimizerHint((OptimizerHint.TableHintsOptimizerHint((src.HintKind), (src.ObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.TableHints |> Seq.map (fun x -> TableHint.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.UseHintList as src->
          TSqlFragment.OptimizerHint((OptimizerHint.UseHintList((src.HintKind), (src.Hints |> Seq.map (fun src -> StringLiteral.StringLiteral((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.IsLargeObject), (src.IsNational), (src.LiteralType), (Option.ofObj (src.Value)))) |> List.ofSeq))  ))
        | _ -> (* :? ScriptDom.OptimizerHint as src *)
          TSqlFragment.OptimizerHint((OptimizerHint.Base((src.HintKind))))
      | :? ScriptDom.OptionValue as src ->
        match src with
        | :? ScriptDom.LiteralOptionValue as src->
          TSqlFragment.OptionValue((OptionValue.LiteralOptionValue((src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.OnOffOptionValue as src->
          TSqlFragment.OptionValue((OptionValue.OnOffOptionValue((src.OptionState))  ))
      | :? ScriptDom.OrderByClause as src ->
        TSqlFragment.OrderByClause((src.OrderByElements |> Seq.map (fun src -> ExpressionWithSortOrder.ExpressionWithSortOrder((src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.SortOrder))) |> List.ofSeq))
      | :? ScriptDom.OutputClause as src ->
        TSqlFragment.OutputClause((src.SelectColumns |> Seq.map (fun x -> SelectElement.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.OutputIntoClause as src ->
        TSqlFragment.OutputIntoClause((src.IntoTable |> Option.ofObj |> Option.map (fun x -> TableReference.FromCs(x, fragmentMapping))),(src.IntoTableColumns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.SelectColumns |> Seq.map (fun x -> SelectElement.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.OverClause as src ->
        TSqlFragment.OverClause((src.OrderByClause |> Option.ofObj |> Option.map (fun x -> OrderByClause.FromCs(x, fragmentMapping))),(src.Partitions |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.WindowFrameClause |> Option.ofObj |> Option.map (fun x -> WindowFrameClause.FromCs(x, fragmentMapping))))
      | :? ScriptDom.PartitionParameterType as src ->
        TSqlFragment.PartitionParameterType((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))))
      | :? ScriptDom.PartitionSpecifications as src ->
        match src with
        | :? ScriptDom.TablePartitionOptionSpecifications as src->
          TSqlFragment.PartitionSpecifications((PartitionSpecifications.TablePartitionOptionSpecifications((src.BoundaryValues |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Range))  ))
      | :? ScriptDom.PartitionSpecifier as src ->
        TSqlFragment.PartitionSpecifier((src.All),(src.Number |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.PayloadOption as src ->
        match src with
        | :? ScriptDom.AuthenticationPayloadOption as src->
          TSqlFragment.PayloadOption((PayloadOption.AuthenticationPayloadOption((src.Certificate |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Kind), (src.Protocol), (src.TryCertificateFirst))  ))
        | :? ScriptDom.CharacterSetPayloadOption as src->
          TSqlFragment.PayloadOption((PayloadOption.CharacterSetPayloadOption((src.IsSql), (src.Kind))  ))
        | :? ScriptDom.EnabledDisabledPayloadOption as src->
          TSqlFragment.PayloadOption((PayloadOption.EnabledDisabledPayloadOption((src.IsEnabled), (src.Kind))  ))
        | :? ScriptDom.EncryptionPayloadOption as src->
          TSqlFragment.PayloadOption((PayloadOption.EncryptionPayloadOption((src.AlgorithmPartOne), (src.AlgorithmPartTwo), (src.EncryptionSupport), (src.Kind))  ))
        | :? ScriptDom.LiteralPayloadOption as src->
          TSqlFragment.PayloadOption((PayloadOption.LiteralPayloadOption((src.Kind), (src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.LoginTypePayloadOption as src->
          TSqlFragment.PayloadOption((PayloadOption.LoginTypePayloadOption((src.IsWindows), (src.Kind))  ))
        | :? ScriptDom.RolePayloadOption as src->
          TSqlFragment.PayloadOption((PayloadOption.RolePayloadOption((src.Kind), (src.Role))  ))
        | :? ScriptDom.SchemaPayloadOption as src->
          TSqlFragment.PayloadOption((PayloadOption.SchemaPayloadOption((src.IsStandard), (src.Kind))  ))
        | :? ScriptDom.SessionTimeoutPayloadOption as src->
          TSqlFragment.PayloadOption((PayloadOption.SessionTimeoutPayloadOption((src.IsNever), (src.Kind), (src.Timeout |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.SoapMethod as src->
          TSqlFragment.PayloadOption((PayloadOption.SoapMethod((src.Action), (src.Alias |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.Format), (src.Kind), (src.Name |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.Namespace |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.Schema))  ))
        | :? ScriptDom.WsdlPayloadOption as src->
          TSqlFragment.PayloadOption((PayloadOption.WsdlPayloadOption((src.IsNone), (src.Kind), (src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.Permission as src ->
        TSqlFragment.Permission((src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Identifiers |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.PrincipalOption as src ->
        match src with
        | :? ScriptDom.IdentifierPrincipalOption as src->
          TSqlFragment.PrincipalOption((PrincipalOption.IdentifierPrincipalOption((src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.OptionKind))  ))
        | :? ScriptDom.LiteralPrincipalOption as src->
          TSqlFragment.PrincipalOption((PrincipalOption.LiteralPrincipalOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.OnOffPrincipalOption as src->
          TSqlFragment.PrincipalOption((PrincipalOption.OnOffPrincipalOption((src.OptionKind), (src.OptionState))  ))
        | :? ScriptDom.PasswordAlterPrincipalOption as src->
          TSqlFragment.PrincipalOption((PrincipalOption.PasswordAlterPrincipalOption((src.Hashed), (src.MustChange), (src.OldPassword |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.OptionKind), (src.Password |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.Unlock))  ))
        | _ -> (* :? ScriptDom.PrincipalOption as src *)
          TSqlFragment.PrincipalOption((PrincipalOption.Base((src.OptionKind))))
      | :? ScriptDom.Privilege80 as src ->
        TSqlFragment.Privilege80((src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.PrivilegeType80))
      | :? ScriptDom.ProcedureOption as src ->
        match src with
        | :? ScriptDom.ExecuteAsProcedureOption as src->
          TSqlFragment.ProcedureOption((ProcedureOption.ExecuteAsProcedureOption((src.ExecuteAs |> Option.ofObj |> Option.map (fun x -> ExecuteAsClause.FromCs(x, fragmentMapping))), (src.OptionKind))  ))
        | _ -> (* :? ScriptDom.ProcedureOption as src *)
          TSqlFragment.ProcedureOption((ProcedureOption.Base((src.OptionKind))))
      | :? ScriptDom.ProcedureReference as src ->
        TSqlFragment.ProcedureReference((src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.Number |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ProcedureReferenceName as src ->
        TSqlFragment.ProcedureReferenceName((src.ProcedureReference |> Option.ofObj |> Option.map (fun x -> ProcedureReference.FromCs(x, fragmentMapping))),(src.ProcedureVariable |> Option.ofObj |> Option.map (fun x -> VariableReference.FromCs(x, fragmentMapping))))
      | :? ScriptDom.QueryExpression as src ->
        match src with
        | :? ScriptDom.BinaryQueryExpression as src->
          TSqlFragment.QueryExpression((QueryExpression.BinaryQueryExpression((src.All), (src.BinaryQueryExpressionType), (src.FirstQueryExpression |> Option.ofObj |> Option.map (fun x -> QueryExpression.FromCs(x, fragmentMapping))), (src.ForClause |> Option.ofObj |> Option.map (fun x -> ForClause.FromCs(x, fragmentMapping))), (src.OffsetClause |> Option.ofObj |> Option.map (fun x -> OffsetClause.FromCs(x, fragmentMapping))), (src.OrderByClause |> Option.ofObj |> Option.map (fun x -> OrderByClause.FromCs(x, fragmentMapping))), (src.SecondQueryExpression |> Option.ofObj |> Option.map (fun x -> QueryExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.QueryParenthesisExpression as src->
          TSqlFragment.QueryExpression((QueryExpression.QueryParenthesisExpression((src.ForClause |> Option.ofObj |> Option.map (fun x -> ForClause.FromCs(x, fragmentMapping))), (src.OffsetClause |> Option.ofObj |> Option.map (fun x -> OffsetClause.FromCs(x, fragmentMapping))), (src.OrderByClause |> Option.ofObj |> Option.map (fun x -> OrderByClause.FromCs(x, fragmentMapping))), (src.QueryExpression |> Option.ofObj |> Option.map (fun x -> QueryExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.QuerySpecification as src->
          TSqlFragment.QueryExpression((QueryExpression.QuerySpecification((src.ForClause |> Option.ofObj |> Option.map (fun x -> ForClause.FromCs(x, fragmentMapping))), (src.FromClause |> Option.ofObj |> Option.map (fun x -> FromClause.FromCs(x, fragmentMapping))), (src.GroupByClause |> Option.ofObj |> Option.map (fun x -> GroupByClause.FromCs(x, fragmentMapping))), (src.HavingClause |> Option.ofObj |> Option.map (fun x -> HavingClause.FromCs(x, fragmentMapping))), (src.OffsetClause |> Option.ofObj |> Option.map (fun x -> OffsetClause.FromCs(x, fragmentMapping))), (src.OrderByClause |> Option.ofObj |> Option.map (fun x -> OrderByClause.FromCs(x, fragmentMapping))), (src.SelectElements |> Seq.map (fun x -> SelectElement.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.TopRowFilter |> Option.ofObj |> Option.map (fun x -> TopRowFilter.FromCs(x, fragmentMapping))), (src.UniqueRowFilter), (src.WhereClause |> Option.ofObj |> Option.map (fun x -> WhereClause.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.QueryStoreOption as src ->
        match src with
        | :? ScriptDom.QueryStoreCapturePolicyOption as src->
          TSqlFragment.QueryStoreOption((QueryStoreOption.QueryStoreCapturePolicyOption((src.OptionKind), (src.Value))  ))
        | :? ScriptDom.QueryStoreDataFlushIntervalOption as src->
          TSqlFragment.QueryStoreOption((QueryStoreOption.QueryStoreDataFlushIntervalOption((src.FlushInterval |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.OptionKind))  ))
        | :? ScriptDom.QueryStoreDesiredStateOption as src->
          TSqlFragment.QueryStoreOption((QueryStoreOption.QueryStoreDesiredStateOption((src.OperationModeSpecified), (src.OptionKind), (src.Value))  ))
        | :? ScriptDom.QueryStoreIntervalLengthOption as src->
          TSqlFragment.QueryStoreOption((QueryStoreOption.QueryStoreIntervalLengthOption((src.OptionKind), (src.StatsIntervalLength |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.QueryStoreMaxPlansPerQueryOption as src->
          TSqlFragment.QueryStoreOption((QueryStoreOption.QueryStoreMaxPlansPerQueryOption((src.MaxPlansPerQuery |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.OptionKind))  ))
        | :? ScriptDom.QueryStoreMaxStorageSizeOption as src->
          TSqlFragment.QueryStoreOption((QueryStoreOption.QueryStoreMaxStorageSizeOption((src.MaxQdsSize |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.OptionKind))  ))
        | :? ScriptDom.QueryStoreSizeCleanupPolicyOption as src->
          TSqlFragment.QueryStoreOption((QueryStoreOption.QueryStoreSizeCleanupPolicyOption((src.OptionKind), (src.Value))  ))
        | :? ScriptDom.QueryStoreTimeCleanupPolicyOption as src->
          TSqlFragment.QueryStoreOption((QueryStoreOption.QueryStoreTimeCleanupPolicyOption((src.OptionKind), (src.StaleQueryThreshold |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.QueueOption as src ->
        match src with
        | :? ScriptDom.QueueExecuteAsOption as src->
          TSqlFragment.QueueOption((QueueOption.QueueExecuteAsOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (fun x -> ExecuteAsClause.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.QueueProcedureOption as src->
          TSqlFragment.QueueOption((QueueOption.QueueProcedureOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.QueueStateOption as src->
          TSqlFragment.QueueOption((QueueOption.QueueStateOption((src.OptionKind), (src.OptionState))  ))
        | :? ScriptDom.QueueValueOption as src->
          TSqlFragment.QueueOption((QueueOption.QueueValueOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))  ))
        | _ -> (* :? ScriptDom.QueueOption as src *)
          TSqlFragment.QueueOption((QueueOption.Base((src.OptionKind))))
      | :? ScriptDom.RemoteDataArchiveDatabaseSetting as src ->
        match src with
        | :? ScriptDom.RemoteDataArchiveDbCredentialSetting as src->
          TSqlFragment.RemoteDataArchiveDatabaseSetting((RemoteDataArchiveDatabaseSetting.RemoteDataArchiveDbCredentialSetting((src.Credential |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.SettingKind))  ))
        | :? ScriptDom.RemoteDataArchiveDbFederatedServiceAccountSetting as src->
          TSqlFragment.RemoteDataArchiveDatabaseSetting((RemoteDataArchiveDatabaseSetting.RemoteDataArchiveDbFederatedServiceAccountSetting((src.IsOn), (src.SettingKind))  ))
        | :? ScriptDom.RemoteDataArchiveDbServerSetting as src->
          TSqlFragment.RemoteDataArchiveDatabaseSetting((RemoteDataArchiveDatabaseSetting.RemoteDataArchiveDbServerSetting((src.Server |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))), (src.SettingKind))  ))
      | :? ScriptDom.RemoteServiceBindingOption as src ->
        match src with
        | :? ScriptDom.OnOffRemoteServiceBindingOption as src->
          TSqlFragment.RemoteServiceBindingOption((RemoteServiceBindingOption.OnOffRemoteServiceBindingOption((src.OptionKind), (src.OptionState))  ))
        | :? ScriptDom.UserRemoteServiceBindingOption as src->
          TSqlFragment.RemoteServiceBindingOption((RemoteServiceBindingOption.UserRemoteServiceBindingOption((src.OptionKind), (src.User |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.ResourcePoolAffinitySpecification as src ->
        TSqlFragment.ResourcePoolAffinitySpecification((src.AffinityType),(src.IsAuto),(src.ParameterValue |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.PoolAffinityRanges |> Seq.map (fun x -> LiteralRange.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.ResourcePoolParameter as src ->
        TSqlFragment.ResourcePoolParameter((src.AffinitySpecification |> Option.ofObj |> Option.map (fun x -> ResourcePoolAffinitySpecification.FromCs(x, fragmentMapping))),(src.ParameterType),(src.ParameterValue |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.RestoreOption as src ->
        match src with
        | :? ScriptDom.FileStreamRestoreOption as src->
          TSqlFragment.RestoreOption((RestoreOption.FileStreamRestoreOption((src.FileStreamOption |> Option.ofObj |> Option.map (fun x -> FileStreamDatabaseOption.FromCs(x, fragmentMapping))), (src.OptionKind))  ))
        | :? ScriptDom.MoveRestoreOption as src->
          TSqlFragment.RestoreOption((RestoreOption.MoveRestoreOption((src.LogicalFileName |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))), (src.OSFileName |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))), (src.OptionKind))  ))
        | :? ScriptDom.ScalarExpressionRestoreOption as src->
          TSqlFragment.RestoreOption((RestoreOption.ScalarExpressionRestoreOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.StopRestoreOption as src->
          TSqlFragment.RestoreOption((RestoreOption.StopRestoreOption((src.After |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))), (src.IsStopAt), (src.Mark |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))), (src.OptionKind))  ))
        | _ -> (* :? ScriptDom.RestoreOption as src *)
          TSqlFragment.RestoreOption((RestoreOption.Base((src.OptionKind))))
      | :? ScriptDom.ResultColumnDefinition as src ->
        TSqlFragment.ResultColumnDefinition((src.ColumnDefinition |> Option.ofObj |> Option.map (fun x -> ColumnDefinitionBase.FromCs(x, fragmentMapping))),(src.Nullable |> Option.ofObj |> Option.map (fun x -> NullableConstraintDefinition.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ResultSetDefinition as src ->
        match src with
        | :? ScriptDom.InlineResultSetDefinition as src->
          TSqlFragment.ResultSetDefinition((ResultSetDefinition.InlineResultSetDefinition((src.ResultColumnDefinitions |> Seq.map (fun src -> ResultColumnDefinition.ResultColumnDefinition((src.ColumnDefinition |> Option.ofObj |> Option.map (fun x -> ColumnDefinitionBase.FromCs(x, fragmentMapping))), (src.Nullable |> Option.ofObj |> Option.map (fun x -> NullableConstraintDefinition.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.ResultSetType))  ))
        | :? ScriptDom.SchemaObjectResultSetDefinition as src->
          TSqlFragment.ResultSetDefinition((ResultSetDefinition.SchemaObjectResultSetDefinition((src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.ResultSetType))  ))
        | _ -> (* :? ScriptDom.ResultSetDefinition as src *)
          TSqlFragment.ResultSetDefinition((ResultSetDefinition.Base((src.ResultSetType))))
      | :? ScriptDom.RetentionPeriodDefinition as src ->
        TSqlFragment.RetentionPeriodDefinition((src.Duration |> Option.ofObj |> Option.map (fun x -> IntegerLiteral.FromCs(x, fragmentMapping))),(src.IsInfinity),(src.Units))
      | :? ScriptDom.RouteOption as src ->
        TSqlFragment.RouteOption((src.Literal |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.OptionKind))
      | :? ScriptDom.RowValue as src ->
        TSqlFragment.RowValue((src.ColumnValues |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.ScalarExpression as src ->
        match src with
        | :? ScriptDom.BinaryExpression as src->
          TSqlFragment.ScalarExpression((ScalarExpression.BinaryExpression((src.BinaryExpressionType), (src.FirstExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.SecondExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.ExtractFromExpression as src->
          TSqlFragment.ScalarExpression((ScalarExpression.ExtractFromExpression((src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.ExtractedElement |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.IdentityFunctionCall as src->
          TSqlFragment.ScalarExpression((ScalarExpression.IdentityFunctionCall((src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.Increment |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.Seed |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.OdbcConvertSpecification as src->
          TSqlFragment.ScalarExpression((ScalarExpression.OdbcConvertSpecification((src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.PrimaryExpression as src->
          TSqlFragment.ScalarExpression((ScalarExpression.PrimaryExpression((PrimaryExpression.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.ScalarExpressionSnippet as src->
          TSqlFragment.ScalarExpression((ScalarExpression.ScalarExpressionSnippet((Option.ofObj (src.Script)))  ))
        | :? ScriptDom.SourceDeclaration as src->
          TSqlFragment.ScalarExpression((ScalarExpression.SourceDeclaration((src.Value |> Option.ofObj |> Option.map (fun x -> EventSessionObjectName.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.UnaryExpression as src->
          TSqlFragment.ScalarExpression((ScalarExpression.UnaryExpression((src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.UnaryExpressionType))  ))
      | :? ScriptDom.SchemaDeclarationItem as src ->
        match src with
        | :? ScriptDom.SchemaDeclarationItemOpenjson as src->
          TSqlFragment.SchemaDeclarationItem((SchemaDeclarationItem.SchemaDeclarationItemOpenjson((src.AsJson), (src.ColumnDefinition |> Option.ofObj |> Option.map (fun x -> ColumnDefinitionBase.FromCs(x, fragmentMapping))), (src.Mapping |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))  ))
        | _ -> (* :? ScriptDom.SchemaDeclarationItem as src *)
          TSqlFragment.SchemaDeclarationItem((SchemaDeclarationItem.Base((src.ColumnDefinition |> Option.ofObj |> Option.map (fun x -> ColumnDefinitionBase.FromCs(x, fragmentMapping))), (src.Mapping |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))))
      | :? ScriptDom.SchemaObjectNameOrValueExpression as src ->
        TSqlFragment.SchemaObjectNameOrValueExpression((src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.ValueExpression |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.SearchPropertyListAction as src ->
        match src with
        | :? ScriptDom.AddSearchPropertyListAction as src->
          TSqlFragment.SearchPropertyListAction((SearchPropertyListAction.AddSearchPropertyListAction((src.Description |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))), (src.Guid |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))), (src.Id |> Option.ofObj |> Option.map (fun x -> IntegerLiteral.FromCs(x, fragmentMapping))), (src.PropertyName |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropSearchPropertyListAction as src->
          TSqlFragment.SearchPropertyListAction((SearchPropertyListAction.DropSearchPropertyListAction((src.PropertyName |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.SecurityElement80 as src ->
        match src with
        | :? ScriptDom.CommandSecurityElement80 as src->
          TSqlFragment.SecurityElement80((SecurityElement80.CommandSecurityElement80((src.All), (src.CommandOptions))  ))
        | :? ScriptDom.PrivilegeSecurityElement80 as src->
          TSqlFragment.SecurityElement80((SecurityElement80.PrivilegeSecurityElement80((src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Privileges |> Seq.map (fun src -> Privilege80.Privilege80((src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.PrivilegeType80))) |> List.ofSeq), (src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.SecurityPolicyOption as src ->
        TSqlFragment.SecurityPolicyOption((src.OptionKind),(src.OptionState))
      | :? ScriptDom.SecurityPredicateAction as src ->
        TSqlFragment.SecurityPredicateAction((src.ActionType),(src.FunctionCall |> Option.ofObj |> Option.map (fun x -> FunctionCall.FromCs(x, fragmentMapping))),(src.SecurityPredicateOperation),(src.SecurityPredicateType),(src.TargetObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.SecurityPrincipal as src ->
        TSqlFragment.SecurityPrincipal((src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.PrincipalType))
      | :? ScriptDom.SecurityTargetObject as src ->
        TSqlFragment.SecurityTargetObject((src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.ObjectKind),(src.ObjectName |> Option.ofObj |> Option.map (fun x -> SecurityTargetObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.SecurityTargetObjectName as src ->
        TSqlFragment.SecurityTargetObjectName((src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.SecurityUserClause80 as src ->
        TSqlFragment.SecurityUserClause80((src.UserType80),(src.Users |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.SelectElement as src ->
        match src with
        | :? ScriptDom.SelectScalarExpression as src->
          TSqlFragment.SelectElement((SelectElement.SelectScalarExpression((src.ColumnName |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.SelectSetVariable as src->
          TSqlFragment.SelectElement((SelectElement.SelectSetVariable((src.AssignmentKind), (src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.Variable |> Option.ofObj |> Option.map (fun x -> VariableReference.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.SelectStarExpression as src->
          TSqlFragment.SelectElement((SelectElement.SelectStarExpression((src.Qualifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.SelectiveXmlIndexPromotedPath as src ->
        TSqlFragment.SelectiveXmlIndexPromotedPath((src.IsSingleton),(src.MaxLength |> Option.ofObj |> Option.map (fun x -> IntegerLiteral.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Path |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.SQLDataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))),(src.XQueryDataType |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.SensitivityClassificationOption as src ->
        TSqlFragment.SensitivityClassificationOption((src.Type),(src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.SequenceOption as src ->
        match src with
        | :? ScriptDom.DataTypeSequenceOption as src->
          TSqlFragment.SequenceOption((SequenceOption.DataTypeSequenceOption((src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.NoValue), (src.OptionKind))  ))
        | :? ScriptDom.ScalarExpressionSequenceOption as src->
          TSqlFragment.SequenceOption((SequenceOption.ScalarExpressionSequenceOption((src.NoValue), (src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  ))
        | _ -> (* :? ScriptDom.SequenceOption as src *)
          TSqlFragment.SequenceOption((SequenceOption.Base((src.NoValue), (src.OptionKind))))
      | :? ScriptDom.ServiceContract as src ->
        TSqlFragment.ServiceContract((src.Action),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.SessionOption as src ->
        match src with
        | :? ScriptDom.EventRetentionSessionOption as src->
          TSqlFragment.SessionOption((SessionOption.EventRetentionSessionOption((src.OptionKind), (src.Value))  ))
        | :? ScriptDom.LiteralSessionOption as src->
          TSqlFragment.SessionOption((SessionOption.LiteralSessionOption((src.OptionKind), (src.Unit), (src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.MaxDispatchLatencySessionOption as src->
          TSqlFragment.SessionOption((SessionOption.MaxDispatchLatencySessionOption((src.IsInfinite), (src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.MemoryPartitionSessionOption as src->
          TSqlFragment.SessionOption((SessionOption.MemoryPartitionSessionOption((src.OptionKind), (src.Value))  ))
        | :? ScriptDom.OnOffSessionOption as src->
          TSqlFragment.SessionOption((SessionOption.OnOffSessionOption((src.OptionKind), (src.OptionState))  ))
      | :? ScriptDom.SetClause as src ->
        match src with
        | :? ScriptDom.AssignmentSetClause as src->
          TSqlFragment.SetClause((SetClause.AssignmentSetClause((src.AssignmentKind), (src.Column |> Option.ofObj |> Option.map (fun x -> ColumnReferenceExpression.FromCs(x, fragmentMapping))), (src.NewValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.Variable |> Option.ofObj |> Option.map (fun x -> VariableReference.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.FunctionCallSetClause as src->
          TSqlFragment.SetClause((SetClause.FunctionCallSetClause((src.MutatorFunction |> Option.ofObj |> Option.map (fun x -> FunctionCall.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.SetCommand as src ->
        match src with
        | :? ScriptDom.GeneralSetCommand as src->
          TSqlFragment.SetCommand((SetCommand.GeneralSetCommand((src.CommandType), (src.Parameter |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.SetFipsFlaggerCommand as src->
          TSqlFragment.SetCommand((SetCommand.SetFipsFlaggerCommand((src.ComplianceLevel))  ))
      | :? ScriptDom.SpatialIndexOption as src ->
        match src with
        | :? ScriptDom.BoundingBoxSpatialIndexOption as src->
          TSqlFragment.SpatialIndexOption((SpatialIndexOption.BoundingBoxSpatialIndexOption((src.BoundingBoxParameters |> Seq.map (fun src -> BoundingBoxParameter.BoundingBoxParameter((src.Parameter), (src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq))  ))
        | :? ScriptDom.CellsPerObjectSpatialIndexOption as src->
          TSqlFragment.SpatialIndexOption((SpatialIndexOption.CellsPerObjectSpatialIndexOption((src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.GridsSpatialIndexOption as src->
          TSqlFragment.SpatialIndexOption((SpatialIndexOption.GridsSpatialIndexOption((src.GridParameters |> Seq.map (fun src -> GridParameter.GridParameter((src.Parameter), (src.Value))) |> List.ofSeq))  ))
        | :? ScriptDom.SpatialIndexRegularOption as src->
          TSqlFragment.SpatialIndexOption((SpatialIndexOption.SpatialIndexRegularOption((src.Option |> Option.ofObj |> Option.map (fun x -> IndexOption.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.StatementList as src ->
        match src with
        | :? ScriptDom.StatementListSnippet as src->
          TSqlFragment.StatementList((StatementList.StatementListSnippet((Option.ofObj (src.Script)), (src.Statements |> Seq.map (fun x -> TSqlStatement.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | _ -> (* :? ScriptDom.StatementList as src *)
          TSqlFragment.StatementList((StatementList.Base((src.Statements |> Seq.map (fun x -> TSqlStatement.FromCs(x, fragmentMapping)) |> List.ofSeq))))
      | :? ScriptDom.StatisticsOption as src ->
        match src with
        | :? ScriptDom.LiteralStatisticsOption as src->
          TSqlFragment.StatisticsOption((StatisticsOption.LiteralStatisticsOption((src.Literal |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.OptionKind))  ))
        | :? ScriptDom.OnOffStatisticsOption as src->
          TSqlFragment.StatisticsOption((StatisticsOption.OnOffStatisticsOption((src.OptionKind), (src.OptionState))  ))
        | :? ScriptDom.ResampleStatisticsOption as src->
          TSqlFragment.StatisticsOption((StatisticsOption.ResampleStatisticsOption((src.OptionKind), (src.Partitions |> Seq.map (fun src -> StatisticsPartitionRange.StatisticsPartitionRange((src.From |> Option.ofObj |> Option.map (fun x -> IntegerLiteral.FromCs(x, fragmentMapping))), (src.To |> Option.ofObj |> Option.map (fun x -> IntegerLiteral.FromCs(x, fragmentMapping))))) |> List.ofSeq))  ))
        | _ -> (* :? ScriptDom.StatisticsOption as src *)
          TSqlFragment.StatisticsOption((StatisticsOption.Base((src.OptionKind))))
      | :? ScriptDom.StatisticsPartitionRange as src ->
        TSqlFragment.StatisticsPartitionRange((src.From |> Option.ofObj |> Option.map (fun x -> IntegerLiteral.FromCs(x, fragmentMapping))),(src.To |> Option.ofObj |> Option.map (fun x -> IntegerLiteral.FromCs(x, fragmentMapping))))
      | :? ScriptDom.SystemTimePeriodDefinition as src ->
        TSqlFragment.SystemTimePeriodDefinition((src.EndTimeColumn |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.StartTimeColumn |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.TSqlBatch as src ->
        TSqlFragment.TSqlBatch((src.Statements |> Seq.map (fun x -> TSqlStatement.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.TSqlFragmentSnippet as src ->
        TSqlFragment.TSqlFragmentSnippet((Option.ofObj (src.Script)))
      | :? ScriptDom.TSqlScript as src ->
        TSqlFragment.TSqlScript((src.Batches |> Seq.map (fun src -> TSqlBatch.TSqlBatch((src.Statements |> Seq.map (fun x -> TSqlStatement.FromCs(x, fragmentMapping)) |> List.ofSeq))) |> List.ofSeq))
      | :? ScriptDom.TSqlStatement as src ->
        match src with
        | :? ScriptDom.AlterAsymmetricKeyStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.AlterAsymmetricKeyStatement((src.AttestedBy |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.DecryptionPassword |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.EncryptionPassword |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.Kind), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.AlterAuthorizationStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.AlterAuthorizationStatement((src.PrincipalName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.SecurityTargetObject |> Option.ofObj |> Option.map (fun x -> SecurityTargetObject.FromCs(x, fragmentMapping))), (src.ToSchemaOwner))  ))
        | :? ScriptDom.AlterCreateEndpointStatementBase as src->
          TSqlFragment.TSqlStatement((TSqlStatement.AlterCreateEndpointStatementBase((AlterCreateEndpointStatementBase.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.AlterCreateServiceStatementBase as src->
          TSqlFragment.TSqlStatement((TSqlStatement.AlterCreateServiceStatementBase((AlterCreateServiceStatementBase.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.AlterCryptographicProviderStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.AlterCryptographicProviderStatement((src.File |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Option))  ))
        | :? ScriptDom.AlterDatabaseScopedConfigurationStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.AlterDatabaseScopedConfigurationStatement((AlterDatabaseScopedConfigurationStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.AlterDatabaseStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.AlterDatabaseStatement((AlterDatabaseStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.AlterFederationStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.AlterFederationStatement((src.Boundary |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.DistributionName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Kind), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.AlterFullTextIndexStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.AlterFullTextIndexStatement((src.Action |> Option.ofObj |> Option.map (fun x -> AlterFullTextIndexAction.FromCs(x, fragmentMapping))), (src.OnName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.AlterFullTextStopListStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.AlterFullTextStopListStatement((src.Action |> Option.ofObj |> Option.map (fun x -> FullTextStopListAction.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.AlterLoginStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.AlterLoginStatement((AlterLoginStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.AlterPartitionFunctionStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.AlterPartitionFunctionStatement((src.Boundary |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.IsSplit), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.AlterPartitionSchemeStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.AlterPartitionSchemeStatement((src.FileGroup |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.AlterResourceGovernorStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.AlterResourceGovernorStatement((src.ClassifierFunction |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.Command))  ))
        | :? ScriptDom.AlterSchemaStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.AlterSchemaStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ObjectKind), (src.ObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.AlterSearchPropertyListStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.AlterSearchPropertyListStatement((src.Action |> Option.ofObj |> Option.map (fun x -> SearchPropertyListAction.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.AlterServerConfigurationSetBufferPoolExtensionStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.AlterServerConfigurationSetBufferPoolExtensionStatement((src.Options |> Seq.map (fun x -> AlterServerConfigurationBufferPoolExtensionOption.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.AlterServerConfigurationSetDiagnosticsLogStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.AlterServerConfigurationSetDiagnosticsLogStatement((src.Options |> Seq.map (fun x -> AlterServerConfigurationDiagnosticsLogOption.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.AlterServerConfigurationSetExternalAuthenticationStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.AlterServerConfigurationSetExternalAuthenticationStatement((src.Options |> Seq.map (fun x -> AlterServerConfigurationExternalAuthenticationOption.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.AlterServerConfigurationSetFailoverClusterPropertyStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.AlterServerConfigurationSetFailoverClusterPropertyStatement((src.Options |> Seq.map (fun src -> AlterServerConfigurationFailoverClusterPropertyOption.AlterServerConfigurationFailoverClusterPropertyOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (fun x -> OptionValue.FromCs(x, fragmentMapping))))) |> List.ofSeq))  ))
        | :? ScriptDom.AlterServerConfigurationSetHadrClusterStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.AlterServerConfigurationSetHadrClusterStatement((src.Options |> Seq.map (fun src -> AlterServerConfigurationHadrClusterOption.AlterServerConfigurationHadrClusterOption((src.IsLocal), (src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (fun x -> OptionValue.FromCs(x, fragmentMapping))))) |> List.ofSeq))  ))
        | :? ScriptDom.AlterServerConfigurationSetSoftNumaStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.AlterServerConfigurationSetSoftNumaStatement((src.Options |> Seq.map (fun src -> AlterServerConfigurationSoftNumaOption.AlterServerConfigurationSoftNumaOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (fun x -> OptionValue.FromCs(x, fragmentMapping))))) |> List.ofSeq))  ))
        | :? ScriptDom.AlterServerConfigurationStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.AlterServerConfigurationStatement((src.ProcessAffinity), (src.ProcessAffinityRanges |> Seq.map (fun src -> ProcessAffinityRange.ProcessAffinityRange((src.From |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.To |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq))  ))
        | :? ScriptDom.AlterServiceMasterKeyStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.AlterServiceMasterKeyStatement((src.Account |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.Kind), (src.Password |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.AlterTableStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.AlterTableStatement((AlterTableStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.AlterXmlSchemaCollectionStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.AlterXmlSchemaCollectionStatement((src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.ApplicationRoleStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.ApplicationRoleStatement((ApplicationRoleStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.AssemblyStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.AssemblyStatement((AssemblyStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.AuditSpecificationStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.AuditSpecificationStatement((AuditSpecificationStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.AvailabilityGroupStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.AvailabilityGroupStatement((AvailabilityGroupStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.BackupRestoreMasterKeyStatementBase as src->
          TSqlFragment.TSqlStatement((TSqlStatement.BackupRestoreMasterKeyStatementBase((BackupRestoreMasterKeyStatementBase.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.BackupStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.BackupStatement((BackupStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.BeginConversationTimerStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.BeginConversationTimerStatement((src.Handle |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.Timeout |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.BeginDialogStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.BeginDialogStatement((src.ContractName |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.Handle |> Option.ofObj |> Option.map (fun x -> VariableReference.FromCs(x, fragmentMapping))), (src.InitiatorServiceName |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.InstanceSpec |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))), (src.IsConversation), (src.Options |> Seq.map (fun x -> DialogOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.TargetServiceName |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.BeginEndBlockStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.BeginEndBlockStatement((BeginEndBlockStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.BreakStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.BreakStatement  ))
        | :? ScriptDom.BrokerPriorityStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.BrokerPriorityStatement((BrokerPriorityStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.BulkInsertBase as src->
          TSqlFragment.TSqlStatement((TSqlStatement.BulkInsertBase((BulkInsertBase.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.CertificateStatementBase as src->
          TSqlFragment.TSqlStatement((TSqlStatement.CertificateStatementBase((CertificateStatementBase.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.CheckpointStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.CheckpointStatement((src.Duration |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CloseMasterKeyStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.CloseMasterKeyStatement  ))
        | :? ScriptDom.CloseSymmetricKeyStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.CloseSymmetricKeyStatement((src.All), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.ColumnEncryptionKeyStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.ColumnEncryptionKeyStatement((ColumnEncryptionKeyStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.ContinueStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.ContinueStatement  ))
        | :? ScriptDom.CopyStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.CopyStatement((src.From |> Seq.map (fun src -> StringLiteral.StringLiteral((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.IsLargeObject), (src.IsNational), (src.LiteralType), (Option.ofObj (src.Value)))) |> List.ofSeq), (src.Into |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.OptimizerHints |> Seq.map (fun x -> OptimizerHint.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Options |> Seq.map (fun src -> CopyOption.CopyOption((src.Kind), (src.Value |> Option.ofObj |> Option.map (fun x -> CopyStatementOptionBase.FromCs(x, fragmentMapping))))) |> List.ofSeq))  ))
        | :? ScriptDom.CreateAggregateStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.CreateAggregateStatement((src.AssemblyName |> Option.ofObj |> Option.map (fun x -> AssemblyName.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.Parameters |> Seq.map (fun src -> ProcedureParameter.ProcedureParameter((src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.IsVarying), (src.Modifier), (src.Nullable |> Option.ofObj |> Option.map (fun x -> NullableConstraintDefinition.FromCs(x, fragmentMapping))), (src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.VariableName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.ReturnType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CreateAsymmetricKeyStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.CreateAsymmetricKeyStatement((src.EncryptionAlgorithm), (src.KeySource |> Option.ofObj |> Option.map (fun x -> EncryptionSource.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Owner |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Password |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CreateColumnMasterKeyStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.CreateColumnMasterKeyStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Parameters |> Seq.map (fun x -> ColumnMasterKeyParameter.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.CreateColumnStoreIndexStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.CreateColumnStoreIndexStatement((Option.ofNullable (src.Clustered)), (src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.FilterPredicate |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))), (src.IndexOptions |> Seq.map (fun x -> IndexOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.OnFileGroupOrPartitionScheme |> Option.ofObj |> Option.map (fun x -> FileGroupOrPartitionScheme.FromCs(x, fragmentMapping))), (src.OnName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.OrderedColumns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq))  ))
        | :? ScriptDom.CreateContractStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.CreateContractStatement((src.Messages |> Seq.map (fun src -> ContractMessage.ContractMessage((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.SentBy))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Owner |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CreateCryptographicProviderStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.CreateCryptographicProviderStatement((src.File |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CreateDatabaseStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.CreateDatabaseStatement((src.AttachMode), (src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Containment |> Option.ofObj |> Option.map (fun x -> ContainmentDatabaseOption.FromCs(x, fragmentMapping))), (src.CopyOf |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))), (src.DatabaseName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.DatabaseSnapshot |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.FileGroups |> Seq.map (fun src -> FileGroupDefinition.FileGroupDefinition((src.ContainsFileStream), (src.ContainsMemoryOptimizedData), (src.FileDeclarations |> Seq.map (fun src -> FileDeclaration.FileDeclaration((src.IsPrimary), (src.Options |> Seq.map (fun x -> FileDeclarationOption.FromCs(x, fragmentMapping)) |> List.ofSeq))) |> List.ofSeq), (src.IsDefault), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.LogOn |> Seq.map (fun src -> FileDeclaration.FileDeclaration((src.IsPrimary), (src.Options |> Seq.map (fun x -> FileDeclarationOption.FromCs(x, fragmentMapping)) |> List.ofSeq))) |> List.ofSeq), (src.Options |> Seq.map (fun x -> DatabaseOption.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.CreateDefaultStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.CreateDefaultStatement((src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CreateEventNotificationStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.CreateEventNotificationStatement((src.BrokerInstanceSpecifier |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.BrokerService |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.EventTypeGroups |> Seq.map (fun x -> EventTypeGroupContainer.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Scope |> Option.ofObj |> Option.map (fun x -> EventNotificationObjectScope.FromCs(x, fragmentMapping))), (src.WithFanIn))  ))
        | :? ScriptDom.CreateFederationStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.CreateFederationStatement((src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.DistributionName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CreateFullTextIndexStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.CreateFullTextIndexStatement((src.CatalogAndFileGroup |> Option.ofObj |> Option.map (fun x -> FullTextCatalogAndFileGroup.FromCs(x, fragmentMapping))), (src.FullTextIndexColumns |> Seq.map (fun src -> FullTextIndexColumn.FullTextIndexColumn((src.LanguageTerm |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.StatisticalSemantics), (src.TypeColumn |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.KeyIndexName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.OnName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.Options |> Seq.map (fun x -> FullTextIndexOption.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.CreateFullTextStopListStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.CreateFullTextStopListStatement((src.DatabaseName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.IsSystemStopList), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Owner |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.SourceStopListName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CreateLoginStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.CreateLoginStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Source |> Option.ofObj |> Option.map (fun x -> CreateLoginSource.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CreatePartitionFunctionStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.CreatePartitionFunctionStatement((src.BoundaryValues |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ParameterType |> Option.ofObj |> Option.map (fun x -> PartitionParameterType.FromCs(x, fragmentMapping))), (src.Range))  ))
        | :? ScriptDom.CreatePartitionSchemeStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.CreatePartitionSchemeStatement((src.FileGroups |> Seq.map (fun src -> IdentifierOrValueExpression.IdentifierOrValueExpression((src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (Option.ofObj (src.Value)), (src.ValueExpression |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.IsAll), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.PartitionFunction |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CreateRuleStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.CreateRuleStatement((src.Expression |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CreateSchemaStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.CreateSchemaStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Owner |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.StatementList |> Option.ofObj |> Option.map (fun x -> StatementList.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CreateSearchPropertyListStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.CreateSearchPropertyListStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Owner |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.SourceSearchPropertyList |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CreateSpatialIndexStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.CreateSpatialIndexStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Object |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.OnFileGroup |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.SpatialColumnName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.SpatialIndexOptions |> Seq.map (fun x -> SpatialIndexOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.SpatialIndexingScheme))  ))
        | :? ScriptDom.CreateStatisticsStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.CreateStatisticsStatement((src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.FilterPredicate |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.OnName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.StatisticsOptions |> Seq.map (fun x -> StatisticsOption.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.CreateSynonymStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.CreateSynonymStatement((src.ForName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CreateTableStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.CreateTableStatement((src.AsEdge), (src.AsFileTable), (src.AsNode), (src.CtasColumns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Definition |> Option.ofObj |> Option.map (fun x -> TableDefinition.FromCs(x, fragmentMapping))), (src.FederationScheme |> Option.ofObj |> Option.map (fun x -> FederationScheme.FromCs(x, fragmentMapping))), (src.FileStreamOn |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.OnFileGroupOrPartitionScheme |> Option.ofObj |> Option.map (fun x -> FileGroupOrPartitionScheme.FromCs(x, fragmentMapping))), (src.Options |> Seq.map (fun x -> TableOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.SelectStatement |> Option.ofObj |> Option.map (fun x -> SelectStatement.FromCs(x, fragmentMapping))), (src.TextImageOn |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CreateTypeStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.CreateTypeStatement((CreateTypeStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.CreateXmlSchemaCollectionStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.CreateXmlSchemaCollectionStatement((src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CredentialStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.CredentialStatement((CredentialStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.CursorStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.CursorStatement((CursorStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.DatabaseEncryptionKeyStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.DatabaseEncryptionKeyStatement((DatabaseEncryptionKeyStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.DbccStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.DbccStatement((src.Command), (Option.ofObj (src.DllName)), (src.Literals |> Seq.map (fun src -> DbccNamedLiteral.DbccNamedLiteral((Option.ofObj (src.Name)), (src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.Options |> Seq.map (fun src -> DbccOption.DbccOption((src.OptionKind))) |> List.ofSeq), (src.OptionsUseJoin), (src.ParenthesisRequired))  ))
        | :? ScriptDom.DeclareCursorStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.DeclareCursorStatement((src.CursorDefinition |> Option.ofObj |> Option.map (fun x -> CursorDefinition.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DeclareTableVariableStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.DeclareTableVariableStatement((src.Body |> Option.ofObj |> Option.map (fun x -> DeclareTableVariableBody.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DeclareVariableStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.DeclareVariableStatement((src.Declarations |> Seq.map (fun x -> DeclareVariableElement.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.DiskStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.DiskStatement((src.DiskStatementType), (src.Options |> Seq.map (fun src -> DiskStatementOption.DiskStatementOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq))  ))
        | :? ScriptDom.DropChildObjectsStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.DropChildObjectsStatement((DropChildObjectsStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.DropDatabaseEncryptionKeyStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.DropDatabaseEncryptionKeyStatement  ))
        | :? ScriptDom.DropDatabaseStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.DropDatabaseStatement((src.Databases |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.IsIfExists))  ))
        | :? ScriptDom.DropEventNotificationStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.DropEventNotificationStatement((src.Notifications |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Scope |> Option.ofObj |> Option.map (fun x -> EventNotificationObjectScope.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropFullTextIndexStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.DropFullTextIndexStatement((src.TableName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropIndexStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.DropIndexStatement((src.DropIndexClauses |> Seq.map (fun x -> DropIndexClauseBase.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.IsIfExists))  ))
        | :? ScriptDom.DropMasterKeyStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.DropMasterKeyStatement  ))
        | :? ScriptDom.DropObjectsStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.DropObjectsStatement((DropObjectsStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.DropQueueStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.DropQueueStatement((src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropSchemaStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.DropSchemaStatement((src.DropBehavior), (src.IsIfExists), (src.Schema |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropTypeStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.DropTypeStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropUnownedObjectStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.DropXmlSchemaCollectionStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.DropXmlSchemaCollectionStatement((src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.EnableDisableTriggerStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.EnableDisableTriggerStatement((src.All), (src.TriggerEnforcement), (src.TriggerNames |> Seq.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.TriggerObject |> Option.ofObj |> Option.map (fun x -> TriggerObject.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.EndConversationStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.EndConversationStatement((src.Conversation |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.ErrorCode |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))), (src.ErrorDescription |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))), (src.WithCleanup))  ))
        | :? ScriptDom.EventSessionStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.EventSessionStatement((EventSessionStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.ExecuteAsStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.ExecuteAsStatement((src.Cookie |> Option.ofObj |> Option.map (fun x -> VariableReference.FromCs(x, fragmentMapping))), (src.ExecuteContext |> Option.ofObj |> Option.map (fun x -> ExecuteContext.FromCs(x, fragmentMapping))), (src.WithNoRevert))  ))
        | :? ScriptDom.ExecuteStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.ExecuteStatement((src.ExecuteSpecification |> Option.ofObj |> Option.map (fun x -> ExecuteSpecification.FromCs(x, fragmentMapping))), (src.Options |> Seq.map (fun x -> ExecuteOption.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.ExternalDataSourceStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.ExternalDataSourceStatement((ExternalDataSourceStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.ExternalFileFormatStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.ExternalFileFormatStatement((ExternalFileFormatStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.ExternalResourcePoolStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.ExternalResourcePoolStatement((ExternalResourcePoolStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.ExternalTableStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.ExternalTableStatement((ExternalTableStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.FullTextCatalogStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.FullTextCatalogStatement((FullTextCatalogStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.GoToStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.GoToStatement((src.LabelName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.IfStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.IfStatement((src.ElseStatement |> Option.ofObj |> Option.map (fun x -> TSqlStatement.FromCs(x, fragmentMapping))), (src.Predicate |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))), (src.ThenStatement |> Option.ofObj |> Option.map (fun x -> TSqlStatement.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.IndexDefinition as src->
          TSqlFragment.TSqlStatement((TSqlStatement.IndexDefinition((src.Columns |> Seq.map (fun src -> ColumnWithSortOrder.ColumnWithSortOrder((src.Column |> Option.ofObj |> Option.map (fun x -> ColumnReferenceExpression.FromCs(x, fragmentMapping))), (src.SortOrder))) |> List.ofSeq), (src.FileStreamOn |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.FilterPredicate |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))), (src.IndexOptions |> Seq.map (fun x -> IndexOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.IndexType |> Option.ofObj |> Option.map (fun x -> IndexType.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.OnFileGroupOrPartitionScheme |> Option.ofObj |> Option.map (fun x -> FileGroupOrPartitionScheme.FromCs(x, fragmentMapping))), (src.Unique))  ))
        | :? ScriptDom.IndexStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.IndexStatement((IndexStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.KillQueryNotificationSubscriptionStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.KillQueryNotificationSubscriptionStatement((src.All), (src.SubscriptionId |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.KillStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.KillStatement((src.Parameter |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.WithStatusOnly))  ))
        | :? ScriptDom.KillStatsJobStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.KillStatsJobStatement((src.JobId |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.LabelStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.LabelStatement((Option.ofObj (src.Value)))  ))
        | :? ScriptDom.LineNoStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.LineNoStatement((src.LineNo |> Option.ofObj |> Option.map (fun x -> IntegerLiteral.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.MasterKeyStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.MasterKeyStatement((MasterKeyStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.MessageTypeStatementBase as src->
          TSqlFragment.TSqlStatement((TSqlStatement.MessageTypeStatementBase((MessageTypeStatementBase.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.MoveConversationStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.MoveConversationStatement((src.Conversation |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.Group |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.OpenMasterKeyStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.OpenMasterKeyStatement((src.Password |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.OpenSymmetricKeyStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.OpenSymmetricKeyStatement((src.DecryptionMechanism |> Option.ofObj |> Option.map (fun x -> CryptoMechanism.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.PrintStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.PrintStatement((src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.ProcedureStatementBodyBase as src->
          TSqlFragment.TSqlStatement((TSqlStatement.ProcedureStatementBodyBase((ProcedureStatementBodyBase.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.QueueStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.QueueStatement((QueueStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.RaiseErrorLegacyStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.RaiseErrorLegacyStatement((src.FirstParameter |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.SecondParameter |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.RaiseErrorStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.RaiseErrorStatement((src.FirstParameter |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.OptionalParameters |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.RaiseErrorOptions), (src.SecondParameter |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.ThirdParameter |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.ReadTextStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.ReadTextStatement((src.Column |> Option.ofObj |> Option.map (fun x -> ColumnReferenceExpression.FromCs(x, fragmentMapping))), (src.HoldLock), (src.Offset |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))), (src.Size |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))), (src.TextPointer |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.ReconfigureStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.ReconfigureStatement((src.WithOverride))  ))
        | :? ScriptDom.RemoteServiceBindingStatementBase as src->
          TSqlFragment.TSqlStatement((TSqlStatement.RemoteServiceBindingStatementBase((RemoteServiceBindingStatementBase.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.RenameEntityStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.RenameEntityStatement((src.NewName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.OldName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.RenameEntityType), (Option.ofNullable (src.SeparatorType)))  ))
        | :? ScriptDom.ResourcePoolStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.ResourcePoolStatement((ResourcePoolStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.RestoreStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.RestoreStatement((src.DatabaseName |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.Devices |> Seq.map (fun src -> DeviceInfo.DeviceInfo((src.DeviceType), (src.LogicalDevice |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.PhysicalDevice |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.Files |> Seq.map (fun src -> BackupRestoreFileInfo.BackupRestoreFileInfo((src.ItemKind), (src.Items |> Seq.map (fun x -> ValueExpression.FromCs(x, fragmentMapping)) |> List.ofSeq))) |> List.ofSeq), (src.Kind), (src.Options |> Seq.map (fun x -> RestoreOption.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.ReturnStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.ReturnStatement((src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.RevertStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.RevertStatement((src.Cookie |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.RoleStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.RoleStatement((RoleStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.RouteStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.RouteStatement((RouteStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.SecurityPolicyStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.SecurityPolicyStatement((SecurityPolicyStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.SecurityStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.SecurityStatement((SecurityStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.SecurityStatementBody80 as src->
          TSqlFragment.TSqlStatement((TSqlStatement.SecurityStatementBody80((SecurityStatementBody80.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.SendStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.SendStatement((src.ConversationHandles |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.MessageBody |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.MessageTypeName |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.SensitivityClassificationStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.SensitivityClassificationStatement((SensitivityClassificationStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.SequenceStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.SequenceStatement((SequenceStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.ServerAuditStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.ServerAuditStatement((ServerAuditStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.SetCommandStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.SetCommandStatement((src.Commands |> Seq.map (fun x -> SetCommand.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.SetErrorLevelStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.SetErrorLevelStatement((src.Level |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.SetOnOffStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.SetOnOffStatement((SetOnOffStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.SetRowCountStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.SetRowCountStatement((src.NumberRows |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.SetTextSizeStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.SetTextSizeStatement((src.TextSize |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.SetTransactionIsolationLevelStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.SetTransactionIsolationLevelStatement((src.Level))  ))
        | :? ScriptDom.SetUserStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.SetUserStatement((src.UserName |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))), (src.WithNoReset))  ))
        | :? ScriptDom.SetVariableStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.SetVariableStatement((src.AssignmentKind), (src.CursorDefinition |> Option.ofObj |> Option.map (fun x -> CursorDefinition.FromCs(x, fragmentMapping))), (src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.FunctionCallExists), (src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Parameters |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.SeparatorType), (src.Variable |> Option.ofObj |> Option.map (fun x -> VariableReference.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.ShutdownStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.ShutdownStatement((src.WithNoWait))  ))
        | :? ScriptDom.SignatureStatementBase as src->
          TSqlFragment.TSqlStatement((TSqlStatement.SignatureStatementBase((SignatureStatementBase.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.StatementWithCtesAndXmlNamespaces as src->
          TSqlFragment.TSqlStatement((TSqlStatement.StatementWithCtesAndXmlNamespaces((StatementWithCtesAndXmlNamespaces.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.SymmetricKeyStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.SymmetricKeyStatement((SymmetricKeyStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.TSqlStatementSnippet as src->
          TSqlFragment.TSqlStatement((TSqlStatement.TSqlStatementSnippet((Option.ofObj (src.Script)))  ))
        | :? ScriptDom.TextModificationStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.TextModificationStatement((TextModificationStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.ThrowStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.ThrowStatement((src.ErrorNumber |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))), (src.Message |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))), (src.State |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.TransactionStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.TransactionStatement((TransactionStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.TriggerStatementBody as src->
          TSqlFragment.TSqlStatement((TSqlStatement.TriggerStatementBody((TriggerStatementBody.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.TruncateTableStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.TruncateTableStatement((src.PartitionRanges |> Seq.map (fun src -> CompressionPartitionRange.CompressionPartitionRange((src.From |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.To |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.TableName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.TryCatchStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.TryCatchStatement((src.CatchStatements |> Option.ofObj |> Option.map (fun x -> StatementList.FromCs(x, fragmentMapping))), (src.TryStatements |> Option.ofObj |> Option.map (fun x -> StatementList.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.UpdateStatisticsStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.UpdateStatisticsStatement((src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.StatisticsOptions |> Seq.map (fun x -> StatisticsOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.SubElements |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.UseFederationStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.UseFederationStatement((src.DistributionName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.FederationName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Filtering), (src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.UseStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.UseStatement((src.DatabaseName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.UserStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.UserStatement((UserStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.ViewStatementBody as src->
          TSqlFragment.TSqlStatement((TSqlStatement.ViewStatementBody((ViewStatementBody.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.WaitForStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.WaitForStatement((src.Parameter |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))), (src.Statement |> Option.ofObj |> Option.map (fun x -> WaitForSupportedStatement.FromCs(x, fragmentMapping))), (src.Timeout |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.WaitForOption))  ))
        | :? ScriptDom.WaitForSupportedStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.WaitForSupportedStatement((WaitForSupportedStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.WhileStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.WhileStatement((src.Predicate |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))), (src.Statement |> Option.ofObj |> Option.map (fun x -> TSqlStatement.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.WorkloadClassifierStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.WorkloadClassifierStatement((WorkloadClassifierStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.WorkloadGroupStatement as src->
          TSqlFragment.TSqlStatement((TSqlStatement.WorkloadGroupStatement((WorkloadGroupStatement.FromCs(src, fragmentMapping)))  ))
      | :? ScriptDom.TableDefinition as src ->
        TSqlFragment.TableDefinition((src.ColumnDefinitions |> Seq.map (fun src -> ColumnDefinition.ColumnDefinition((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ComputedColumnExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.Constraints |> Seq.map (fun x -> ConstraintDefinition.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.DefaultConstraint |> Option.ofObj |> Option.map (fun x -> DefaultConstraintDefinition.FromCs(x, fragmentMapping))), (src.Encryption |> Option.ofObj |> Option.map (fun x -> ColumnEncryptionDefinition.FromCs(x, fragmentMapping))), (Option.ofNullable (src.GeneratedAlways)), (src.IdentityOptions |> Option.ofObj |> Option.map (fun x -> IdentityOptions.FromCs(x, fragmentMapping))), (src.Index |> Option.ofObj |> Option.map (fun x -> IndexDefinition.FromCs(x, fragmentMapping))), (src.IsHidden), (src.IsMasked), (src.IsPersisted), (src.IsRowGuidCol), (src.MaskingFunction |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))), (src.StorageOptions |> Option.ofObj |> Option.map (fun x -> ColumnStorageOptions.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.Indexes |> Seq.map (fun src -> IndexDefinition.IndexDefinition((src.Columns |> Seq.map (fun src -> ColumnWithSortOrder.ColumnWithSortOrder((src.Column |> Option.ofObj |> Option.map (fun x -> ColumnReferenceExpression.FromCs(x, fragmentMapping))), (src.SortOrder))) |> List.ofSeq), (src.FileStreamOn |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.FilterPredicate |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))), (src.IndexOptions |> Seq.map (fun x -> IndexOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.IndexType |> Option.ofObj |> Option.map (fun x -> IndexType.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.OnFileGroupOrPartitionScheme |> Option.ofObj |> Option.map (fun x -> FileGroupOrPartitionScheme.FromCs(x, fragmentMapping))), (src.Unique))) |> List.ofSeq),(src.SystemTimePeriod |> Option.ofObj |> Option.map (fun x -> SystemTimePeriodDefinition.FromCs(x, fragmentMapping))),(src.TableConstraints |> Seq.map (fun x -> ConstraintDefinition.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.TableDistributionPolicy as src ->
        match src with
        | :? ScriptDom.TableHashDistributionPolicy as src->
          TSqlFragment.TableDistributionPolicy((TableDistributionPolicy.TableHashDistributionPolicy((src.DistributionColumn |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.TableReplicateDistributionPolicy as src->
          TSqlFragment.TableDistributionPolicy((TableDistributionPolicy.TableReplicateDistributionPolicy  ))
        | :? ScriptDom.TableRoundRobinDistributionPolicy as src->
          TSqlFragment.TableDistributionPolicy((TableDistributionPolicy.TableRoundRobinDistributionPolicy  ))
      | :? ScriptDom.TableHint as src ->
        match src with
        | :? ScriptDom.ForceSeekTableHint as src->
          TSqlFragment.TableHint((TableHint.ForceSeekTableHint((src.ColumnValues |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.HintKind), (src.IndexValue |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.IndexTableHint as src->
          TSqlFragment.TableHint((TableHint.IndexTableHint((src.HintKind), (src.IndexValues |> Seq.map (fun src -> IdentifierOrValueExpression.IdentifierOrValueExpression((src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (Option.ofObj (src.Value)), (src.ValueExpression |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq))  ))
        | :? ScriptDom.LiteralTableHint as src->
          TSqlFragment.TableHint((TableHint.LiteralTableHint((src.HintKind), (src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | _ -> (* :? ScriptDom.TableHint as src *)
          TSqlFragment.TableHint((TableHint.Base((src.HintKind))))
      | :? ScriptDom.TableIndexType as src ->
        match src with
        | :? ScriptDom.TableClusteredIndexType as src->
          TSqlFragment.TableIndexType((TableIndexType.TableClusteredIndexType((src.ColumnStore), (src.Columns |> Seq.map (fun src -> ColumnWithSortOrder.ColumnWithSortOrder((src.Column |> Option.ofObj |> Option.map (fun x -> ColumnReferenceExpression.FromCs(x, fragmentMapping))), (src.SortOrder))) |> List.ofSeq), (src.OrderedColumns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq))  ))
        | :? ScriptDom.TableNonClusteredIndexType as src->
          TSqlFragment.TableIndexType((TableIndexType.TableNonClusteredIndexType  ))
      | :? ScriptDom.TableOption as src ->
        match src with
        | :? ScriptDom.DurabilityTableOption as src->
          TSqlFragment.TableOption((TableOption.DurabilityTableOption((src.DurabilityTableOptionKind), (src.OptionKind))  ))
        | :? ScriptDom.FileStreamOnTableOption as src->
          TSqlFragment.TableOption((TableOption.FileStreamOnTableOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.FileTableCollateFileNameTableOption as src->
          TSqlFragment.TableOption((TableOption.FileTableCollateFileNameTableOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.FileTableConstraintNameTableOption as src->
          TSqlFragment.TableOption((TableOption.FileTableConstraintNameTableOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.FileTableDirectoryTableOption as src->
          TSqlFragment.TableOption((TableOption.FileTableDirectoryTableOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.LocationOption as src->
          TSqlFragment.TableOption((TableOption.LocationOption((src.LocationValue |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.OptionKind))  ))
        | :? ScriptDom.LockEscalationTableOption as src->
          TSqlFragment.TableOption((TableOption.LockEscalationTableOption((src.OptionKind), (src.Value))  ))
        | :? ScriptDom.MemoryOptimizedTableOption as src->
          TSqlFragment.TableOption((TableOption.MemoryOptimizedTableOption((src.OptionKind), (src.OptionState))  ))
        | :? ScriptDom.RemoteDataArchiveAlterTableOption as src->
          TSqlFragment.TableOption((TableOption.RemoteDataArchiveAlterTableOption((src.FilterPredicate |> Option.ofObj |> Option.map (fun x -> FunctionCall.FromCs(x, fragmentMapping))), (src.IsFilterPredicateSpecified), (src.IsMigrationStateSpecified), (src.MigrationState), (src.OptionKind), (src.RdaTableOption))  ))
        | :? ScriptDom.RemoteDataArchiveTableOption as src->
          TSqlFragment.TableOption((TableOption.RemoteDataArchiveTableOption((src.MigrationState), (src.OptionKind), (src.RdaTableOption))  ))
        | :? ScriptDom.SystemVersioningTableOption as src->
          TSqlFragment.TableOption((TableOption.SystemVersioningTableOption((src.ConsistencyCheckEnabled), (src.HistoryTable |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.OptionKind), (src.OptionState), (src.RetentionPeriod |> Option.ofObj |> Option.map (fun x -> RetentionPeriodDefinition.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.TableDataCompressionOption as src->
          TSqlFragment.TableOption((TableOption.TableDataCompressionOption((src.DataCompressionOption |> Option.ofObj |> Option.map (fun x -> DataCompressionOption.FromCs(x, fragmentMapping))), (src.OptionKind))  ))
        | :? ScriptDom.TableDistributionOption as src->
          TSqlFragment.TableOption((TableOption.TableDistributionOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> TableDistributionPolicy.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.TableIndexOption as src->
          TSqlFragment.TableOption((TableOption.TableIndexOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> TableIndexType.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.TablePartitionOption as src->
          TSqlFragment.TableOption((TableOption.TablePartitionOption((src.OptionKind), (src.PartitionColumn |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.PartitionOptionSpecs |> Option.ofObj |> Option.map (fun x -> TablePartitionOptionSpecifications.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.TableReference as src ->
        match src with
        | :? ScriptDom.JoinParenthesisTableReference as src->
          TSqlFragment.TableReference((TableReference.JoinParenthesisTableReference((src.Join |> Option.ofObj |> Option.map (fun x -> TableReference.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.JoinTableReference as src->
          TSqlFragment.TableReference((TableReference.JoinTableReference((JoinTableReference.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.OdbcQualifiedJoinTableReference as src->
          TSqlFragment.TableReference((TableReference.OdbcQualifiedJoinTableReference((src.TableReference |> Option.ofObj |> Option.map (fun x -> TableReference.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.TableReferenceWithAlias as src->
          TSqlFragment.TableReference((TableReference.TableReferenceWithAlias((TableReferenceWithAlias.FromCs(src, fragmentMapping)))  ))
      | :? ScriptDom.TableSampleClause as src ->
        TSqlFragment.TableSampleClause((src.RepeatSeed |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.SampleNumber |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.System),(src.TableSampleClauseOption))
      | :? ScriptDom.TableSwitchOption as src ->
        match src with
        | :? ScriptDom.LowPriorityLockWaitTableSwitchOption as src->
          TSqlFragment.TableSwitchOption((TableSwitchOption.LowPriorityLockWaitTableSwitchOption((src.OptionKind), (src.Options |> Seq.map (fun x -> LowPriorityLockWaitOption.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.TruncateTargetTableSwitchOption as src->
          TSqlFragment.TableSwitchOption((TableSwitchOption.TruncateTargetTableSwitchOption((src.OptionKind), (src.TruncateTarget))  ))
      | :? ScriptDom.TargetDeclaration as src ->
        TSqlFragment.TargetDeclaration((src.ObjectName |> Option.ofObj |> Option.map (fun x -> EventSessionObjectName.FromCs(x, fragmentMapping))),(src.TargetDeclarationParameters |> Seq.map (fun src -> EventDeclarationSetParameter.EventDeclarationSetParameter((src.EventField |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.EventValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq))
      | :? ScriptDom.TemporalClause as src ->
        TSqlFragment.TemporalClause((src.EndTime |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.StartTime |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.TemporalClauseType))
      | :? ScriptDom.TopRowFilter as src ->
        TSqlFragment.TopRowFilter((src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.Percent),(src.WithTies))
      | :? ScriptDom.TriggerAction as src ->
        TSqlFragment.TriggerAction((src.EventTypeGroup |> Option.ofObj |> Option.map (fun x -> EventTypeGroupContainer.FromCs(x, fragmentMapping))),(src.TriggerActionType))
      | :? ScriptDom.TriggerObject as src ->
        TSqlFragment.TriggerObject((src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.TriggerScope))
      | :? ScriptDom.TriggerOption as src ->
        match src with
        | :? ScriptDom.ExecuteAsTriggerOption as src->
          TSqlFragment.TriggerOption((TriggerOption.ExecuteAsTriggerOption((src.ExecuteAsClause |> Option.ofObj |> Option.map (fun x -> ExecuteAsClause.FromCs(x, fragmentMapping))), (src.OptionKind))  ))
        | _ -> (* :? ScriptDom.TriggerOption as src *)
          TSqlFragment.TriggerOption((TriggerOption.Base((src.OptionKind))))
      | :? ScriptDom.UserLoginOption as src ->
        TSqlFragment.UserLoginOption((src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.UserLoginOptionType))
      | :? ScriptDom.VariableValuePair as src ->
        TSqlFragment.VariableValuePair((src.IsForUnknown),(src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.Variable |> Option.ofObj |> Option.map (fun x -> VariableReference.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ViewDistributionPolicy as src ->
        match src with
        | :? ScriptDom.ViewHashDistributionPolicy as src->
          TSqlFragment.ViewDistributionPolicy((ViewDistributionPolicy.ViewHashDistributionPolicy((src.DistributionColumn |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.ViewRoundRobinDistributionPolicy as src->
          TSqlFragment.ViewDistributionPolicy((ViewDistributionPolicy.ViewRoundRobinDistributionPolicy  ))
      | :? ScriptDom.ViewOption as src ->
        match src with
        | :? ScriptDom.ViewDistributionOption as src->
          TSqlFragment.ViewOption((ViewOption.ViewDistributionOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> ViewDistributionPolicy.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.ViewForAppendOption as src->
          TSqlFragment.ViewOption((ViewOption.ViewForAppendOption((src.OptionKind))  ))
        | _ -> (* :? ScriptDom.ViewOption as src *)
          TSqlFragment.ViewOption((ViewOption.Base((src.OptionKind))))
      | :? ScriptDom.WhenClause as src ->
        match src with
        | :? ScriptDom.SearchedWhenClause as src->
          TSqlFragment.WhenClause((WhenClause.SearchedWhenClause((src.ThenExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.WhenExpression |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.SimpleWhenClause as src->
          TSqlFragment.WhenClause((WhenClause.SimpleWhenClause((src.ThenExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.WhenExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.WhereClause as src ->
        TSqlFragment.WhereClause((src.Cursor |> Option.ofObj |> Option.map (fun x -> CursorId.FromCs(x, fragmentMapping))),(src.SearchCondition |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.WindowDelimiter as src ->
        TSqlFragment.WindowDelimiter((src.OffsetValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.WindowDelimiterType))
      | :? ScriptDom.WindowFrameClause as src ->
        TSqlFragment.WindowFrameClause((src.Bottom |> Option.ofObj |> Option.map (fun x -> WindowDelimiter.FromCs(x, fragmentMapping))),(src.Top |> Option.ofObj |> Option.map (fun x -> WindowDelimiter.FromCs(x, fragmentMapping))),(src.WindowFrameType))
      | :? ScriptDom.WithCtesAndXmlNamespaces as src ->
        TSqlFragment.WithCtesAndXmlNamespaces((src.ChangeTrackingContext |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))),(src.CommonTableExpressions |> Seq.map (fun src -> CommonTableExpression.CommonTableExpression((src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.ExpressionName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.QueryExpression |> Option.ofObj |> Option.map (fun x -> QueryExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.XmlNamespaces |> Option.ofObj |> Option.map (fun x -> XmlNamespaces.FromCs(x, fragmentMapping))))
      | :? ScriptDom.WithinGroupClause as src ->
        TSqlFragment.WithinGroupClause((src.HasGraphPath),(src.OrderByClause |> Option.ofObj |> Option.map (fun x -> OrderByClause.FromCs(x, fragmentMapping))))
      | :? ScriptDom.WlmTimeLiteral as src ->
        TSqlFragment.WlmTimeLiteral((src.TimeString |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))))
      | :? ScriptDom.WorkloadClassifierOption as src ->
        match src with
        | :? ScriptDom.ClassifierEndTimeOption as src->
          TSqlFragment.WorkloadClassifierOption((WorkloadClassifierOption.ClassifierEndTimeOption((src.OptionType), (src.Time |> Option.ofObj |> Option.map (fun x -> WlmTimeLiteral.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.ClassifierImportanceOption as src->
          TSqlFragment.WorkloadClassifierOption((WorkloadClassifierOption.ClassifierImportanceOption((src.Importance), (src.OptionType))  ))
        | :? ScriptDom.ClassifierMemberNameOption as src->
          TSqlFragment.WorkloadClassifierOption((WorkloadClassifierOption.ClassifierMemberNameOption((src.MemberName |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))), (src.OptionType))  ))
        | :? ScriptDom.ClassifierStartTimeOption as src->
          TSqlFragment.WorkloadClassifierOption((WorkloadClassifierOption.ClassifierStartTimeOption((src.OptionType), (src.Time |> Option.ofObj |> Option.map (fun x -> WlmTimeLiteral.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.ClassifierWlmContextOption as src->
          TSqlFragment.WorkloadClassifierOption((WorkloadClassifierOption.ClassifierWlmContextOption((src.OptionType), (src.WlmContext |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.ClassifierWlmLabelOption as src->
          TSqlFragment.WorkloadClassifierOption((WorkloadClassifierOption.ClassifierWlmLabelOption((src.OptionType), (src.WlmLabel |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.ClassifierWorkloadGroupOption as src->
          TSqlFragment.WorkloadClassifierOption((WorkloadClassifierOption.ClassifierWorkloadGroupOption((src.OptionType), (src.WorkloadGroupName |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.WorkloadGroupParameter as src ->
        match src with
        | :? ScriptDom.WorkloadGroupImportanceParameter as src->
          TSqlFragment.WorkloadGroupParameter((WorkloadGroupParameter.WorkloadGroupImportanceParameter((src.ParameterType), (src.ParameterValue))  ))
        | :? ScriptDom.WorkloadGroupResourceParameter as src->
          TSqlFragment.WorkloadGroupParameter((WorkloadGroupParameter.WorkloadGroupResourceParameter((src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.XmlNamespaces as src ->
        TSqlFragment.XmlNamespaces((src.XmlNamespacesElements |> Seq.map (fun x -> XmlNamespacesElement.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.XmlNamespacesElement as src ->
        match src with
        | :? ScriptDom.XmlNamespacesAliasElement as src->
          TSqlFragment.XmlNamespacesElement((XmlNamespacesElement.XmlNamespacesAliasElement((src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.String |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.XmlNamespacesDefaultElement as src->
          TSqlFragment.XmlNamespacesElement((XmlNamespacesElement.XmlNamespacesDefaultElement((src.String |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))))  ))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] AlterAvailabilityGroupAction = (* IsAbstract = false *)
  | Base of ActionType:ScriptDom.AlterAvailabilityGroupActionType
  | AlterAvailabilityGroupFailoverAction of ActionType:ScriptDom.AlterAvailabilityGroupActionType * Options:(AlterAvailabilityGroupFailoverOption) list
  member this.ToCs() : ScriptDom.AlterAvailabilityGroupAction =
    match this with
    | AlterAvailabilityGroupFailoverAction(ActionType=aActionType; Options=aOptions) ->
      let ret = ScriptDom.AlterAvailabilityGroupFailoverAction()
      ret.ActionType <- aActionType
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.AlterAvailabilityGroupAction (* 335 *)
    | Base(ActionType=aActionType) ->

      let ret = ScriptDom.AlterAvailabilityGroupAction()
      ret.ActionType <- aActionType
      ret
  static member FromCs(src:ScriptDom.AlterAvailabilityGroupAction, fragmentMapping:FragmentMapping) : AlterAvailabilityGroupAction =
    let ret =
      match src with
      | :? ScriptDom.AlterAvailabilityGroupFailoverAction as src ->
        AlterAvailabilityGroupAction.AlterAvailabilityGroupFailoverAction((src.ActionType),(src.Options |> Seq.map (fun src -> AlterAvailabilityGroupFailoverOption.AlterAvailabilityGroupFailoverOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq))
      | _ -> (* :? ScriptDom.AlterAvailabilityGroupAction as src *)
        AlterAvailabilityGroupAction.Base(((src.ActionType))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] AlterFullTextIndexAction = (* IsAbstract = true *)
  | AddAlterFullTextIndexAction of Columns:(FullTextIndexColumn) list * WithNoPopulation:bool
  | AlterColumnAlterFullTextIndexAction of Column:FullTextIndexColumn option * WithNoPopulation:bool
  | DropAlterFullTextIndexAction of Columns:(Identifier) list * WithNoPopulation:bool
  | SetSearchPropertyListAlterFullTextIndexAction of SearchPropertyListOption:SearchPropertyListFullTextIndexOption option * WithNoPopulation:bool
  | SetStopListAlterFullTextIndexAction of StopListOption:StopListFullTextIndexOption option * WithNoPopulation:bool
  | SimpleAlterFullTextIndexAction of ActionKind:ScriptDom.SimpleAlterFullTextIndexActionKind
  member this.ToCs() : ScriptDom.AlterFullTextIndexAction =
    match this with
    | AddAlterFullTextIndexAction(Columns=aColumns; WithNoPopulation=aWithNoPopulation) ->
      let ret = ScriptDom.AddAlterFullTextIndexAction()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.WithNoPopulation <- aWithNoPopulation
      ret :> ScriptDom.AlterFullTextIndexAction (* 335 *)
    | AlterColumnAlterFullTextIndexAction(Column=aColumn; WithNoPopulation=aWithNoPopulation) ->
      let ret = ScriptDom.AlterColumnAlterFullTextIndexAction()
      ret.Column <- aColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WithNoPopulation <- aWithNoPopulation
      ret :> ScriptDom.AlterFullTextIndexAction (* 335 *)
    | DropAlterFullTextIndexAction(Columns=aColumns; WithNoPopulation=aWithNoPopulation) ->
      let ret = ScriptDom.DropAlterFullTextIndexAction()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.WithNoPopulation <- aWithNoPopulation
      ret :> ScriptDom.AlterFullTextIndexAction (* 335 *)
    | SetSearchPropertyListAlterFullTextIndexAction(SearchPropertyListOption=aSearchPropertyListOption; WithNoPopulation=aWithNoPopulation) ->
      let ret = ScriptDom.SetSearchPropertyListAlterFullTextIndexAction()
      ret.SearchPropertyListOption <- aSearchPropertyListOption |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WithNoPopulation <- aWithNoPopulation
      ret :> ScriptDom.AlterFullTextIndexAction (* 335 *)
    | SetStopListAlterFullTextIndexAction(StopListOption=aStopListOption; WithNoPopulation=aWithNoPopulation) ->
      let ret = ScriptDom.SetStopListAlterFullTextIndexAction()
      ret.StopListOption <- aStopListOption |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WithNoPopulation <- aWithNoPopulation
      ret :> ScriptDom.AlterFullTextIndexAction (* 335 *)
    | SimpleAlterFullTextIndexAction(ActionKind=aActionKind) ->
      let ret = ScriptDom.SimpleAlterFullTextIndexAction()
      ret.ActionKind <- aActionKind
      ret :> ScriptDom.AlterFullTextIndexAction (* 335 *)
  static member FromCs(src:ScriptDom.AlterFullTextIndexAction, fragmentMapping:FragmentMapping) : AlterFullTextIndexAction =
    let ret =
      match src with
      | :? ScriptDom.AddAlterFullTextIndexAction as src ->
        AlterFullTextIndexAction.AddAlterFullTextIndexAction((src.Columns |> Seq.map (fun src -> FullTextIndexColumn.FullTextIndexColumn((src.LanguageTerm |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.StatisticalSemantics), (src.TypeColumn |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.WithNoPopulation))
      | :? ScriptDom.AlterColumnAlterFullTextIndexAction as src ->
        AlterFullTextIndexAction.AlterColumnAlterFullTextIndexAction((src.Column |> Option.ofObj |> Option.map (fun x -> FullTextIndexColumn.FromCs(x, fragmentMapping))),(src.WithNoPopulation))
      | :? ScriptDom.DropAlterFullTextIndexAction as src ->
        AlterFullTextIndexAction.DropAlterFullTextIndexAction((src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.WithNoPopulation))
      | :? ScriptDom.SetSearchPropertyListAlterFullTextIndexAction as src ->
        AlterFullTextIndexAction.SetSearchPropertyListAlterFullTextIndexAction((src.SearchPropertyListOption |> Option.ofObj |> Option.map (fun x -> SearchPropertyListFullTextIndexOption.FromCs(x, fragmentMapping))),(src.WithNoPopulation))
      | :? ScriptDom.SetStopListAlterFullTextIndexAction as src ->
        AlterFullTextIndexAction.SetStopListAlterFullTextIndexAction((src.StopListOption |> Option.ofObj |> Option.map (fun x -> StopListFullTextIndexOption.FromCs(x, fragmentMapping))),(src.WithNoPopulation))
      | :? ScriptDom.SimpleAlterFullTextIndexAction as src ->
        AlterFullTextIndexAction.SimpleAlterFullTextIndexAction((src.ActionKind))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] AlterRoleAction = (* IsAbstract = true *)
  | AddMemberAlterRoleAction of Member:Identifier option
  | DropMemberAlterRoleAction of Member:Identifier option
  | RenameAlterRoleAction of NewName:Identifier option
  member this.ToCs() : ScriptDom.AlterRoleAction =
    match this with
    | AddMemberAlterRoleAction(Member=aMember) ->
      let ret = ScriptDom.AddMemberAlterRoleAction()
      ret.Member <- aMember |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AlterRoleAction (* 335 *)
    | DropMemberAlterRoleAction(Member=aMember) ->
      let ret = ScriptDom.DropMemberAlterRoleAction()
      ret.Member <- aMember |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AlterRoleAction (* 335 *)
    | RenameAlterRoleAction(NewName=aNewName) ->
      let ret = ScriptDom.RenameAlterRoleAction()
      ret.NewName <- aNewName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AlterRoleAction (* 335 *)
  static member FromCs(src:ScriptDom.AlterRoleAction, fragmentMapping:FragmentMapping) : AlterRoleAction =
    let ret =
      match src with
      | :? ScriptDom.AddMemberAlterRoleAction as src ->
        AlterRoleAction.AddMemberAlterRoleAction((src.Member |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropMemberAlterRoleAction as src ->
        AlterRoleAction.DropMemberAlterRoleAction((src.Member |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.RenameAlterRoleAction as src ->
        AlterRoleAction.RenameAlterRoleAction((src.NewName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] AlterServerConfigurationBufferPoolExtensionOption = (* IsAbstract = false *)
  | Base of OptionKind:ScriptDom.AlterServerConfigurationBufferPoolExtensionOptionKind * OptionValue:OptionValue option
  | AlterServerConfigurationBufferPoolExtensionContainerOption of OptionKind:ScriptDom.AlterServerConfigurationBufferPoolExtensionOptionKind * OptionValue:OptionValue option * Suboptions:(AlterServerConfigurationBufferPoolExtensionOption) list
  | AlterServerConfigurationBufferPoolExtensionSizeOption of OptionKind:ScriptDom.AlterServerConfigurationBufferPoolExtensionOptionKind * OptionValue:OptionValue option * SizeUnit:ScriptDom.MemoryUnit
  member this.ToCs() : ScriptDom.AlterServerConfigurationBufferPoolExtensionOption =
    match this with
    | AlterServerConfigurationBufferPoolExtensionContainerOption(OptionKind=aOptionKind; OptionValue=aOptionValue; Suboptions=aSuboptions) ->
      let ret = ScriptDom.AlterServerConfigurationBufferPoolExtensionContainerOption()
      ret.OptionKind <- aOptionKind
      ret.OptionValue <- aOptionValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aSuboptions do ret.Suboptions.Add (e.ToCs())
      ret :> ScriptDom.AlterServerConfigurationBufferPoolExtensionOption (* 335 *)
    | AlterServerConfigurationBufferPoolExtensionSizeOption(OptionKind=aOptionKind; OptionValue=aOptionValue; SizeUnit=aSizeUnit) ->
      let ret = ScriptDom.AlterServerConfigurationBufferPoolExtensionSizeOption()
      ret.OptionKind <- aOptionKind
      ret.OptionValue <- aOptionValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SizeUnit <- aSizeUnit
      ret :> ScriptDom.AlterServerConfigurationBufferPoolExtensionOption (* 335 *)
    | Base(OptionKind=aOptionKind; OptionValue=aOptionValue) ->

      let ret = ScriptDom.AlterServerConfigurationBufferPoolExtensionOption()
      ret.OptionKind <- aOptionKind
      ret.OptionValue <- aOptionValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret
  static member FromCs(src:ScriptDom.AlterServerConfigurationBufferPoolExtensionOption, fragmentMapping:FragmentMapping) : AlterServerConfigurationBufferPoolExtensionOption =
    let ret =
      match src with
      | :? ScriptDom.AlterServerConfigurationBufferPoolExtensionContainerOption as src ->
        AlterServerConfigurationBufferPoolExtensionOption.AlterServerConfigurationBufferPoolExtensionContainerOption((src.OptionKind),(src.OptionValue |> Option.ofObj |> Option.map (fun x -> OptionValue.FromCs(x, fragmentMapping))),(src.Suboptions |> Seq.map (fun x -> AlterServerConfigurationBufferPoolExtensionOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.AlterServerConfigurationBufferPoolExtensionSizeOption as src ->
        AlterServerConfigurationBufferPoolExtensionOption.AlterServerConfigurationBufferPoolExtensionSizeOption((src.OptionKind),(src.OptionValue |> Option.ofObj |> Option.map (fun x -> OptionValue.FromCs(x, fragmentMapping))),(src.SizeUnit))
      | _ -> (* :? ScriptDom.AlterServerConfigurationBufferPoolExtensionOption as src *)
        AlterServerConfigurationBufferPoolExtensionOption.Base(((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (fun x -> OptionValue.FromCs(x, fragmentMapping))))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] AlterServerConfigurationDiagnosticsLogOption = (* IsAbstract = false *)
  | Base of OptionKind:ScriptDom.AlterServerConfigurationDiagnosticsLogOptionKind * OptionValue:OptionValue option
  | AlterServerConfigurationDiagnosticsLogMaxSizeOption of OptionKind:ScriptDom.AlterServerConfigurationDiagnosticsLogOptionKind * OptionValue:OptionValue option * SizeUnit:ScriptDom.MemoryUnit
  member this.ToCs() : ScriptDom.AlterServerConfigurationDiagnosticsLogOption =
    match this with
    | AlterServerConfigurationDiagnosticsLogMaxSizeOption(OptionKind=aOptionKind; OptionValue=aOptionValue; SizeUnit=aSizeUnit) ->
      let ret = ScriptDom.AlterServerConfigurationDiagnosticsLogMaxSizeOption()
      ret.OptionKind <- aOptionKind
      ret.OptionValue <- aOptionValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SizeUnit <- aSizeUnit
      ret :> ScriptDom.AlterServerConfigurationDiagnosticsLogOption (* 335 *)
    | Base(OptionKind=aOptionKind; OptionValue=aOptionValue) ->

      let ret = ScriptDom.AlterServerConfigurationDiagnosticsLogOption()
      ret.OptionKind <- aOptionKind
      ret.OptionValue <- aOptionValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret
  static member FromCs(src:ScriptDom.AlterServerConfigurationDiagnosticsLogOption, fragmentMapping:FragmentMapping) : AlterServerConfigurationDiagnosticsLogOption =
    let ret =
      match src with
      | :? ScriptDom.AlterServerConfigurationDiagnosticsLogMaxSizeOption as src ->
        AlterServerConfigurationDiagnosticsLogOption.AlterServerConfigurationDiagnosticsLogMaxSizeOption((src.OptionKind),(src.OptionValue |> Option.ofObj |> Option.map (fun x -> OptionValue.FromCs(x, fragmentMapping))),(src.SizeUnit))
      | _ -> (* :? ScriptDom.AlterServerConfigurationDiagnosticsLogOption as src *)
        AlterServerConfigurationDiagnosticsLogOption.Base(((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (fun x -> OptionValue.FromCs(x, fragmentMapping))))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] AlterServerConfigurationExternalAuthenticationOption = (* IsAbstract = false *)
  | Base of OptionKind:ScriptDom.AlterServerConfigurationExternalAuthenticationOptionKind * OptionValue:OptionValue option
  | AlterServerConfigurationExternalAuthenticationContainerOption of OptionKind:ScriptDom.AlterServerConfigurationExternalAuthenticationOptionKind * OptionValue:OptionValue option * Suboptions:(AlterServerConfigurationExternalAuthenticationOption) list
  member this.ToCs() : ScriptDom.AlterServerConfigurationExternalAuthenticationOption =
    match this with
    | AlterServerConfigurationExternalAuthenticationContainerOption(OptionKind=aOptionKind; OptionValue=aOptionValue; Suboptions=aSuboptions) ->
      let ret = ScriptDom.AlterServerConfigurationExternalAuthenticationContainerOption()
      ret.OptionKind <- aOptionKind
      ret.OptionValue <- aOptionValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aSuboptions do ret.Suboptions.Add (e.ToCs())
      ret :> ScriptDom.AlterServerConfigurationExternalAuthenticationOption (* 335 *)
    | Base(OptionKind=aOptionKind; OptionValue=aOptionValue) ->

      let ret = ScriptDom.AlterServerConfigurationExternalAuthenticationOption()
      ret.OptionKind <- aOptionKind
      ret.OptionValue <- aOptionValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret
  static member FromCs(src:ScriptDom.AlterServerConfigurationExternalAuthenticationOption, fragmentMapping:FragmentMapping) : AlterServerConfigurationExternalAuthenticationOption =
    let ret =
      match src with
      | :? ScriptDom.AlterServerConfigurationExternalAuthenticationContainerOption as src ->
        AlterServerConfigurationExternalAuthenticationOption.AlterServerConfigurationExternalAuthenticationContainerOption((src.OptionKind),(src.OptionValue |> Option.ofObj |> Option.map (fun x -> OptionValue.FromCs(x, fragmentMapping))),(src.Suboptions |> Seq.map (fun x -> AlterServerConfigurationExternalAuthenticationOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | _ -> (* :? ScriptDom.AlterServerConfigurationExternalAuthenticationOption as src *)
        AlterServerConfigurationExternalAuthenticationOption.Base(((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (fun x -> OptionValue.FromCs(x, fragmentMapping))))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] AssemblyOption = (* IsAbstract = false *)
  | Base of OptionKind:ScriptDom.AssemblyOptionKind
  | OnOffAssemblyOption of OptionKind:ScriptDom.AssemblyOptionKind * OptionState:ScriptDom.OptionState
  | PermissionSetAssemblyOption of OptionKind:ScriptDom.AssemblyOptionKind * PermissionSetOption:ScriptDom.PermissionSetOption
  member this.ToCs() : ScriptDom.AssemblyOption =
    match this with
    | OnOffAssemblyOption(OptionKind=aOptionKind; OptionState=aOptionState) ->
      let ret = ScriptDom.OnOffAssemblyOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret :> ScriptDom.AssemblyOption (* 335 *)
    | PermissionSetAssemblyOption(OptionKind=aOptionKind; PermissionSetOption=aPermissionSetOption) ->
      let ret = ScriptDom.PermissionSetAssemblyOption()
      ret.OptionKind <- aOptionKind
      ret.PermissionSetOption <- aPermissionSetOption
      ret :> ScriptDom.AssemblyOption (* 335 *)
    | Base(OptionKind=aOptionKind) ->

      let ret = ScriptDom.AssemblyOption()
      ret.OptionKind <- aOptionKind
      ret
  static member FromCs(src:ScriptDom.AssemblyOption, fragmentMapping:FragmentMapping) : AssemblyOption =
    let ret =
      match src with
      | :? ScriptDom.OnOffAssemblyOption as src ->
        AssemblyOption.OnOffAssemblyOption((src.OptionKind),(src.OptionState))
      | :? ScriptDom.PermissionSetAssemblyOption as src ->
        AssemblyOption.PermissionSetAssemblyOption((src.OptionKind),(src.PermissionSetOption))
      | _ -> (* :? ScriptDom.AssemblyOption as src *)
        AssemblyOption.Base(((src.OptionKind))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] AtomicBlockOption = (* IsAbstract = true *)
  | IdentifierAtomicBlockOption of OptionKind:ScriptDom.AtomicBlockOptionKind * Value:Identifier option
  | LiteralAtomicBlockOption of OptionKind:ScriptDom.AtomicBlockOptionKind * Value:Literal option
  | OnOffAtomicBlockOption of OptionKind:ScriptDom.AtomicBlockOptionKind * OptionState:ScriptDom.OptionState
  member this.ToCs() : ScriptDom.AtomicBlockOption =
    match this with
    | IdentifierAtomicBlockOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.IdentifierAtomicBlockOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AtomicBlockOption (* 335 *)
    | LiteralAtomicBlockOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.LiteralAtomicBlockOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AtomicBlockOption (* 335 *)
    | OnOffAtomicBlockOption(OptionKind=aOptionKind; OptionState=aOptionState) ->
      let ret = ScriptDom.OnOffAtomicBlockOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret :> ScriptDom.AtomicBlockOption (* 335 *)
  static member FromCs(src:ScriptDom.AtomicBlockOption, fragmentMapping:FragmentMapping) : AtomicBlockOption =
    let ret =
      match src with
      | :? ScriptDom.IdentifierAtomicBlockOption as src ->
        AtomicBlockOption.IdentifierAtomicBlockOption((src.OptionKind),(src.Value |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.LiteralAtomicBlockOption as src ->
        AtomicBlockOption.LiteralAtomicBlockOption((src.OptionKind),(src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.OnOffAtomicBlockOption as src ->
        AtomicBlockOption.OnOffAtomicBlockOption((src.OptionKind),(src.OptionState))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] AuditOption = (* IsAbstract = true *)
  | AuditGuidAuditOption of Guid:Literal option * OptionKind:ScriptDom.AuditOptionKind
  | OnFailureAuditOption of OnFailureAction:ScriptDom.AuditFailureActionType * OptionKind:ScriptDom.AuditOptionKind
  | QueueDelayAuditOption of Delay:Literal option * OptionKind:ScriptDom.AuditOptionKind
  | StateAuditOption of OptionKind:ScriptDom.AuditOptionKind * Value:ScriptDom.OptionState
  member this.ToCs() : ScriptDom.AuditOption =
    match this with
    | AuditGuidAuditOption(Guid=aGuid; OptionKind=aOptionKind) ->
      let ret = ScriptDom.AuditGuidAuditOption()
      ret.Guid <- aGuid |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.AuditOption (* 335 *)
    | OnFailureAuditOption(OnFailureAction=aOnFailureAction; OptionKind=aOptionKind) ->
      let ret = ScriptDom.OnFailureAuditOption()
      ret.OnFailureAction <- aOnFailureAction
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.AuditOption (* 335 *)
    | QueueDelayAuditOption(Delay=aDelay; OptionKind=aOptionKind) ->
      let ret = ScriptDom.QueueDelayAuditOption()
      ret.Delay <- aDelay |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.AuditOption (* 335 *)
    | StateAuditOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.StateAuditOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.AuditOption (* 335 *)
  static member FromCs(src:ScriptDom.AuditOption, fragmentMapping:FragmentMapping) : AuditOption =
    let ret =
      match src with
      | :? ScriptDom.AuditGuidAuditOption as src ->
        AuditOption.AuditGuidAuditOption((src.Guid |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.OptionKind))
      | :? ScriptDom.OnFailureAuditOption as src ->
        AuditOption.OnFailureAuditOption((src.OnFailureAction),(src.OptionKind))
      | :? ScriptDom.QueueDelayAuditOption as src ->
        AuditOption.QueueDelayAuditOption((src.Delay |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.OptionKind))
      | :? ScriptDom.StateAuditOption as src ->
        AuditOption.StateAuditOption((src.OptionKind),(src.Value))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] AuditSpecificationDetail = (* IsAbstract = true *)
  | AuditActionGroupReference of Group:ScriptDom.AuditActionGroup
  | AuditActionSpecification of Actions:(DatabaseAuditAction) list * Principals:(SecurityPrincipal) list * TargetObject:SecurityTargetObject option
  member this.ToCs() : ScriptDom.AuditSpecificationDetail =
    match this with
    | AuditActionGroupReference(Group=aGroup) ->
      let ret = ScriptDom.AuditActionGroupReference()
      ret.Group <- aGroup
      ret :> ScriptDom.AuditSpecificationDetail (* 335 *)
    | AuditActionSpecification(Actions=aActions; Principals=aPrincipals; TargetObject=aTargetObject) ->
      let ret = ScriptDom.AuditActionSpecification()
      for e in aActions do ret.Actions.Add (e.ToCs())
      for e in aPrincipals do ret.Principals.Add (e.ToCs())
      ret.TargetObject <- aTargetObject |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AuditSpecificationDetail (* 335 *)
  static member FromCs(src:ScriptDom.AuditSpecificationDetail, fragmentMapping:FragmentMapping) : AuditSpecificationDetail =
    let ret =
      match src with
      | :? ScriptDom.AuditActionGroupReference as src ->
        AuditSpecificationDetail.AuditActionGroupReference((src.Group))
      | :? ScriptDom.AuditActionSpecification as src ->
        AuditSpecificationDetail.AuditActionSpecification((src.Actions |> Seq.map (fun src -> DatabaseAuditAction.DatabaseAuditAction((src.ActionKind))) |> List.ofSeq),(src.Principals |> Seq.map (fun src -> SecurityPrincipal.SecurityPrincipal((src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.PrincipalType))) |> List.ofSeq),(src.TargetObject |> Option.ofObj |> Option.map (fun x -> SecurityTargetObject.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] AuditTargetOption = (* IsAbstract = true *)
  | LiteralAuditTargetOption of OptionKind:ScriptDom.AuditTargetOptionKind * Value:Literal option
  | MaxRolloverFilesAuditTargetOption of IsUnlimited:bool * OptionKind:ScriptDom.AuditTargetOptionKind * Value:Literal option
  | MaxSizeAuditTargetOption of IsUnlimited:bool * OptionKind:ScriptDom.AuditTargetOptionKind * Size:Literal option * Unit:ScriptDom.MemoryUnit
  | OnOffAuditTargetOption of OptionKind:ScriptDom.AuditTargetOptionKind * Value:ScriptDom.OptionState
  | RetentionDaysAuditTargetOption of Days:Literal option * OptionKind:ScriptDom.AuditTargetOptionKind
  member this.ToCs() : ScriptDom.AuditTargetOption =
    match this with
    | LiteralAuditTargetOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.LiteralAuditTargetOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AuditTargetOption (* 335 *)
    | MaxRolloverFilesAuditTargetOption(IsUnlimited=aIsUnlimited; OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.MaxRolloverFilesAuditTargetOption()
      ret.IsUnlimited <- aIsUnlimited
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AuditTargetOption (* 335 *)
    | MaxSizeAuditTargetOption(IsUnlimited=aIsUnlimited; OptionKind=aOptionKind; Size=aSize; Unit=aUnit) ->
      let ret = ScriptDom.MaxSizeAuditTargetOption()
      ret.IsUnlimited <- aIsUnlimited
      ret.OptionKind <- aOptionKind
      ret.Size <- aSize |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Unit <- aUnit
      ret :> ScriptDom.AuditTargetOption (* 335 *)
    | OnOffAuditTargetOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.OnOffAuditTargetOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.AuditTargetOption (* 335 *)
    | RetentionDaysAuditTargetOption(Days=aDays; OptionKind=aOptionKind) ->
      let ret = ScriptDom.RetentionDaysAuditTargetOption()
      ret.Days <- aDays |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.AuditTargetOption (* 335 *)
  static member FromCs(src:ScriptDom.AuditTargetOption, fragmentMapping:FragmentMapping) : AuditTargetOption =
    let ret =
      match src with
      | :? ScriptDom.LiteralAuditTargetOption as src ->
        AuditTargetOption.LiteralAuditTargetOption((src.OptionKind),(src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.MaxRolloverFilesAuditTargetOption as src ->
        AuditTargetOption.MaxRolloverFilesAuditTargetOption((src.IsUnlimited),(src.OptionKind),(src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.MaxSizeAuditTargetOption as src ->
        AuditTargetOption.MaxSizeAuditTargetOption((src.IsUnlimited),(src.OptionKind),(src.Size |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.Unit))
      | :? ScriptDom.OnOffAuditTargetOption as src ->
        AuditTargetOption.OnOffAuditTargetOption((src.OptionKind),(src.Value))
      | :? ScriptDom.RetentionDaysAuditTargetOption as src ->
        AuditTargetOption.RetentionDaysAuditTargetOption((src.Days |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.OptionKind))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] AutomaticTuningOption = (* IsAbstract = false *)
  | Base of OptionKind:ScriptDom.AutomaticTuningOptionKind * Value:ScriptDom.AutomaticTuningOptionState
  | AutomaticTuningCreateIndexOption of OptionKind:ScriptDom.AutomaticTuningOptionKind * Value:ScriptDom.AutomaticTuningOptionState
  | AutomaticTuningDropIndexOption of OptionKind:ScriptDom.AutomaticTuningOptionKind * Value:ScriptDom.AutomaticTuningOptionState
  | AutomaticTuningForceLastGoodPlanOption of OptionKind:ScriptDom.AutomaticTuningOptionKind * Value:ScriptDom.AutomaticTuningOptionState
  | AutomaticTuningMaintainIndexOption of OptionKind:ScriptDom.AutomaticTuningOptionKind * Value:ScriptDom.AutomaticTuningOptionState
  member this.ToCs() : ScriptDom.AutomaticTuningOption =
    match this with
    | AutomaticTuningCreateIndexOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.AutomaticTuningCreateIndexOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.AutomaticTuningOption (* 335 *)
    | AutomaticTuningDropIndexOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.AutomaticTuningDropIndexOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.AutomaticTuningOption (* 335 *)
    | AutomaticTuningForceLastGoodPlanOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.AutomaticTuningForceLastGoodPlanOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.AutomaticTuningOption (* 335 *)
    | AutomaticTuningMaintainIndexOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.AutomaticTuningMaintainIndexOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.AutomaticTuningOption (* 335 *)
    | Base(OptionKind=aOptionKind; Value=aValue) ->

      let ret = ScriptDom.AutomaticTuningOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret
  static member FromCs(src:ScriptDom.AutomaticTuningOption, fragmentMapping:FragmentMapping) : AutomaticTuningOption =
    let ret =
      match src with
      | :? ScriptDom.AutomaticTuningCreateIndexOption as src ->
        AutomaticTuningOption.AutomaticTuningCreateIndexOption((src.OptionKind),(src.Value))
      | :? ScriptDom.AutomaticTuningDropIndexOption as src ->
        AutomaticTuningOption.AutomaticTuningDropIndexOption((src.OptionKind),(src.Value))
      | :? ScriptDom.AutomaticTuningForceLastGoodPlanOption as src ->
        AutomaticTuningOption.AutomaticTuningForceLastGoodPlanOption((src.OptionKind),(src.Value))
      | :? ScriptDom.AutomaticTuningMaintainIndexOption as src ->
        AutomaticTuningOption.AutomaticTuningMaintainIndexOption((src.OptionKind),(src.Value))
      | _ -> (* :? ScriptDom.AutomaticTuningOption as src *)
        AutomaticTuningOption.Base(((src.OptionKind), (src.Value))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] AvailabilityGroupOption = (* IsAbstract = true *)
  | LiteralAvailabilityGroupOption of OptionKind:ScriptDom.AvailabilityGroupOptionKind * Value:Literal option
  member this.ToCs() : ScriptDom.AvailabilityGroupOption =
    match this with
    | LiteralAvailabilityGroupOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.LiteralAvailabilityGroupOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AvailabilityGroupOption (* 335 *)
  static member FromCs(src:ScriptDom.AvailabilityGroupOption, fragmentMapping:FragmentMapping) : AvailabilityGroupOption =
    let ret =
      match src with
      | :? ScriptDom.LiteralAvailabilityGroupOption as src ->
        AvailabilityGroupOption.LiteralAvailabilityGroupOption((src.OptionKind),(src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] AvailabilityReplicaOption = (* IsAbstract = true *)
  | AvailabilityModeReplicaOption of OptionKind:ScriptDom.AvailabilityReplicaOptionKind * Value:ScriptDom.AvailabilityModeOptionKind
  | FailoverModeReplicaOption of OptionKind:ScriptDom.AvailabilityReplicaOptionKind * Value:ScriptDom.FailoverModeOptionKind
  | LiteralReplicaOption of OptionKind:ScriptDom.AvailabilityReplicaOptionKind * Value:Literal option
  | PrimaryRoleReplicaOption of AllowConnections:ScriptDom.AllowConnectionsOptionKind * OptionKind:ScriptDom.AvailabilityReplicaOptionKind
  | SecondaryRoleReplicaOption of AllowConnections:ScriptDom.AllowConnectionsOptionKind * OptionKind:ScriptDom.AvailabilityReplicaOptionKind
  member this.ToCs() : ScriptDom.AvailabilityReplicaOption =
    match this with
    | AvailabilityModeReplicaOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.AvailabilityModeReplicaOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.AvailabilityReplicaOption (* 335 *)
    | FailoverModeReplicaOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.FailoverModeReplicaOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.AvailabilityReplicaOption (* 335 *)
    | LiteralReplicaOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.LiteralReplicaOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AvailabilityReplicaOption (* 335 *)
    | PrimaryRoleReplicaOption(AllowConnections=aAllowConnections; OptionKind=aOptionKind) ->
      let ret = ScriptDom.PrimaryRoleReplicaOption()
      ret.AllowConnections <- aAllowConnections
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.AvailabilityReplicaOption (* 335 *)
    | SecondaryRoleReplicaOption(AllowConnections=aAllowConnections; OptionKind=aOptionKind) ->
      let ret = ScriptDom.SecondaryRoleReplicaOption()
      ret.AllowConnections <- aAllowConnections
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.AvailabilityReplicaOption (* 335 *)
  static member FromCs(src:ScriptDom.AvailabilityReplicaOption, fragmentMapping:FragmentMapping) : AvailabilityReplicaOption =
    let ret =
      match src with
      | :? ScriptDom.AvailabilityModeReplicaOption as src ->
        AvailabilityReplicaOption.AvailabilityModeReplicaOption((src.OptionKind),(src.Value))
      | :? ScriptDom.FailoverModeReplicaOption as src ->
        AvailabilityReplicaOption.FailoverModeReplicaOption((src.OptionKind),(src.Value))
      | :? ScriptDom.LiteralReplicaOption as src ->
        AvailabilityReplicaOption.LiteralReplicaOption((src.OptionKind),(src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.PrimaryRoleReplicaOption as src ->
        AvailabilityReplicaOption.PrimaryRoleReplicaOption((src.AllowConnections),(src.OptionKind))
      | :? ScriptDom.SecondaryRoleReplicaOption as src ->
        AvailabilityReplicaOption.SecondaryRoleReplicaOption((src.AllowConnections),(src.OptionKind))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] BackupOption = (* IsAbstract = false *)
  | Base of OptionKind:ScriptDom.BackupOptionKind * Value:ScalarExpression option
  | BackupEncryptionOption of Algorithm:ScriptDom.EncryptionAlgorithm * Encryptor:CryptoMechanism option * OptionKind:ScriptDom.BackupOptionKind * Value:ScalarExpression option
  member this.ToCs() : ScriptDom.BackupOption =
    match this with
    | BackupEncryptionOption(Algorithm=aAlgorithm; Encryptor=aEncryptor; OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.BackupEncryptionOption()
      ret.Algorithm <- aAlgorithm
      ret.Encryptor <- aEncryptor |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BackupOption (* 335 *)
    | Base(OptionKind=aOptionKind; Value=aValue) ->

      let ret = ScriptDom.BackupOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret
  static member FromCs(src:ScriptDom.BackupOption, fragmentMapping:FragmentMapping) : BackupOption =
    let ret =
      match src with
      | :? ScriptDom.BackupEncryptionOption as src ->
        BackupOption.BackupEncryptionOption((src.Algorithm),(src.Encryptor |> Option.ofObj |> Option.map (fun x -> CryptoMechanism.FromCs(x, fragmentMapping))),(src.OptionKind),(src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | _ -> (* :? ScriptDom.BackupOption as src *)
        BackupOption.Base(((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] BooleanExpression = (* IsAbstract = true *)
  | BooleanBinaryExpression of BinaryExpressionType:ScriptDom.BooleanBinaryExpressionType * FirstExpression:BooleanExpression option * SecondExpression:BooleanExpression option
  | BooleanComparisonExpression of ComparisonType:ScriptDom.BooleanComparisonType * FirstExpression:ScalarExpression option * SecondExpression:ScalarExpression option
  | BooleanExpressionSnippet of Script:String option
  | BooleanIsNullExpression of Expression:ScalarExpression option * IsNot:bool
  | BooleanNotExpression of Expression:BooleanExpression option
  | BooleanParenthesisExpression of Expression:BooleanExpression option
  | BooleanTernaryExpression of FirstExpression:ScalarExpression option * SecondExpression:ScalarExpression option * TernaryExpressionType:ScriptDom.BooleanTernaryExpressionType * ThirdExpression:ScalarExpression option
  | EventDeclarationCompareFunctionParameter of EventValue:ScalarExpression option * Name:EventSessionObjectName option * SourceDeclaration:SourceDeclaration option
  | ExistsPredicate of Subquery:ScalarSubquery option
  | FullTextPredicate of Columns:(ColumnReferenceExpression) list * FullTextFunctionType:ScriptDom.FullTextFunctionType * LanguageTerm:ValueExpression option * PropertyName:StringLiteral option * Value:ValueExpression option
  | GraphMatchCompositeExpression of ArrowOnRight:bool * Edge:Identifier option * LeftNode:GraphMatchNodeExpression option * RightNode:GraphMatchNodeExpression option
  | GraphMatchExpression of ArrowOnRight:bool * Edge:Identifier option * LeftNode:Identifier option * RightNode:Identifier option
  | GraphMatchLastNodePredicate of LeftExpression:GraphMatchNodeExpression option * RightExpression:GraphMatchNodeExpression option
  | GraphMatchNodeExpression of Node:Identifier option * UsesLastNode:bool
  | GraphMatchPredicate of Expression:BooleanExpression option
  | GraphMatchRecursivePredicate of AnchorOnLeft:bool * Expression:(BooleanExpression) list * Function:ScriptDom.GraphMatchRecursivePredicateKind * OuterNodeExpression:GraphMatchNodeExpression option * RecursiveQuantifier:GraphRecursiveMatchQuantifier option
  | GraphRecursiveMatchQuantifier of IsPlusSign:bool * LowerLimit:Literal option * UpperLimit:Literal option
  | InPredicate of Expression:ScalarExpression option * NotDefined:bool * Subquery:ScalarSubquery option * Values:(ScalarExpression) list
  | LikePredicate of EscapeExpression:ScalarExpression option * FirstExpression:ScalarExpression option * NotDefined:bool * OdbcEscape:bool * SecondExpression:ScalarExpression option
  | SubqueryComparisonPredicate of ComparisonType:ScriptDom.BooleanComparisonType * Expression:ScalarExpression option * Subquery:ScalarSubquery option * SubqueryComparisonPredicateType:ScriptDom.SubqueryComparisonPredicateType
  | TSEqualCall of FirstExpression:ScalarExpression option * SecondExpression:ScalarExpression option
  | UpdateCall of Identifier:Identifier option
  member this.ToCs() : ScriptDom.BooleanExpression =
    match this with
    | BooleanBinaryExpression(BinaryExpressionType=aBinaryExpressionType; FirstExpression=aFirstExpression; SecondExpression=aSecondExpression) ->
      let ret = ScriptDom.BooleanBinaryExpression()
      ret.BinaryExpressionType <- aBinaryExpressionType
      ret.FirstExpression <- aFirstExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SecondExpression <- aSecondExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BooleanExpression (* 335 *)
    | BooleanComparisonExpression(ComparisonType=aComparisonType; FirstExpression=aFirstExpression; SecondExpression=aSecondExpression) ->
      let ret = ScriptDom.BooleanComparisonExpression()
      ret.ComparisonType <- aComparisonType
      ret.FirstExpression <- aFirstExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SecondExpression <- aSecondExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BooleanExpression (* 335 *)
    | BooleanExpressionSnippet(Script=aScript) ->
      let ret = ScriptDom.BooleanExpressionSnippet()
      ret.Script <- aScript |> Option.toObj
      ret :> ScriptDom.BooleanExpression (* 335 *)
    | BooleanIsNullExpression(Expression=aExpression; IsNot=aIsNot) ->
      let ret = ScriptDom.BooleanIsNullExpression()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsNot <- aIsNot
      ret :> ScriptDom.BooleanExpression (* 335 *)
    | BooleanNotExpression(Expression=aExpression) ->
      let ret = ScriptDom.BooleanNotExpression()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BooleanExpression (* 335 *)
    | BooleanParenthesisExpression(Expression=aExpression) ->
      let ret = ScriptDom.BooleanParenthesisExpression()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BooleanExpression (* 335 *)
    | BooleanTernaryExpression(FirstExpression=aFirstExpression; SecondExpression=aSecondExpression; TernaryExpressionType=aTernaryExpressionType; ThirdExpression=aThirdExpression) ->
      let ret = ScriptDom.BooleanTernaryExpression()
      ret.FirstExpression <- aFirstExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SecondExpression <- aSecondExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TernaryExpressionType <- aTernaryExpressionType
      ret.ThirdExpression <- aThirdExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BooleanExpression (* 335 *)
    | EventDeclarationCompareFunctionParameter(EventValue=aEventValue; Name=aName; SourceDeclaration=aSourceDeclaration) ->
      let ret = ScriptDom.EventDeclarationCompareFunctionParameter()
      ret.EventValue <- aEventValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SourceDeclaration <- aSourceDeclaration |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BooleanExpression (* 335 *)
    | ExistsPredicate(Subquery=aSubquery) ->
      let ret = ScriptDom.ExistsPredicate()
      ret.Subquery <- aSubquery |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BooleanExpression (* 335 *)
    | FullTextPredicate(Columns=aColumns; FullTextFunctionType=aFullTextFunctionType; LanguageTerm=aLanguageTerm; PropertyName=aPropertyName; Value=aValue) ->
      let ret = ScriptDom.FullTextPredicate()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.FullTextFunctionType <- aFullTextFunctionType
      ret.LanguageTerm <- aLanguageTerm |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PropertyName <- aPropertyName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BooleanExpression (* 335 *)
    | GraphMatchCompositeExpression(ArrowOnRight=aArrowOnRight; Edge=aEdge; LeftNode=aLeftNode; RightNode=aRightNode) ->
      let ret = ScriptDom.GraphMatchCompositeExpression()
      ret.ArrowOnRight <- aArrowOnRight
      ret.Edge <- aEdge |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.LeftNode <- aLeftNode |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.RightNode <- aRightNode |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BooleanExpression (* 335 *)
    | GraphMatchExpression(ArrowOnRight=aArrowOnRight; Edge=aEdge; LeftNode=aLeftNode; RightNode=aRightNode) ->
      let ret = ScriptDom.GraphMatchExpression()
      ret.ArrowOnRight <- aArrowOnRight
      ret.Edge <- aEdge |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.LeftNode <- aLeftNode |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.RightNode <- aRightNode |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BooleanExpression (* 335 *)
    | GraphMatchLastNodePredicate(LeftExpression=aLeftExpression; RightExpression=aRightExpression) ->
      let ret = ScriptDom.GraphMatchLastNodePredicate()
      ret.LeftExpression <- aLeftExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.RightExpression <- aRightExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BooleanExpression (* 335 *)
    | GraphMatchNodeExpression(Node=aNode; UsesLastNode=aUsesLastNode) ->
      let ret = ScriptDom.GraphMatchNodeExpression()
      ret.Node <- aNode |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UsesLastNode <- aUsesLastNode
      ret :> ScriptDom.BooleanExpression (* 335 *)
    | GraphMatchPredicate(Expression=aExpression) ->
      let ret = ScriptDom.GraphMatchPredicate()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BooleanExpression (* 335 *)
    | GraphMatchRecursivePredicate(AnchorOnLeft=aAnchorOnLeft; Expression=aExpression; Function=aFunction; OuterNodeExpression=aOuterNodeExpression; RecursiveQuantifier=aRecursiveQuantifier) ->
      let ret = ScriptDom.GraphMatchRecursivePredicate()
      ret.AnchorOnLeft <- aAnchorOnLeft
      for e in aExpression do ret.Expression.Add (e.ToCs())
      ret.Function <- aFunction
      ret.OuterNodeExpression <- aOuterNodeExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.RecursiveQuantifier <- aRecursiveQuantifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BooleanExpression (* 335 *)
    | GraphRecursiveMatchQuantifier(IsPlusSign=aIsPlusSign; LowerLimit=aLowerLimit; UpperLimit=aUpperLimit) ->
      let ret = ScriptDom.GraphRecursiveMatchQuantifier()
      ret.IsPlusSign <- aIsPlusSign
      ret.LowerLimit <- aLowerLimit |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UpperLimit <- aUpperLimit |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BooleanExpression (* 335 *)
    | InPredicate(Expression=aExpression; NotDefined=aNotDefined; Subquery=aSubquery; Values=aValues) ->
      let ret = ScriptDom.InPredicate()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.NotDefined <- aNotDefined
      ret.Subquery <- aSubquery |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aValues do ret.Values.Add (e.ToCs())
      ret :> ScriptDom.BooleanExpression (* 335 *)
    | LikePredicate(EscapeExpression=aEscapeExpression; FirstExpression=aFirstExpression; NotDefined=aNotDefined; OdbcEscape=aOdbcEscape; SecondExpression=aSecondExpression) ->
      let ret = ScriptDom.LikePredicate()
      ret.EscapeExpression <- aEscapeExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FirstExpression <- aFirstExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.NotDefined <- aNotDefined
      ret.OdbcEscape <- aOdbcEscape
      ret.SecondExpression <- aSecondExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BooleanExpression (* 335 *)
    | SubqueryComparisonPredicate(ComparisonType=aComparisonType; Expression=aExpression; Subquery=aSubquery; SubqueryComparisonPredicateType=aSubqueryComparisonPredicateType) ->
      let ret = ScriptDom.SubqueryComparisonPredicate()
      ret.ComparisonType <- aComparisonType
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Subquery <- aSubquery |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SubqueryComparisonPredicateType <- aSubqueryComparisonPredicateType
      ret :> ScriptDom.BooleanExpression (* 335 *)
    | TSEqualCall(FirstExpression=aFirstExpression; SecondExpression=aSecondExpression) ->
      let ret = ScriptDom.TSEqualCall()
      ret.FirstExpression <- aFirstExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SecondExpression <- aSecondExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BooleanExpression (* 335 *)
    | UpdateCall(Identifier=aIdentifier) ->
      let ret = ScriptDom.UpdateCall()
      ret.Identifier <- aIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BooleanExpression (* 335 *)
  static member FromCs(src:ScriptDom.BooleanExpression, fragmentMapping:FragmentMapping) : BooleanExpression =
    let ret =
      match src with
      | :? ScriptDom.BooleanBinaryExpression as src ->
        BooleanExpression.BooleanBinaryExpression((src.BinaryExpressionType),(src.FirstExpression |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))),(src.SecondExpression |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.BooleanComparisonExpression as src ->
        BooleanExpression.BooleanComparisonExpression((src.ComparisonType),(src.FirstExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.SecondExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.BooleanExpressionSnippet as src ->
        BooleanExpression.BooleanExpressionSnippet((Option.ofObj (src.Script)))
      | :? ScriptDom.BooleanIsNullExpression as src ->
        BooleanExpression.BooleanIsNullExpression((src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.IsNot))
      | :? ScriptDom.BooleanNotExpression as src ->
        BooleanExpression.BooleanNotExpression((src.Expression |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.BooleanParenthesisExpression as src ->
        BooleanExpression.BooleanParenthesisExpression((src.Expression |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.BooleanTernaryExpression as src ->
        BooleanExpression.BooleanTernaryExpression((src.FirstExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.SecondExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.TernaryExpressionType),(src.ThirdExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.EventDeclarationCompareFunctionParameter as src ->
        BooleanExpression.EventDeclarationCompareFunctionParameter((src.EventValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> EventSessionObjectName.FromCs(x, fragmentMapping))),(src.SourceDeclaration |> Option.ofObj |> Option.map (fun x -> SourceDeclaration.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ExistsPredicate as src ->
        BooleanExpression.ExistsPredicate((src.Subquery |> Option.ofObj |> Option.map (fun x -> ScalarSubquery.FromCs(x, fragmentMapping))))
      | :? ScriptDom.FullTextPredicate as src ->
        BooleanExpression.FullTextPredicate((src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.FullTextFunctionType),(src.LanguageTerm |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))),(src.PropertyName |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))),(src.Value |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.GraphMatchCompositeExpression as src ->
        BooleanExpression.GraphMatchCompositeExpression((src.ArrowOnRight),(src.Edge |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.LeftNode |> Option.ofObj |> Option.map (fun x -> GraphMatchNodeExpression.FromCs(x, fragmentMapping))),(src.RightNode |> Option.ofObj |> Option.map (fun x -> GraphMatchNodeExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.GraphMatchExpression as src ->
        BooleanExpression.GraphMatchExpression((src.ArrowOnRight),(src.Edge |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.LeftNode |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.RightNode |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.GraphMatchLastNodePredicate as src ->
        BooleanExpression.GraphMatchLastNodePredicate((src.LeftExpression |> Option.ofObj |> Option.map (fun x -> GraphMatchNodeExpression.FromCs(x, fragmentMapping))),(src.RightExpression |> Option.ofObj |> Option.map (fun x -> GraphMatchNodeExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.GraphMatchNodeExpression as src ->
        BooleanExpression.GraphMatchNodeExpression((src.Node |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.UsesLastNode))
      | :? ScriptDom.GraphMatchPredicate as src ->
        BooleanExpression.GraphMatchPredicate((src.Expression |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.GraphMatchRecursivePredicate as src ->
        BooleanExpression.GraphMatchRecursivePredicate((src.AnchorOnLeft),(src.Expression |> Seq.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Function),(src.OuterNodeExpression |> Option.ofObj |> Option.map (fun x -> GraphMatchNodeExpression.FromCs(x, fragmentMapping))),(src.RecursiveQuantifier |> Option.ofObj |> Option.map (fun x -> GraphRecursiveMatchQuantifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.GraphRecursiveMatchQuantifier as src ->
        BooleanExpression.GraphRecursiveMatchQuantifier((src.IsPlusSign),(src.LowerLimit |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.UpperLimit |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.InPredicate as src ->
        BooleanExpression.InPredicate((src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.NotDefined),(src.Subquery |> Option.ofObj |> Option.map (fun x -> ScalarSubquery.FromCs(x, fragmentMapping))),(src.Values |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.LikePredicate as src ->
        BooleanExpression.LikePredicate((src.EscapeExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.FirstExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.NotDefined),(src.OdbcEscape),(src.SecondExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.SubqueryComparisonPredicate as src ->
        BooleanExpression.SubqueryComparisonPredicate((src.ComparisonType),(src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.Subquery |> Option.ofObj |> Option.map (fun x -> ScalarSubquery.FromCs(x, fragmentMapping))),(src.SubqueryComparisonPredicateType))
      | :? ScriptDom.TSEqualCall as src ->
        BooleanExpression.TSEqualCall((src.FirstExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.SecondExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.UpdateCall as src ->
        BooleanExpression.UpdateCall((src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] BulkInsertOption = (* IsAbstract = false *)
  | Base of OptionKind:ScriptDom.BulkInsertOptionKind
  | LiteralBulkInsertOption of OptionKind:ScriptDom.BulkInsertOptionKind * Value:Literal option
  | OrderBulkInsertOption of Columns:(ColumnWithSortOrder) list * IsUnique:bool * OptionKind:ScriptDom.BulkInsertOptionKind
  member this.ToCs() : ScriptDom.BulkInsertOption =
    match this with
    | LiteralBulkInsertOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.LiteralBulkInsertOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BulkInsertOption (* 335 *)
    | OrderBulkInsertOption(Columns=aColumns; IsUnique=aIsUnique; OptionKind=aOptionKind) ->
      let ret = ScriptDom.OrderBulkInsertOption()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.IsUnique <- aIsUnique
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.BulkInsertOption (* 335 *)
    | Base(OptionKind=aOptionKind) ->

      let ret = ScriptDom.BulkInsertOption()
      ret.OptionKind <- aOptionKind
      ret
  static member FromCs(src:ScriptDom.BulkInsertOption, fragmentMapping:FragmentMapping) : BulkInsertOption =
    let ret =
      match src with
      | :? ScriptDom.LiteralBulkInsertOption as src ->
        BulkInsertOption.LiteralBulkInsertOption((src.OptionKind),(src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.OrderBulkInsertOption as src ->
        BulkInsertOption.OrderBulkInsertOption((src.Columns |> Seq.map (fun src -> ColumnWithSortOrder.ColumnWithSortOrder((src.Column |> Option.ofObj |> Option.map (fun x -> ColumnReferenceExpression.FromCs(x, fragmentMapping))), (src.SortOrder))) |> List.ofSeq),(src.IsUnique),(src.OptionKind))
      | _ -> (* :? ScriptDom.BulkInsertOption as src *)
        BulkInsertOption.Base(((src.OptionKind))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] CallTarget = (* IsAbstract = true *)
  | ExpressionCallTarget of Expression:ScalarExpression option
  | MultiPartIdentifierCallTarget of MultiPartIdentifier:MultiPartIdentifier option
  | UserDefinedTypeCallTarget of SchemaObjectName:SchemaObjectName option
  member this.ToCs() : ScriptDom.CallTarget =
    match this with
    | ExpressionCallTarget(Expression=aExpression) ->
      let ret = ScriptDom.ExpressionCallTarget()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CallTarget (* 335 *)
    | MultiPartIdentifierCallTarget(MultiPartIdentifier=aMultiPartIdentifier) ->
      let ret = ScriptDom.MultiPartIdentifierCallTarget()
      ret.MultiPartIdentifier <- aMultiPartIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CallTarget (* 335 *)
    | UserDefinedTypeCallTarget(SchemaObjectName=aSchemaObjectName) ->
      let ret = ScriptDom.UserDefinedTypeCallTarget()
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CallTarget (* 335 *)
  static member FromCs(src:ScriptDom.CallTarget, fragmentMapping:FragmentMapping) : CallTarget =
    let ret =
      match src with
      | :? ScriptDom.ExpressionCallTarget as src ->
        CallTarget.ExpressionCallTarget((src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.MultiPartIdentifierCallTarget as src ->
        CallTarget.MultiPartIdentifierCallTarget((src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.UserDefinedTypeCallTarget as src ->
        CallTarget.UserDefinedTypeCallTarget((src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ChangeTrackingOptionDetail = (* IsAbstract = true *)
  | AutoCleanupChangeTrackingOptionDetail of IsOn:bool
  | ChangeRetentionChangeTrackingOptionDetail of RetentionPeriod:Literal option * Unit:ScriptDom.TimeUnit
  member this.ToCs() : ScriptDom.ChangeTrackingOptionDetail =
    match this with
    | AutoCleanupChangeTrackingOptionDetail(IsOn=aIsOn) ->
      let ret = ScriptDom.AutoCleanupChangeTrackingOptionDetail()
      ret.IsOn <- aIsOn
      ret :> ScriptDom.ChangeTrackingOptionDetail (* 335 *)
    | ChangeRetentionChangeTrackingOptionDetail(RetentionPeriod=aRetentionPeriod; Unit=aUnit) ->
      let ret = ScriptDom.ChangeRetentionChangeTrackingOptionDetail()
      ret.RetentionPeriod <- aRetentionPeriod |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Unit <- aUnit
      ret :> ScriptDom.ChangeTrackingOptionDetail (* 335 *)
  static member FromCs(src:ScriptDom.ChangeTrackingOptionDetail, fragmentMapping:FragmentMapping) : ChangeTrackingOptionDetail =
    let ret =
      match src with
      | :? ScriptDom.AutoCleanupChangeTrackingOptionDetail as src ->
        ChangeTrackingOptionDetail.AutoCleanupChangeTrackingOptionDetail((src.IsOn))
      | :? ScriptDom.ChangeRetentionChangeTrackingOptionDetail as src ->
        ChangeTrackingOptionDetail.ChangeRetentionChangeTrackingOptionDetail((src.RetentionPeriod |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.Unit))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ColumnDefinitionBase = (* IsAbstract = false *)
  | Base of Collation:Identifier option * ColumnIdentifier:Identifier option * DataType:DataTypeReference option
  | ColumnDefinition of Collation:Identifier option * ColumnIdentifier:Identifier option * ComputedColumnExpression:ScalarExpression option * Constraints:(ConstraintDefinition) list * DataType:DataTypeReference option * DefaultConstraint:DefaultConstraintDefinition option * Encryption:ColumnEncryptionDefinition option * GeneratedAlways:(ScriptDom.GeneratedAlwaysType) option * IdentityOptions:IdentityOptions option * Index:IndexDefinition option * IsHidden:bool * IsMasked:bool * IsPersisted:bool * IsRowGuidCol:bool * MaskingFunction:StringLiteral option * StorageOptions:ColumnStorageOptions option
  member this.ToCs() : ScriptDom.ColumnDefinitionBase =
    match this with
    | ColumnDefinition(Collation=aCollation; ColumnIdentifier=aColumnIdentifier; ComputedColumnExpression=aComputedColumnExpression; Constraints=aConstraints; DataType=aDataType; DefaultConstraint=aDefaultConstraint; Encryption=aEncryption; GeneratedAlways=aGeneratedAlways; IdentityOptions=aIdentityOptions; Index=aIndex; IsHidden=aIsHidden; IsMasked=aIsMasked; IsPersisted=aIsPersisted; IsRowGuidCol=aIsRowGuidCol; MaskingFunction=aMaskingFunction; StorageOptions=aStorageOptions) ->
      let ret = ScriptDom.ColumnDefinition()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ColumnIdentifier <- aColumnIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ComputedColumnExpression <- aComputedColumnExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aConstraints do ret.Constraints.Add (e.ToCs())
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DefaultConstraint <- aDefaultConstraint |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Encryption <- aEncryption |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.GeneratedAlways <- Option.toNullable aGeneratedAlways
      ret.IdentityOptions <- aIdentityOptions |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Index <- aIndex |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsHidden <- aIsHidden
      ret.IsMasked <- aIsMasked
      ret.IsPersisted <- aIsPersisted
      ret.IsRowGuidCol <- aIsRowGuidCol
      ret.MaskingFunction <- aMaskingFunction |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StorageOptions <- aStorageOptions |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ColumnDefinitionBase (* 335 *)
    | Base(Collation=aCollation; ColumnIdentifier=aColumnIdentifier; DataType=aDataType) ->

      let ret = ScriptDom.ColumnDefinitionBase()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ColumnIdentifier <- aColumnIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret
  static member FromCs(src:ScriptDom.ColumnDefinitionBase, fragmentMapping:FragmentMapping) : ColumnDefinitionBase =
    let ret =
      match src with
      | :? ScriptDom.ColumnDefinition as src ->
        ColumnDefinitionBase.ColumnDefinition((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.ColumnIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.ComputedColumnExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.Constraints |> Seq.map (fun x -> ConstraintDefinition.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))),(src.DefaultConstraint |> Option.ofObj |> Option.map (fun x -> DefaultConstraintDefinition.FromCs(x, fragmentMapping))),(src.Encryption |> Option.ofObj |> Option.map (fun x -> ColumnEncryptionDefinition.FromCs(x, fragmentMapping))),(Option.ofNullable (src.GeneratedAlways)),(src.IdentityOptions |> Option.ofObj |> Option.map (fun x -> IdentityOptions.FromCs(x, fragmentMapping))),(src.Index |> Option.ofObj |> Option.map (fun x -> IndexDefinition.FromCs(x, fragmentMapping))),(src.IsHidden),(src.IsMasked),(src.IsPersisted),(src.IsRowGuidCol),(src.MaskingFunction |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))),(src.StorageOptions |> Option.ofObj |> Option.map (fun x -> ColumnStorageOptions.FromCs(x, fragmentMapping))))
      | _ -> (* :? ScriptDom.ColumnDefinitionBase as src *)
        ColumnDefinitionBase.Base(((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ColumnEncryptionDefinitionParameter = (* IsAbstract = true *)
  | ColumnEncryptionAlgorithmParameter of EncryptionAlgorithm:StringLiteral option * ParameterKind:ScriptDom.ColumnEncryptionDefinitionParameterKind
  | ColumnEncryptionKeyNameParameter of Name:Identifier option * ParameterKind:ScriptDom.ColumnEncryptionDefinitionParameterKind
  | ColumnEncryptionTypeParameter of EncryptionType:ScriptDom.ColumnEncryptionType * ParameterKind:ScriptDom.ColumnEncryptionDefinitionParameterKind
  member this.ToCs() : ScriptDom.ColumnEncryptionDefinitionParameter =
    match this with
    | ColumnEncryptionAlgorithmParameter(EncryptionAlgorithm=aEncryptionAlgorithm; ParameterKind=aParameterKind) ->
      let ret = ScriptDom.ColumnEncryptionAlgorithmParameter()
      ret.EncryptionAlgorithm <- aEncryptionAlgorithm |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ParameterKind <- aParameterKind
      ret :> ScriptDom.ColumnEncryptionDefinitionParameter (* 335 *)
    | ColumnEncryptionKeyNameParameter(Name=aName; ParameterKind=aParameterKind) ->
      let ret = ScriptDom.ColumnEncryptionKeyNameParameter()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ParameterKind <- aParameterKind
      ret :> ScriptDom.ColumnEncryptionDefinitionParameter (* 335 *)
    | ColumnEncryptionTypeParameter(EncryptionType=aEncryptionType; ParameterKind=aParameterKind) ->
      let ret = ScriptDom.ColumnEncryptionTypeParameter()
      ret.EncryptionType <- aEncryptionType
      ret.ParameterKind <- aParameterKind
      ret :> ScriptDom.ColumnEncryptionDefinitionParameter (* 335 *)
  static member FromCs(src:ScriptDom.ColumnEncryptionDefinitionParameter, fragmentMapping:FragmentMapping) : ColumnEncryptionDefinitionParameter =
    let ret =
      match src with
      | :? ScriptDom.ColumnEncryptionAlgorithmParameter as src ->
        ColumnEncryptionDefinitionParameter.ColumnEncryptionAlgorithmParameter((src.EncryptionAlgorithm |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))),(src.ParameterKind))
      | :? ScriptDom.ColumnEncryptionKeyNameParameter as src ->
        ColumnEncryptionDefinitionParameter.ColumnEncryptionKeyNameParameter((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.ParameterKind))
      | :? ScriptDom.ColumnEncryptionTypeParameter as src ->
        ColumnEncryptionDefinitionParameter.ColumnEncryptionTypeParameter((src.EncryptionType),(src.ParameterKind))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ColumnEncryptionKeyValueParameter = (* IsAbstract = true *)
  | ColumnEncryptionAlgorithmNameParameter of Algorithm:StringLiteral option * ParameterKind:ScriptDom.ColumnEncryptionKeyValueParameterKind
  | ColumnMasterKeyNameParameter of Name:Identifier option * ParameterKind:ScriptDom.ColumnEncryptionKeyValueParameterKind
  | EncryptedValueParameter of ParameterKind:ScriptDom.ColumnEncryptionKeyValueParameterKind * Value:BinaryLiteral option
  member this.ToCs() : ScriptDom.ColumnEncryptionKeyValueParameter =
    match this with
    | ColumnEncryptionAlgorithmNameParameter(Algorithm=aAlgorithm; ParameterKind=aParameterKind) ->
      let ret = ScriptDom.ColumnEncryptionAlgorithmNameParameter()
      ret.Algorithm <- aAlgorithm |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ParameterKind <- aParameterKind
      ret :> ScriptDom.ColumnEncryptionKeyValueParameter (* 335 *)
    | ColumnMasterKeyNameParameter(Name=aName; ParameterKind=aParameterKind) ->
      let ret = ScriptDom.ColumnMasterKeyNameParameter()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ParameterKind <- aParameterKind
      ret :> ScriptDom.ColumnEncryptionKeyValueParameter (* 335 *)
    | EncryptedValueParameter(ParameterKind=aParameterKind; Value=aValue) ->
      let ret = ScriptDom.EncryptedValueParameter()
      ret.ParameterKind <- aParameterKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ColumnEncryptionKeyValueParameter (* 335 *)
  static member FromCs(src:ScriptDom.ColumnEncryptionKeyValueParameter, fragmentMapping:FragmentMapping) : ColumnEncryptionKeyValueParameter =
    let ret =
      match src with
      | :? ScriptDom.ColumnEncryptionAlgorithmNameParameter as src ->
        ColumnEncryptionKeyValueParameter.ColumnEncryptionAlgorithmNameParameter((src.Algorithm |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))),(src.ParameterKind))
      | :? ScriptDom.ColumnMasterKeyNameParameter as src ->
        ColumnEncryptionKeyValueParameter.ColumnMasterKeyNameParameter((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.ParameterKind))
      | :? ScriptDom.EncryptedValueParameter as src ->
        ColumnEncryptionKeyValueParameter.EncryptedValueParameter((src.ParameterKind),(src.Value |> Option.ofObj |> Option.map (fun x -> BinaryLiteral.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ColumnMasterKeyParameter = (* IsAbstract = true *)
  | ColumnMasterKeyEnclaveComputationsParameter of ParameterKind:ScriptDom.ColumnMasterKeyParameterKind * Signature:BinaryLiteral option
  | ColumnMasterKeyPathParameter of ParameterKind:ScriptDom.ColumnMasterKeyParameterKind * Path:StringLiteral option
  | ColumnMasterKeyStoreProviderNameParameter of Name:StringLiteral option * ParameterKind:ScriptDom.ColumnMasterKeyParameterKind
  member this.ToCs() : ScriptDom.ColumnMasterKeyParameter =
    match this with
    | ColumnMasterKeyEnclaveComputationsParameter(ParameterKind=aParameterKind; Signature=aSignature) ->
      let ret = ScriptDom.ColumnMasterKeyEnclaveComputationsParameter()
      ret.ParameterKind <- aParameterKind
      ret.Signature <- aSignature |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ColumnMasterKeyParameter (* 335 *)
    | ColumnMasterKeyPathParameter(ParameterKind=aParameterKind; Path=aPath) ->
      let ret = ScriptDom.ColumnMasterKeyPathParameter()
      ret.ParameterKind <- aParameterKind
      ret.Path <- aPath |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ColumnMasterKeyParameter (* 335 *)
    | ColumnMasterKeyStoreProviderNameParameter(Name=aName; ParameterKind=aParameterKind) ->
      let ret = ScriptDom.ColumnMasterKeyStoreProviderNameParameter()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ParameterKind <- aParameterKind
      ret :> ScriptDom.ColumnMasterKeyParameter (* 335 *)
  static member FromCs(src:ScriptDom.ColumnMasterKeyParameter, fragmentMapping:FragmentMapping) : ColumnMasterKeyParameter =
    let ret =
      match src with
      | :? ScriptDom.ColumnMasterKeyEnclaveComputationsParameter as src ->
        ColumnMasterKeyParameter.ColumnMasterKeyEnclaveComputationsParameter((src.ParameterKind),(src.Signature |> Option.ofObj |> Option.map (fun x -> BinaryLiteral.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ColumnMasterKeyPathParameter as src ->
        ColumnMasterKeyParameter.ColumnMasterKeyPathParameter((src.ParameterKind),(src.Path |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ColumnMasterKeyStoreProviderNameParameter as src ->
        ColumnMasterKeyParameter.ColumnMasterKeyStoreProviderNameParameter((src.Name |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))),(src.ParameterKind))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ConstraintDefinition = (* IsAbstract = true *)
  | CheckConstraintDefinition of CheckCondition:BooleanExpression option * ConstraintIdentifier:Identifier option * NotForReplication:bool
  | DefaultConstraintDefinition of Column:Identifier option * ConstraintIdentifier:Identifier option * Expression:ScalarExpression option * WithValues:bool
  | ForeignKeyConstraintDefinition of Columns:(Identifier) list * ConstraintIdentifier:Identifier option * DeleteAction:ScriptDom.DeleteUpdateAction * NotForReplication:bool * ReferenceTableName:SchemaObjectName option * ReferencedTableColumns:(Identifier) list * UpdateAction:ScriptDom.DeleteUpdateAction
  | GraphConnectionConstraintDefinition of ConstraintIdentifier:Identifier option * DeleteAction:ScriptDom.DeleteUpdateAction * FromNodeToNodeList:(GraphConnectionBetweenNodes) list
  | NullableConstraintDefinition of ConstraintIdentifier:Identifier option * Nullable:bool
  | UniqueConstraintDefinition of Clustered:(bool) option * Columns:(ColumnWithSortOrder) list * ConstraintIdentifier:Identifier option * FileStreamOn:IdentifierOrValueExpression option * IndexOptions:(IndexOption) list * IndexType:IndexType option * IsEnforced:(bool) option * IsPrimaryKey:bool * OnFileGroupOrPartitionScheme:FileGroupOrPartitionScheme option
  member this.ToCs() : ScriptDom.ConstraintDefinition =
    match this with
    | CheckConstraintDefinition(CheckCondition=aCheckCondition; ConstraintIdentifier=aConstraintIdentifier; NotForReplication=aNotForReplication) ->
      let ret = ScriptDom.CheckConstraintDefinition()
      ret.CheckCondition <- aCheckCondition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ConstraintIdentifier <- aConstraintIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.NotForReplication <- aNotForReplication
      ret :> ScriptDom.ConstraintDefinition (* 335 *)
    | DefaultConstraintDefinition(Column=aColumn; ConstraintIdentifier=aConstraintIdentifier; Expression=aExpression; WithValues=aWithValues) ->
      let ret = ScriptDom.DefaultConstraintDefinition()
      ret.Column <- aColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ConstraintIdentifier <- aConstraintIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WithValues <- aWithValues
      ret :> ScriptDom.ConstraintDefinition (* 335 *)
    | ForeignKeyConstraintDefinition(Columns=aColumns; ConstraintIdentifier=aConstraintIdentifier; DeleteAction=aDeleteAction; NotForReplication=aNotForReplication; ReferenceTableName=aReferenceTableName; ReferencedTableColumns=aReferencedTableColumns; UpdateAction=aUpdateAction) ->
      let ret = ScriptDom.ForeignKeyConstraintDefinition()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.ConstraintIdentifier <- aConstraintIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DeleteAction <- aDeleteAction
      ret.NotForReplication <- aNotForReplication
      ret.ReferenceTableName <- aReferenceTableName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aReferencedTableColumns do ret.ReferencedTableColumns.Add (e.ToCs())
      ret.UpdateAction <- aUpdateAction
      ret :> ScriptDom.ConstraintDefinition (* 335 *)
    | GraphConnectionConstraintDefinition(ConstraintIdentifier=aConstraintIdentifier; DeleteAction=aDeleteAction; FromNodeToNodeList=aFromNodeToNodeList) ->
      let ret = ScriptDom.GraphConnectionConstraintDefinition()
      ret.ConstraintIdentifier <- aConstraintIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DeleteAction <- aDeleteAction
      for e in aFromNodeToNodeList do ret.FromNodeToNodeList.Add (e.ToCs())
      ret :> ScriptDom.ConstraintDefinition (* 335 *)
    | NullableConstraintDefinition(ConstraintIdentifier=aConstraintIdentifier; Nullable=aNullable) ->
      let ret = ScriptDom.NullableConstraintDefinition()
      ret.ConstraintIdentifier <- aConstraintIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Nullable <- aNullable
      ret :> ScriptDom.ConstraintDefinition (* 335 *)
    | UniqueConstraintDefinition(Clustered=aClustered; Columns=aColumns; ConstraintIdentifier=aConstraintIdentifier; FileStreamOn=aFileStreamOn; IndexOptions=aIndexOptions; IndexType=aIndexType; IsEnforced=aIsEnforced; IsPrimaryKey=aIsPrimaryKey; OnFileGroupOrPartitionScheme=aOnFileGroupOrPartitionScheme) ->
      let ret = ScriptDom.UniqueConstraintDefinition()
      ret.Clustered <- Option.toNullable aClustered
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.ConstraintIdentifier <- aConstraintIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FileStreamOn <- aFileStreamOn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aIndexOptions do ret.IndexOptions.Add (e.ToCs())
      ret.IndexType <- aIndexType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsEnforced <- Option.toNullable aIsEnforced
      ret.IsPrimaryKey <- aIsPrimaryKey
      ret.OnFileGroupOrPartitionScheme <- aOnFileGroupOrPartitionScheme |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ConstraintDefinition (* 335 *)
  static member FromCs(src:ScriptDom.ConstraintDefinition, fragmentMapping:FragmentMapping) : ConstraintDefinition =
    let ret =
      match src with
      | :? ScriptDom.CheckConstraintDefinition as src ->
        ConstraintDefinition.CheckConstraintDefinition((src.CheckCondition |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))),(src.ConstraintIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.NotForReplication))
      | :? ScriptDom.DefaultConstraintDefinition as src ->
        ConstraintDefinition.DefaultConstraintDefinition((src.Column |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.ConstraintIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.WithValues))
      | :? ScriptDom.ForeignKeyConstraintDefinition as src ->
        ConstraintDefinition.ForeignKeyConstraintDefinition((src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.ConstraintIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.DeleteAction),(src.NotForReplication),(src.ReferenceTableName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.ReferencedTableColumns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.UpdateAction))
      | :? ScriptDom.GraphConnectionConstraintDefinition as src ->
        ConstraintDefinition.GraphConnectionConstraintDefinition((src.ConstraintIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.DeleteAction),(src.FromNodeToNodeList |> Seq.map (fun src -> GraphConnectionBetweenNodes.GraphConnectionBetweenNodes((src.FromNode |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.ToNode |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))) |> List.ofSeq))
      | :? ScriptDom.NullableConstraintDefinition as src ->
        ConstraintDefinition.NullableConstraintDefinition((src.ConstraintIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Nullable))
      | :? ScriptDom.UniqueConstraintDefinition as src ->
        ConstraintDefinition.UniqueConstraintDefinition((Option.ofNullable (src.Clustered)),(src.Columns |> Seq.map (fun src -> ColumnWithSortOrder.ColumnWithSortOrder((src.Column |> Option.ofObj |> Option.map (fun x -> ColumnReferenceExpression.FromCs(x, fragmentMapping))), (src.SortOrder))) |> List.ofSeq),(src.ConstraintIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.FileStreamOn |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))),(src.IndexOptions |> Seq.map (fun x -> IndexOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.IndexType |> Option.ofObj |> Option.map (fun x -> IndexType.FromCs(x, fragmentMapping))),(Option.ofNullable (src.IsEnforced)),(src.IsPrimaryKey),(src.OnFileGroupOrPartitionScheme |> Option.ofObj |> Option.map (fun x -> FileGroupOrPartitionScheme.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] CopyStatementOptionBase = (* IsAbstract = true *)
  | CopyColumnOption of ColumnName:Identifier option * DefaultValue:ScalarExpression option * FieldNumber:IntegerLiteral option
  | CopyCredentialOption of Identity:StringLiteral option * Secret:StringLiteral option
  | ListTypeCopyOption of Options:(CopyStatementOptionBase) list
  | SingleValueTypeCopyOption of SingleValue:IdentifierOrValueExpression option
  member this.ToCs() : ScriptDom.CopyStatementOptionBase =
    match this with
    | CopyColumnOption(ColumnName=aColumnName; DefaultValue=aDefaultValue; FieldNumber=aFieldNumber) ->
      let ret = ScriptDom.CopyColumnOption()
      ret.ColumnName <- aColumnName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DefaultValue <- aDefaultValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FieldNumber <- aFieldNumber |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CopyStatementOptionBase (* 335 *)
    | CopyCredentialOption(Identity=aIdentity; Secret=aSecret) ->
      let ret = ScriptDom.CopyCredentialOption()
      ret.Identity <- aIdentity |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Secret <- aSecret |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CopyStatementOptionBase (* 335 *)
    | ListTypeCopyOption(Options=aOptions) ->
      let ret = ScriptDom.ListTypeCopyOption()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.CopyStatementOptionBase (* 335 *)
    | SingleValueTypeCopyOption(SingleValue=aSingleValue) ->
      let ret = ScriptDom.SingleValueTypeCopyOption()
      ret.SingleValue <- aSingleValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CopyStatementOptionBase (* 335 *)
  static member FromCs(src:ScriptDom.CopyStatementOptionBase, fragmentMapping:FragmentMapping) : CopyStatementOptionBase =
    let ret =
      match src with
      | :? ScriptDom.CopyColumnOption as src ->
        CopyStatementOptionBase.CopyColumnOption((src.ColumnName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.DefaultValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.FieldNumber |> Option.ofObj |> Option.map (fun x -> IntegerLiteral.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CopyCredentialOption as src ->
        CopyStatementOptionBase.CopyCredentialOption((src.Identity |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))),(src.Secret |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ListTypeCopyOption as src ->
        CopyStatementOptionBase.ListTypeCopyOption((src.Options |> Seq.map (fun x -> CopyStatementOptionBase.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.SingleValueTypeCopyOption as src ->
        CopyStatementOptionBase.SingleValueTypeCopyOption((src.SingleValue |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] CreateLoginSource = (* IsAbstract = true *)
  | AsymmetricKeyCreateLoginSource of Credential:Identifier option * Key:Identifier option
  | CertificateCreateLoginSource of Certificate:Identifier option * Credential:Identifier option
  | ExternalCreateLoginSource of Options:(PrincipalOption) list
  | PasswordCreateLoginSource of Hashed:bool * MustChange:bool * Options:(PrincipalOption) list * Password:Literal option
  | WindowsCreateLoginSource of Options:(PrincipalOption) list
  member this.ToCs() : ScriptDom.CreateLoginSource =
    match this with
    | AsymmetricKeyCreateLoginSource(Credential=aCredential; Key=aKey) ->
      let ret = ScriptDom.AsymmetricKeyCreateLoginSource()
      ret.Credential <- aCredential |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Key <- aKey |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CreateLoginSource (* 335 *)
    | CertificateCreateLoginSource(Certificate=aCertificate; Credential=aCredential) ->
      let ret = ScriptDom.CertificateCreateLoginSource()
      ret.Certificate <- aCertificate |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Credential <- aCredential |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CreateLoginSource (* 335 *)
    | ExternalCreateLoginSource(Options=aOptions) ->
      let ret = ScriptDom.ExternalCreateLoginSource()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.CreateLoginSource (* 335 *)
    | PasswordCreateLoginSource(Hashed=aHashed; MustChange=aMustChange; Options=aOptions; Password=aPassword) ->
      let ret = ScriptDom.PasswordCreateLoginSource()
      ret.Hashed <- aHashed
      ret.MustChange <- aMustChange
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.Password <- aPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CreateLoginSource (* 335 *)
    | WindowsCreateLoginSource(Options=aOptions) ->
      let ret = ScriptDom.WindowsCreateLoginSource()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.CreateLoginSource (* 335 *)
  static member FromCs(src:ScriptDom.CreateLoginSource, fragmentMapping:FragmentMapping) : CreateLoginSource =
    let ret =
      match src with
      | :? ScriptDom.AsymmetricKeyCreateLoginSource as src ->
        CreateLoginSource.AsymmetricKeyCreateLoginSource((src.Credential |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Key |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CertificateCreateLoginSource as src ->
        CreateLoginSource.CertificateCreateLoginSource((src.Certificate |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Credential |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ExternalCreateLoginSource as src ->
        CreateLoginSource.ExternalCreateLoginSource((src.Options |> Seq.map (fun x -> PrincipalOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.PasswordCreateLoginSource as src ->
        CreateLoginSource.PasswordCreateLoginSource((src.Hashed),(src.MustChange),(src.Options |> Seq.map (fun x -> PrincipalOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Password |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.WindowsCreateLoginSource as src ->
        CreateLoginSource.WindowsCreateLoginSource((src.Options |> Seq.map (fun x -> PrincipalOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] DataModificationSpecification = (* IsAbstract = true *)
  | InsertSpecification of Columns:(ColumnReferenceExpression) list * InsertOption:ScriptDom.InsertOption * InsertSource:InsertSource option * OutputClause:OutputClause option * OutputIntoClause:OutputIntoClause option * Target:TableReference option * TopRowFilter:TopRowFilter option
  | MergeSpecification of ActionClauses:(MergeActionClause) list * OutputClause:OutputClause option * OutputIntoClause:OutputIntoClause option * SearchCondition:BooleanExpression option * TableAlias:Identifier option * TableReference:TableReference option * Target:TableReference option * TopRowFilter:TopRowFilter option
  | UpdateDeleteSpecificationBase of UpdateDeleteSpecificationBase
  member this.ToCs() : ScriptDom.DataModificationSpecification =
    match this with
    | InsertSpecification(Columns=aColumns; InsertOption=aInsertOption; InsertSource=aInsertSource; OutputClause=aOutputClause; OutputIntoClause=aOutputIntoClause; Target=aTarget; TopRowFilter=aTopRowFilter) ->
      let ret = ScriptDom.InsertSpecification()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.InsertOption <- aInsertOption
      ret.InsertSource <- aInsertSource |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OutputClause <- aOutputClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OutputIntoClause <- aOutputIntoClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Target <- aTarget |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TopRowFilter <- aTopRowFilter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DataModificationSpecification (* 335 *)
    | MergeSpecification(ActionClauses=aActionClauses; OutputClause=aOutputClause; OutputIntoClause=aOutputIntoClause; SearchCondition=aSearchCondition; TableAlias=aTableAlias; TableReference=aTableReference; Target=aTarget; TopRowFilter=aTopRowFilter) ->
      let ret = ScriptDom.MergeSpecification()
      for e in aActionClauses do ret.ActionClauses.Add (e.ToCs())
      ret.OutputClause <- aOutputClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OutputIntoClause <- aOutputIntoClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SearchCondition <- aSearchCondition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TableAlias <- aTableAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TableReference <- aTableReference |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Target <- aTarget |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TopRowFilter <- aTopRowFilter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DataModificationSpecification (* 335 *)
    | UpdateDeleteSpecificationBase(x) -> x.ToCs() :> ScriptDom.DataModificationSpecification (* 345 *)
  static member FromCs(src:ScriptDom.DataModificationSpecification, fragmentMapping:FragmentMapping) : DataModificationSpecification =
    let ret =
      match src with
      | :? ScriptDom.InsertSpecification as src ->
        DataModificationSpecification.InsertSpecification((src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.InsertOption),(src.InsertSource |> Option.ofObj |> Option.map (fun x -> InsertSource.FromCs(x, fragmentMapping))),(src.OutputClause |> Option.ofObj |> Option.map (fun x -> OutputClause.FromCs(x, fragmentMapping))),(src.OutputIntoClause |> Option.ofObj |> Option.map (fun x -> OutputIntoClause.FromCs(x, fragmentMapping))),(src.Target |> Option.ofObj |> Option.map (fun x -> TableReference.FromCs(x, fragmentMapping))),(src.TopRowFilter |> Option.ofObj |> Option.map (fun x -> TopRowFilter.FromCs(x, fragmentMapping))))
      | :? ScriptDom.MergeSpecification as src ->
        DataModificationSpecification.MergeSpecification((src.ActionClauses |> Seq.map (fun src -> MergeActionClause.MergeActionClause((src.Action |> Option.ofObj |> Option.map (fun x -> MergeAction.FromCs(x, fragmentMapping))), (src.Condition), (src.SearchCondition |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.OutputClause |> Option.ofObj |> Option.map (fun x -> OutputClause.FromCs(x, fragmentMapping))),(src.OutputIntoClause |> Option.ofObj |> Option.map (fun x -> OutputIntoClause.FromCs(x, fragmentMapping))),(src.SearchCondition |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))),(src.TableAlias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.TableReference |> Option.ofObj |> Option.map (fun x -> TableReference.FromCs(x, fragmentMapping))),(src.Target |> Option.ofObj |> Option.map (fun x -> TableReference.FromCs(x, fragmentMapping))),(src.TopRowFilter |> Option.ofObj |> Option.map (fun x -> TopRowFilter.FromCs(x, fragmentMapping))))
      | :? ScriptDom.UpdateDeleteSpecificationBase as src ->
        match src with
        | :? ScriptDom.DeleteSpecification as src->
          DataModificationSpecification.UpdateDeleteSpecificationBase((UpdateDeleteSpecificationBase.DeleteSpecification((src.FromClause |> Option.ofObj |> Option.map (fun x -> FromClause.FromCs(x, fragmentMapping))), (src.OutputClause |> Option.ofObj |> Option.map (fun x -> OutputClause.FromCs(x, fragmentMapping))), (src.OutputIntoClause |> Option.ofObj |> Option.map (fun x -> OutputIntoClause.FromCs(x, fragmentMapping))), (src.Target |> Option.ofObj |> Option.map (fun x -> TableReference.FromCs(x, fragmentMapping))), (src.TopRowFilter |> Option.ofObj |> Option.map (fun x -> TopRowFilter.FromCs(x, fragmentMapping))), (src.WhereClause |> Option.ofObj |> Option.map (fun x -> WhereClause.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.UpdateSpecification as src->
          DataModificationSpecification.UpdateDeleteSpecificationBase((UpdateDeleteSpecificationBase.UpdateSpecification((src.FromClause |> Option.ofObj |> Option.map (fun x -> FromClause.FromCs(x, fragmentMapping))), (src.OutputClause |> Option.ofObj |> Option.map (fun x -> OutputClause.FromCs(x, fragmentMapping))), (src.OutputIntoClause |> Option.ofObj |> Option.map (fun x -> OutputIntoClause.FromCs(x, fragmentMapping))), (src.SetClauses |> Seq.map (fun x -> SetClause.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Target |> Option.ofObj |> Option.map (fun x -> TableReference.FromCs(x, fragmentMapping))), (src.TopRowFilter |> Option.ofObj |> Option.map (fun x -> TopRowFilter.FromCs(x, fragmentMapping))), (src.WhereClause |> Option.ofObj |> Option.map (fun x -> WhereClause.FromCs(x, fragmentMapping))))  ))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] DataTypeReference = (* IsAbstract = true *)
  | ParameterizedDataTypeReference of ParameterizedDataTypeReference
  | XmlDataTypeReference of Name:SchemaObjectName option * XmlDataTypeOption:ScriptDom.XmlDataTypeOption * XmlSchemaCollection:SchemaObjectName option
  member this.ToCs() : ScriptDom.DataTypeReference =
    match this with
    | ParameterizedDataTypeReference(x) -> x.ToCs() :> ScriptDom.DataTypeReference (* 345 *)
    | XmlDataTypeReference(Name=aName; XmlDataTypeOption=aXmlDataTypeOption; XmlSchemaCollection=aXmlSchemaCollection) ->
      let ret = ScriptDom.XmlDataTypeReference()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.XmlDataTypeOption <- aXmlDataTypeOption
      ret.XmlSchemaCollection <- aXmlSchemaCollection |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DataTypeReference (* 335 *)
  static member FromCs(src:ScriptDom.DataTypeReference, fragmentMapping:FragmentMapping) : DataTypeReference =
    let ret =
      match src with
      | :? ScriptDom.ParameterizedDataTypeReference as src ->
        match src with
        | :? ScriptDom.SqlDataTypeReference as src->
          DataTypeReference.ParameterizedDataTypeReference((ParameterizedDataTypeReference.SqlDataTypeReference((src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.Parameters |> Seq.map (fun x -> Literal.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.SqlDataTypeOption))  ))
        | :? ScriptDom.UserDataTypeReference as src->
          DataTypeReference.ParameterizedDataTypeReference((ParameterizedDataTypeReference.UserDataTypeReference((src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.Parameters |> Seq.map (fun x -> Literal.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
      | :? ScriptDom.XmlDataTypeReference as src ->
        DataTypeReference.XmlDataTypeReference((src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.XmlDataTypeOption),(src.XmlSchemaCollection |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] DatabaseConfigurationSetOption = (* IsAbstract = false *)
  | Base of GenericOptionKind:Identifier option * OptionKind:ScriptDom.DatabaseConfigSetOptionKind
  | GenericConfigurationOption of GenericOptionKind:Identifier option * GenericOptionState:IdentifierOrScalarExpression option * OptionKind:ScriptDom.DatabaseConfigSetOptionKind
  | MaxDopConfigurationOption of GenericOptionKind:Identifier option * OptionKind:ScriptDom.DatabaseConfigSetOptionKind * Primary:bool * Value:Literal option
  | OnOffPrimaryConfigurationOption of GenericOptionKind:Identifier option * OptionKind:ScriptDom.DatabaseConfigSetOptionKind * OptionState:ScriptDom.DatabaseConfigurationOptionState
  member this.ToCs() : ScriptDom.DatabaseConfigurationSetOption =
    match this with
    | GenericConfigurationOption(GenericOptionKind=aGenericOptionKind; GenericOptionState=aGenericOptionState; OptionKind=aOptionKind) ->
      let ret = ScriptDom.GenericConfigurationOption()
      ret.GenericOptionKind <- aGenericOptionKind |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.GenericOptionState <- aGenericOptionState |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.DatabaseConfigurationSetOption (* 335 *)
    | MaxDopConfigurationOption(GenericOptionKind=aGenericOptionKind; OptionKind=aOptionKind; Primary=aPrimary; Value=aValue) ->
      let ret = ScriptDom.MaxDopConfigurationOption()
      ret.GenericOptionKind <- aGenericOptionKind |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret.Primary <- aPrimary
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DatabaseConfigurationSetOption (* 335 *)
    | OnOffPrimaryConfigurationOption(GenericOptionKind=aGenericOptionKind; OptionKind=aOptionKind; OptionState=aOptionState) ->
      let ret = ScriptDom.OnOffPrimaryConfigurationOption()
      ret.GenericOptionKind <- aGenericOptionKind |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret :> ScriptDom.DatabaseConfigurationSetOption (* 335 *)
    | Base(GenericOptionKind=aGenericOptionKind; OptionKind=aOptionKind) ->

      let ret = ScriptDom.DatabaseConfigurationSetOption()
      ret.GenericOptionKind <- aGenericOptionKind |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret
  static member FromCs(src:ScriptDom.DatabaseConfigurationSetOption, fragmentMapping:FragmentMapping) : DatabaseConfigurationSetOption =
    let ret =
      match src with
      | :? ScriptDom.GenericConfigurationOption as src ->
        DatabaseConfigurationSetOption.GenericConfigurationOption((src.GenericOptionKind |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.GenericOptionState |> Option.ofObj |> Option.map (fun x -> IdentifierOrScalarExpression.FromCs(x, fragmentMapping))),(src.OptionKind))
      | :? ScriptDom.MaxDopConfigurationOption as src ->
        DatabaseConfigurationSetOption.MaxDopConfigurationOption((src.GenericOptionKind |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.OptionKind),(src.Primary),(src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.OnOffPrimaryConfigurationOption as src ->
        DatabaseConfigurationSetOption.OnOffPrimaryConfigurationOption((src.GenericOptionKind |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.OptionKind),(src.OptionState))
      | _ -> (* :? ScriptDom.DatabaseConfigurationSetOption as src *)
        DatabaseConfigurationSetOption.Base(((src.GenericOptionKind |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.OptionKind))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] DatabaseOption = (* IsAbstract = false *)
  | Base of OptionKind:ScriptDom.DatabaseOptionKind
  | AcceleratedDatabaseRecoveryDatabaseOption of OptionKind:ScriptDom.DatabaseOptionKind * OptionState:ScriptDom.OptionState
  | AutomaticTuningDatabaseOption of AutomaticTuningState:ScriptDom.AutomaticTuningState * OptionKind:ScriptDom.DatabaseOptionKind * Options:(AutomaticTuningOption) list
  | CatalogCollationOption of CatalogCollation:(ScriptDom.CatalogCollation) option * OptionKind:ScriptDom.DatabaseOptionKind
  | ChangeTrackingDatabaseOption of Details:(ChangeTrackingOptionDetail) list * OptionKind:ScriptDom.DatabaseOptionKind * OptionState:ScriptDom.OptionState
  | ContainmentDatabaseOption of OptionKind:ScriptDom.DatabaseOptionKind * Value:ScriptDom.ContainmentOptionKind
  | CursorDefaultDatabaseOption of IsLocal:bool * OptionKind:ScriptDom.DatabaseOptionKind
  | DelayedDurabilityDatabaseOption of OptionKind:ScriptDom.DatabaseOptionKind * Value:ScriptDom.DelayedDurabilityOptionKind
  | FileStreamDatabaseOption of DirectoryName:Literal option * NonTransactedAccess:(ScriptDom.NonTransactedFileStreamAccess) option * OptionKind:ScriptDom.DatabaseOptionKind
  | HadrDatabaseOption of HadrDatabaseOption
  | IdentifierDatabaseOption of OptionKind:ScriptDom.DatabaseOptionKind * Value:Identifier option
  | LiteralDatabaseOption of OptionKind:ScriptDom.DatabaseOptionKind * Value:Literal option
  | MaxSizeDatabaseOption of MaxSize:Literal option * OptionKind:ScriptDom.DatabaseOptionKind * Units:ScriptDom.MemoryUnit
  | OnOffDatabaseOption of OnOffDatabaseOption
  | PageVerifyDatabaseOption of OptionKind:ScriptDom.DatabaseOptionKind * Value:ScriptDom.PageVerifyDatabaseOptionKind
  | ParameterizationDatabaseOption of IsSimple:bool * OptionKind:ScriptDom.DatabaseOptionKind
  | PartnerDatabaseOption of OptionKind:ScriptDom.DatabaseOptionKind * PartnerOption:ScriptDom.PartnerDatabaseOptionKind * PartnerServer:Literal option * Timeout:Literal option
  | QueryStoreDatabaseOption of Clear:bool * ClearAll:bool * OptionKind:ScriptDom.DatabaseOptionKind * OptionState:ScriptDom.OptionState * Options:(QueryStoreOption) list
  | RecoveryDatabaseOption of OptionKind:ScriptDom.DatabaseOptionKind * Value:ScriptDom.RecoveryDatabaseOptionKind
  | RemoteDataArchiveDatabaseOption of OptionKind:ScriptDom.DatabaseOptionKind * OptionState:ScriptDom.OptionState * Settings:(RemoteDataArchiveDatabaseSetting) list
  | TargetRecoveryTimeDatabaseOption of OptionKind:ScriptDom.DatabaseOptionKind * RecoveryTime:Literal option * Unit:ScriptDom.TimeUnit
  | WitnessDatabaseOption of IsOff:bool * OptionKind:ScriptDom.DatabaseOptionKind * WitnessServer:Literal option
  member this.ToCs() : ScriptDom.DatabaseOption =
    match this with
    | AcceleratedDatabaseRecoveryDatabaseOption(OptionKind=aOptionKind; OptionState=aOptionState) ->
      let ret = ScriptDom.AcceleratedDatabaseRecoveryDatabaseOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret :> ScriptDom.DatabaseOption (* 335 *)
    | AutomaticTuningDatabaseOption(AutomaticTuningState=aAutomaticTuningState; OptionKind=aOptionKind; Options=aOptions) ->
      let ret = ScriptDom.AutomaticTuningDatabaseOption()
      ret.AutomaticTuningState <- aAutomaticTuningState
      ret.OptionKind <- aOptionKind
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.DatabaseOption (* 335 *)
    | CatalogCollationOption(CatalogCollation=aCatalogCollation; OptionKind=aOptionKind) ->
      let ret = ScriptDom.CatalogCollationOption()
      ret.CatalogCollation <- Option.toNullable aCatalogCollation
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.DatabaseOption (* 335 *)
    | ChangeTrackingDatabaseOption(Details=aDetails; OptionKind=aOptionKind; OptionState=aOptionState) ->
      let ret = ScriptDom.ChangeTrackingDatabaseOption()
      for e in aDetails do ret.Details.Add (e.ToCs())
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret :> ScriptDom.DatabaseOption (* 335 *)
    | ContainmentDatabaseOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.ContainmentDatabaseOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.DatabaseOption (* 335 *)
    | CursorDefaultDatabaseOption(IsLocal=aIsLocal; OptionKind=aOptionKind) ->
      let ret = ScriptDom.CursorDefaultDatabaseOption()
      ret.IsLocal <- aIsLocal
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.DatabaseOption (* 335 *)
    | DelayedDurabilityDatabaseOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.DelayedDurabilityDatabaseOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.DatabaseOption (* 335 *)
    | FileStreamDatabaseOption(DirectoryName=aDirectoryName; NonTransactedAccess=aNonTransactedAccess; OptionKind=aOptionKind) ->
      let ret = ScriptDom.FileStreamDatabaseOption()
      ret.DirectoryName <- aDirectoryName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.NonTransactedAccess <- Option.toNullable aNonTransactedAccess
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.DatabaseOption (* 335 *)
    | HadrDatabaseOption(x) -> x.ToCs() :> ScriptDom.DatabaseOption (* 345 *)
    | IdentifierDatabaseOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.IdentifierDatabaseOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DatabaseOption (* 335 *)
    | LiteralDatabaseOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.LiteralDatabaseOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DatabaseOption (* 335 *)
    | MaxSizeDatabaseOption(MaxSize=aMaxSize; OptionKind=aOptionKind; Units=aUnits) ->
      let ret = ScriptDom.MaxSizeDatabaseOption()
      ret.MaxSize <- aMaxSize |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret.Units <- aUnits
      ret :> ScriptDom.DatabaseOption (* 335 *)
    | OnOffDatabaseOption(x) -> x.ToCs() :> ScriptDom.DatabaseOption (* 345 *)
    | PageVerifyDatabaseOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.PageVerifyDatabaseOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.DatabaseOption (* 335 *)
    | ParameterizationDatabaseOption(IsSimple=aIsSimple; OptionKind=aOptionKind) ->
      let ret = ScriptDom.ParameterizationDatabaseOption()
      ret.IsSimple <- aIsSimple
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.DatabaseOption (* 335 *)
    | PartnerDatabaseOption(OptionKind=aOptionKind; PartnerOption=aPartnerOption; PartnerServer=aPartnerServer; Timeout=aTimeout) ->
      let ret = ScriptDom.PartnerDatabaseOption()
      ret.OptionKind <- aOptionKind
      ret.PartnerOption <- aPartnerOption
      ret.PartnerServer <- aPartnerServer |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Timeout <- aTimeout |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DatabaseOption (* 335 *)
    | QueryStoreDatabaseOption(Clear=aClear; ClearAll=aClearAll; OptionKind=aOptionKind; OptionState=aOptionState; Options=aOptions) ->
      let ret = ScriptDom.QueryStoreDatabaseOption()
      ret.Clear <- aClear
      ret.ClearAll <- aClearAll
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.DatabaseOption (* 335 *)
    | RecoveryDatabaseOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.RecoveryDatabaseOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.DatabaseOption (* 335 *)
    | RemoteDataArchiveDatabaseOption(OptionKind=aOptionKind; OptionState=aOptionState; Settings=aSettings) ->
      let ret = ScriptDom.RemoteDataArchiveDatabaseOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      for e in aSettings do ret.Settings.Add (e.ToCs())
      ret :> ScriptDom.DatabaseOption (* 335 *)
    | TargetRecoveryTimeDatabaseOption(OptionKind=aOptionKind; RecoveryTime=aRecoveryTime; Unit=aUnit) ->
      let ret = ScriptDom.TargetRecoveryTimeDatabaseOption()
      ret.OptionKind <- aOptionKind
      ret.RecoveryTime <- aRecoveryTime |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Unit <- aUnit
      ret :> ScriptDom.DatabaseOption (* 335 *)
    | WitnessDatabaseOption(IsOff=aIsOff; OptionKind=aOptionKind; WitnessServer=aWitnessServer) ->
      let ret = ScriptDom.WitnessDatabaseOption()
      ret.IsOff <- aIsOff
      ret.OptionKind <- aOptionKind
      ret.WitnessServer <- aWitnessServer |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DatabaseOption (* 335 *)
    | Base(OptionKind=aOptionKind) ->

      let ret = ScriptDom.DatabaseOption()
      ret.OptionKind <- aOptionKind
      ret
  static member FromCs(src:ScriptDom.DatabaseOption, fragmentMapping:FragmentMapping) : DatabaseOption =
    let ret =
      match src with
      | :? ScriptDom.AcceleratedDatabaseRecoveryDatabaseOption as src ->
        DatabaseOption.AcceleratedDatabaseRecoveryDatabaseOption((src.OptionKind),(src.OptionState))
      | :? ScriptDom.AutomaticTuningDatabaseOption as src ->
        DatabaseOption.AutomaticTuningDatabaseOption((src.AutomaticTuningState),(src.OptionKind),(src.Options |> Seq.map (fun x -> AutomaticTuningOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.CatalogCollationOption as src ->
        DatabaseOption.CatalogCollationOption((Option.ofNullable (src.CatalogCollation)),(src.OptionKind))
      | :? ScriptDom.ChangeTrackingDatabaseOption as src ->
        DatabaseOption.ChangeTrackingDatabaseOption((src.Details |> Seq.map (fun x -> ChangeTrackingOptionDetail.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.OptionKind),(src.OptionState))
      | :? ScriptDom.ContainmentDatabaseOption as src ->
        DatabaseOption.ContainmentDatabaseOption((src.OptionKind),(src.Value))
      | :? ScriptDom.CursorDefaultDatabaseOption as src ->
        DatabaseOption.CursorDefaultDatabaseOption((src.IsLocal),(src.OptionKind))
      | :? ScriptDom.DelayedDurabilityDatabaseOption as src ->
        DatabaseOption.DelayedDurabilityDatabaseOption((src.OptionKind),(src.Value))
      | :? ScriptDom.FileStreamDatabaseOption as src ->
        DatabaseOption.FileStreamDatabaseOption((src.DirectoryName |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(Option.ofNullable (src.NonTransactedAccess)),(src.OptionKind))
      | :? ScriptDom.HadrDatabaseOption as src ->
        match src with
        | :? ScriptDom.HadrAvailabilityGroupDatabaseOption as src->
          DatabaseOption.HadrDatabaseOption((HadrDatabaseOption.HadrAvailabilityGroupDatabaseOption((src.GroupName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.HadrOption), (src.OptionKind))  ))
        | _ -> (* :? ScriptDom.HadrDatabaseOption as src *)
          DatabaseOption.HadrDatabaseOption((HadrDatabaseOption.Base((src.HadrOption), (src.OptionKind))))
      | :? ScriptDom.IdentifierDatabaseOption as src ->
        DatabaseOption.IdentifierDatabaseOption((src.OptionKind),(src.Value |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.LiteralDatabaseOption as src ->
        DatabaseOption.LiteralDatabaseOption((src.OptionKind),(src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.MaxSizeDatabaseOption as src ->
        DatabaseOption.MaxSizeDatabaseOption((src.MaxSize |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.OptionKind),(src.Units))
      | :? ScriptDom.OnOffDatabaseOption as src ->
        match src with
        | :? ScriptDom.AutoCreateStatisticsDatabaseOption as src->
          DatabaseOption.OnOffDatabaseOption((OnOffDatabaseOption.AutoCreateStatisticsDatabaseOption((src.HasIncremental), (src.IncrementalState), (src.OptionKind), (src.OptionState))  ))
        | _ -> (* :? ScriptDom.OnOffDatabaseOption as src *)
          DatabaseOption.OnOffDatabaseOption((OnOffDatabaseOption.Base((src.OptionKind), (src.OptionState))))
      | :? ScriptDom.PageVerifyDatabaseOption as src ->
        DatabaseOption.PageVerifyDatabaseOption((src.OptionKind),(src.Value))
      | :? ScriptDom.ParameterizationDatabaseOption as src ->
        DatabaseOption.ParameterizationDatabaseOption((src.IsSimple),(src.OptionKind))
      | :? ScriptDom.PartnerDatabaseOption as src ->
        DatabaseOption.PartnerDatabaseOption((src.OptionKind),(src.PartnerOption),(src.PartnerServer |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.Timeout |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.QueryStoreDatabaseOption as src ->
        DatabaseOption.QueryStoreDatabaseOption((src.Clear),(src.ClearAll),(src.OptionKind),(src.OptionState),(src.Options |> Seq.map (fun x -> QueryStoreOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.RecoveryDatabaseOption as src ->
        DatabaseOption.RecoveryDatabaseOption((src.OptionKind),(src.Value))
      | :? ScriptDom.RemoteDataArchiveDatabaseOption as src ->
        DatabaseOption.RemoteDataArchiveDatabaseOption((src.OptionKind),(src.OptionState),(src.Settings |> Seq.map (fun x -> RemoteDataArchiveDatabaseSetting.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.TargetRecoveryTimeDatabaseOption as src ->
        DatabaseOption.TargetRecoveryTimeDatabaseOption((src.OptionKind),(src.RecoveryTime |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.Unit))
      | :? ScriptDom.WitnessDatabaseOption as src ->
        DatabaseOption.WitnessDatabaseOption((src.IsOff),(src.OptionKind),(src.WitnessServer |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | _ -> (* :? ScriptDom.DatabaseOption as src *)
        DatabaseOption.Base(((src.OptionKind))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] DeclareVariableElement = (* IsAbstract = false *)
  | Base of DataType:DataTypeReference option * Nullable:NullableConstraintDefinition option * Value:ScalarExpression option * VariableName:Identifier option
  | ProcedureParameter of DataType:DataTypeReference option * IsVarying:bool * Modifier:ScriptDom.ParameterModifier * Nullable:NullableConstraintDefinition option * Value:ScalarExpression option * VariableName:Identifier option
  member this.ToCs() : ScriptDom.DeclareVariableElement =
    match this with
    | ProcedureParameter(DataType=aDataType; IsVarying=aIsVarying; Modifier=aModifier; Nullable=aNullable; Value=aValue; VariableName=aVariableName) ->
      let ret = ScriptDom.ProcedureParameter()
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsVarying <- aIsVarying
      ret.Modifier <- aModifier
      ret.Nullable <- aNullable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.VariableName <- aVariableName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DeclareVariableElement (* 335 *)
    | Base(DataType=aDataType; Nullable=aNullable; Value=aValue; VariableName=aVariableName) ->

      let ret = ScriptDom.DeclareVariableElement()
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Nullable <- aNullable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.VariableName <- aVariableName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret
  static member FromCs(src:ScriptDom.DeclareVariableElement, fragmentMapping:FragmentMapping) : DeclareVariableElement =
    let ret =
      match src with
      | :? ScriptDom.ProcedureParameter as src ->
        DeclareVariableElement.ProcedureParameter((src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))),(src.IsVarying),(src.Modifier),(src.Nullable |> Option.ofObj |> Option.map (fun x -> NullableConstraintDefinition.FromCs(x, fragmentMapping))),(src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.VariableName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | _ -> (* :? ScriptDom.DeclareVariableElement as src *)
        DeclareVariableElement.Base(((src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.Nullable |> Option.ofObj |> Option.map (fun x -> NullableConstraintDefinition.FromCs(x, fragmentMapping))), (src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.VariableName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] DialogOption = (* IsAbstract = true *)
  | OnOffDialogOption of OptionKind:ScriptDom.DialogOptionKind * OptionState:ScriptDom.OptionState
  | ScalarExpressionDialogOption of OptionKind:ScriptDom.DialogOptionKind * Value:ScalarExpression option
  member this.ToCs() : ScriptDom.DialogOption =
    match this with
    | OnOffDialogOption(OptionKind=aOptionKind; OptionState=aOptionState) ->
      let ret = ScriptDom.OnOffDialogOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret :> ScriptDom.DialogOption (* 335 *)
    | ScalarExpressionDialogOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.ScalarExpressionDialogOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DialogOption (* 335 *)
  static member FromCs(src:ScriptDom.DialogOption, fragmentMapping:FragmentMapping) : DialogOption =
    let ret =
      match src with
      | :? ScriptDom.OnOffDialogOption as src ->
        DialogOption.OnOffDialogOption((src.OptionKind),(src.OptionState))
      | :? ScriptDom.ScalarExpressionDialogOption as src ->
        DialogOption.ScalarExpressionDialogOption((src.OptionKind),(src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] DropClusteredConstraintOption = (* IsAbstract = true *)
  | DropClusteredConstraintMoveOption of OptionKind:ScriptDom.DropClusteredConstraintOptionKind * OptionValue:FileGroupOrPartitionScheme option
  | DropClusteredConstraintStateOption of OptionKind:ScriptDom.DropClusteredConstraintOptionKind * OptionState:ScriptDom.OptionState
  | DropClusteredConstraintValueOption of OptionKind:ScriptDom.DropClusteredConstraintOptionKind * OptionValue:Literal option
  | DropClusteredConstraintWaitAtLowPriorityLockOption of OptionKind:ScriptDom.DropClusteredConstraintOptionKind * Options:(LowPriorityLockWaitOption) list
  member this.ToCs() : ScriptDom.DropClusteredConstraintOption =
    match this with
    | DropClusteredConstraintMoveOption(OptionKind=aOptionKind; OptionValue=aOptionValue) ->
      let ret = ScriptDom.DropClusteredConstraintMoveOption()
      ret.OptionKind <- aOptionKind
      ret.OptionValue <- aOptionValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropClusteredConstraintOption (* 335 *)
    | DropClusteredConstraintStateOption(OptionKind=aOptionKind; OptionState=aOptionState) ->
      let ret = ScriptDom.DropClusteredConstraintStateOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret :> ScriptDom.DropClusteredConstraintOption (* 335 *)
    | DropClusteredConstraintValueOption(OptionKind=aOptionKind; OptionValue=aOptionValue) ->
      let ret = ScriptDom.DropClusteredConstraintValueOption()
      ret.OptionKind <- aOptionKind
      ret.OptionValue <- aOptionValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropClusteredConstraintOption (* 335 *)
    | DropClusteredConstraintWaitAtLowPriorityLockOption(OptionKind=aOptionKind; Options=aOptions) ->
      let ret = ScriptDom.DropClusteredConstraintWaitAtLowPriorityLockOption()
      ret.OptionKind <- aOptionKind
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.DropClusteredConstraintOption (* 335 *)
  static member FromCs(src:ScriptDom.DropClusteredConstraintOption, fragmentMapping:FragmentMapping) : DropClusteredConstraintOption =
    let ret =
      match src with
      | :? ScriptDom.DropClusteredConstraintMoveOption as src ->
        DropClusteredConstraintOption.DropClusteredConstraintMoveOption((src.OptionKind),(src.OptionValue |> Option.ofObj |> Option.map (fun x -> FileGroupOrPartitionScheme.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropClusteredConstraintStateOption as src ->
        DropClusteredConstraintOption.DropClusteredConstraintStateOption((src.OptionKind),(src.OptionState))
      | :? ScriptDom.DropClusteredConstraintValueOption as src ->
        DropClusteredConstraintOption.DropClusteredConstraintValueOption((src.OptionKind),(src.OptionValue |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropClusteredConstraintWaitAtLowPriorityLockOption as src ->
        DropClusteredConstraintOption.DropClusteredConstraintWaitAtLowPriorityLockOption((src.OptionKind),(src.Options |> Seq.map (fun x -> LowPriorityLockWaitOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] DropIndexClauseBase = (* IsAbstract = true *)
  | BackwardsCompatibleDropIndexClause of Index:ChildObjectName option
  | DropIndexClause of Index:Identifier option * Object:SchemaObjectName option * Options:(IndexOption) list
  member this.ToCs() : ScriptDom.DropIndexClauseBase =
    match this with
    | BackwardsCompatibleDropIndexClause(Index=aIndex) ->
      let ret = ScriptDom.BackwardsCompatibleDropIndexClause()
      ret.Index <- aIndex |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropIndexClauseBase (* 335 *)
    | DropIndexClause(Index=aIndex; Object=aObject; Options=aOptions) ->
      let ret = ScriptDom.DropIndexClause()
      ret.Index <- aIndex |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Object <- aObject |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.DropIndexClauseBase (* 335 *)
  static member FromCs(src:ScriptDom.DropIndexClauseBase, fragmentMapping:FragmentMapping) : DropIndexClauseBase =
    let ret =
      match src with
      | :? ScriptDom.BackwardsCompatibleDropIndexClause as src ->
        DropIndexClauseBase.BackwardsCompatibleDropIndexClause((src.Index |> Option.ofObj |> Option.map (fun x -> ChildObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropIndexClause as src ->
        DropIndexClauseBase.DropIndexClause((src.Index |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Object |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.Options |> Seq.map (fun x -> IndexOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] EncryptionSource = (* IsAbstract = true *)
  | AssemblyEncryptionSource of Assembly:Identifier option
  | FileEncryptionSource of File:Literal option * IsExecutable:bool
  | ProviderEncryptionSource of KeyOptions:(KeyOption) list * Name:Identifier option
  member this.ToCs() : ScriptDom.EncryptionSource =
    match this with
    | AssemblyEncryptionSource(Assembly=aAssembly) ->
      let ret = ScriptDom.AssemblyEncryptionSource()
      ret.Assembly <- aAssembly |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.EncryptionSource (* 335 *)
    | FileEncryptionSource(File=aFile; IsExecutable=aIsExecutable) ->
      let ret = ScriptDom.FileEncryptionSource()
      ret.File <- aFile |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsExecutable <- aIsExecutable
      ret :> ScriptDom.EncryptionSource (* 335 *)
    | ProviderEncryptionSource(KeyOptions=aKeyOptions; Name=aName) ->
      let ret = ScriptDom.ProviderEncryptionSource()
      for e in aKeyOptions do ret.KeyOptions.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.EncryptionSource (* 335 *)
  static member FromCs(src:ScriptDom.EncryptionSource, fragmentMapping:FragmentMapping) : EncryptionSource =
    let ret =
      match src with
      | :? ScriptDom.AssemblyEncryptionSource as src ->
        EncryptionSource.AssemblyEncryptionSource((src.Assembly |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.FileEncryptionSource as src ->
        EncryptionSource.FileEncryptionSource((src.File |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.IsExecutable))
      | :? ScriptDom.ProviderEncryptionSource as src ->
        EncryptionSource.ProviderEncryptionSource((src.KeyOptions |> Seq.map (fun x -> KeyOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] EndpointProtocolOption = (* IsAbstract = true *)
  | AuthenticationEndpointProtocolOption of AuthenticationTypes:ScriptDom.AuthenticationTypes * Kind:ScriptDom.EndpointProtocolOptions
  | CompressionEndpointProtocolOption of IsEnabled:bool * Kind:ScriptDom.EndpointProtocolOptions
  | ListenerIPEndpointProtocolOption of IPv4PartOne:IPv4 option * IPv4PartTwo:IPv4 option * IPv6:Literal option * IsAll:bool * Kind:ScriptDom.EndpointProtocolOptions
  | LiteralEndpointProtocolOption of Kind:ScriptDom.EndpointProtocolOptions * Value:Literal option
  | PortsEndpointProtocolOption of Kind:ScriptDom.EndpointProtocolOptions * PortTypes:ScriptDom.PortTypes
  member this.ToCs() : ScriptDom.EndpointProtocolOption =
    match this with
    | AuthenticationEndpointProtocolOption(AuthenticationTypes=aAuthenticationTypes; Kind=aKind) ->
      let ret = ScriptDom.AuthenticationEndpointProtocolOption()
      ret.AuthenticationTypes <- aAuthenticationTypes
      ret.Kind <- aKind
      ret :> ScriptDom.EndpointProtocolOption (* 335 *)
    | CompressionEndpointProtocolOption(IsEnabled=aIsEnabled; Kind=aKind) ->
      let ret = ScriptDom.CompressionEndpointProtocolOption()
      ret.IsEnabled <- aIsEnabled
      ret.Kind <- aKind
      ret :> ScriptDom.EndpointProtocolOption (* 335 *)
    | ListenerIPEndpointProtocolOption(IPv4PartOne=aIPv4PartOne; IPv4PartTwo=aIPv4PartTwo; IPv6=aIPv6; IsAll=aIsAll; Kind=aKind) ->
      let ret = ScriptDom.ListenerIPEndpointProtocolOption()
      ret.IPv4PartOne <- aIPv4PartOne |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IPv4PartTwo <- aIPv4PartTwo |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IPv6 <- aIPv6 |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsAll <- aIsAll
      ret.Kind <- aKind
      ret :> ScriptDom.EndpointProtocolOption (* 335 *)
    | LiteralEndpointProtocolOption(Kind=aKind; Value=aValue) ->
      let ret = ScriptDom.LiteralEndpointProtocolOption()
      ret.Kind <- aKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.EndpointProtocolOption (* 335 *)
    | PortsEndpointProtocolOption(Kind=aKind; PortTypes=aPortTypes) ->
      let ret = ScriptDom.PortsEndpointProtocolOption()
      ret.Kind <- aKind
      ret.PortTypes <- aPortTypes
      ret :> ScriptDom.EndpointProtocolOption (* 335 *)
  static member FromCs(src:ScriptDom.EndpointProtocolOption, fragmentMapping:FragmentMapping) : EndpointProtocolOption =
    let ret =
      match src with
      | :? ScriptDom.AuthenticationEndpointProtocolOption as src ->
        EndpointProtocolOption.AuthenticationEndpointProtocolOption((src.AuthenticationTypes),(src.Kind))
      | :? ScriptDom.CompressionEndpointProtocolOption as src ->
        EndpointProtocolOption.CompressionEndpointProtocolOption((src.IsEnabled),(src.Kind))
      | :? ScriptDom.ListenerIPEndpointProtocolOption as src ->
        EndpointProtocolOption.ListenerIPEndpointProtocolOption((src.IPv4PartOne |> Option.ofObj |> Option.map (fun x -> IPv4.FromCs(x, fragmentMapping))),(src.IPv4PartTwo |> Option.ofObj |> Option.map (fun x -> IPv4.FromCs(x, fragmentMapping))),(src.IPv6 |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.IsAll),(src.Kind))
      | :? ScriptDom.LiteralEndpointProtocolOption as src ->
        EndpointProtocolOption.LiteralEndpointProtocolOption((src.Kind),(src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.PortsEndpointProtocolOption as src ->
        EndpointProtocolOption.PortsEndpointProtocolOption((src.Kind),(src.PortTypes))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] EventTypeGroupContainer = (* IsAbstract = true *)
  | EventGroupContainer of EventGroup:ScriptDom.EventNotificationEventGroup
  | EventTypeContainer of EventType:ScriptDom.EventNotificationEventType
  member this.ToCs() : ScriptDom.EventTypeGroupContainer =
    match this with
    | EventGroupContainer(EventGroup=aEventGroup) ->
      let ret = ScriptDom.EventGroupContainer()
      ret.EventGroup <- aEventGroup
      ret :> ScriptDom.EventTypeGroupContainer (* 335 *)
    | EventTypeContainer(EventType=aEventType) ->
      let ret = ScriptDom.EventTypeContainer()
      ret.EventType <- aEventType
      ret :> ScriptDom.EventTypeGroupContainer (* 335 *)
  static member FromCs(src:ScriptDom.EventTypeGroupContainer, fragmentMapping:FragmentMapping) : EventTypeGroupContainer =
    let ret =
      match src with
      | :? ScriptDom.EventGroupContainer as src ->
        EventTypeGroupContainer.EventGroupContainer((src.EventGroup))
      | :? ScriptDom.EventTypeContainer as src ->
        EventTypeGroupContainer.EventTypeContainer((src.EventType))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ExecutableEntity = (* IsAbstract = true *)
  | ExecutableProcedureReference of AdHocDataSource:AdHocDataSource option * Parameters:(ExecuteParameter) list * ProcedureReference:ProcedureReferenceName option
  | ExecutableStringList of Parameters:(ExecuteParameter) list * Strings:(ValueExpression) list
  member this.ToCs() : ScriptDom.ExecutableEntity =
    match this with
    | ExecutableProcedureReference(AdHocDataSource=aAdHocDataSource; Parameters=aParameters; ProcedureReference=aProcedureReference) ->
      let ret = ScriptDom.ExecutableProcedureReference()
      ret.AdHocDataSource <- aAdHocDataSource |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret.ProcedureReference <- aProcedureReference |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ExecutableEntity (* 335 *)
    | ExecutableStringList(Parameters=aParameters; Strings=aStrings) ->
      let ret = ScriptDom.ExecutableStringList()
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      for e in aStrings do ret.Strings.Add (e.ToCs())
      ret :> ScriptDom.ExecutableEntity (* 335 *)
  static member FromCs(src:ScriptDom.ExecutableEntity, fragmentMapping:FragmentMapping) : ExecutableEntity =
    let ret =
      match src with
      | :? ScriptDom.ExecutableProcedureReference as src ->
        ExecutableEntity.ExecutableProcedureReference((src.AdHocDataSource |> Option.ofObj |> Option.map (fun x -> AdHocDataSource.FromCs(x, fragmentMapping))),(src.Parameters |> Seq.map (fun src -> ExecuteParameter.ExecuteParameter((src.IsOutput), (src.ParameterValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.Variable |> Option.ofObj |> Option.map (fun x -> VariableReference.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.ProcedureReference |> Option.ofObj |> Option.map (fun x -> ProcedureReferenceName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ExecutableStringList as src ->
        ExecutableEntity.ExecutableStringList((src.Parameters |> Seq.map (fun src -> ExecuteParameter.ExecuteParameter((src.IsOutput), (src.ParameterValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.Variable |> Option.ofObj |> Option.map (fun x -> VariableReference.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.Strings |> Seq.map (fun x -> ValueExpression.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ExecuteOption = (* IsAbstract = false *)
  | Base of OptionKind:ScriptDom.ExecuteOptionKind
  | ResultSetsExecuteOption of Definitions:(ResultSetDefinition) list * OptionKind:ScriptDom.ExecuteOptionKind * ResultSetsOptionKind:ScriptDom.ResultSetsOptionKind
  member this.ToCs() : ScriptDom.ExecuteOption =
    match this with
    | ResultSetsExecuteOption(Definitions=aDefinitions; OptionKind=aOptionKind; ResultSetsOptionKind=aResultSetsOptionKind) ->
      let ret = ScriptDom.ResultSetsExecuteOption()
      for e in aDefinitions do ret.Definitions.Add (e.ToCs())
      ret.OptionKind <- aOptionKind
      ret.ResultSetsOptionKind <- aResultSetsOptionKind
      ret :> ScriptDom.ExecuteOption (* 335 *)
    | Base(OptionKind=aOptionKind) ->

      let ret = ScriptDom.ExecuteOption()
      ret.OptionKind <- aOptionKind
      ret
  static member FromCs(src:ScriptDom.ExecuteOption, fragmentMapping:FragmentMapping) : ExecuteOption =
    let ret =
      match src with
      | :? ScriptDom.ResultSetsExecuteOption as src ->
        ExecuteOption.ResultSetsExecuteOption((src.Definitions |> Seq.map (fun x -> ResultSetDefinition.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.OptionKind),(src.ResultSetsOptionKind))
      | _ -> (* :? ScriptDom.ExecuteOption as src *)
        ExecuteOption.Base(((src.OptionKind))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ExternalDataSourceOption = (* IsAbstract = true *)
  | ExternalDataSourceLiteralOrIdentifierOption of OptionKind:ScriptDom.ExternalDataSourceOptionKind * Value:IdentifierOrValueExpression option
  member this.ToCs() : ScriptDom.ExternalDataSourceOption =
    match this with
    | ExternalDataSourceLiteralOrIdentifierOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.ExternalDataSourceLiteralOrIdentifierOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ExternalDataSourceOption (* 335 *)
  static member FromCs(src:ScriptDom.ExternalDataSourceOption, fragmentMapping:FragmentMapping) : ExternalDataSourceOption =
    let ret =
      match src with
      | :? ScriptDom.ExternalDataSourceLiteralOrIdentifierOption as src ->
        ExternalDataSourceOption.ExternalDataSourceLiteralOrIdentifierOption((src.OptionKind),(src.Value |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ExternalFileFormatOption = (* IsAbstract = true *)
  | ExternalFileFormatContainerOption of OptionKind:ScriptDom.ExternalFileFormatOptionKind * Suboptions:(ExternalFileFormatOption) list
  | ExternalFileFormatLiteralOption of OptionKind:ScriptDom.ExternalFileFormatOptionKind * Value:Literal option
  | ExternalFileFormatUseDefaultTypeOption of ExternalFileFormatUseDefaultType:ScriptDom.ExternalFileFormatUseDefaultType * OptionKind:ScriptDom.ExternalFileFormatOptionKind
  member this.ToCs() : ScriptDom.ExternalFileFormatOption =
    match this with
    | ExternalFileFormatContainerOption(OptionKind=aOptionKind; Suboptions=aSuboptions) ->
      let ret = ScriptDom.ExternalFileFormatContainerOption()
      ret.OptionKind <- aOptionKind
      for e in aSuboptions do ret.Suboptions.Add (e.ToCs())
      ret :> ScriptDom.ExternalFileFormatOption (* 335 *)
    | ExternalFileFormatLiteralOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.ExternalFileFormatLiteralOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ExternalFileFormatOption (* 335 *)
    | ExternalFileFormatUseDefaultTypeOption(ExternalFileFormatUseDefaultType=aExternalFileFormatUseDefaultType; OptionKind=aOptionKind) ->
      let ret = ScriptDom.ExternalFileFormatUseDefaultTypeOption()
      ret.ExternalFileFormatUseDefaultType <- aExternalFileFormatUseDefaultType
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.ExternalFileFormatOption (* 335 *)
  static member FromCs(src:ScriptDom.ExternalFileFormatOption, fragmentMapping:FragmentMapping) : ExternalFileFormatOption =
    let ret =
      match src with
      | :? ScriptDom.ExternalFileFormatContainerOption as src ->
        ExternalFileFormatOption.ExternalFileFormatContainerOption((src.OptionKind),(src.Suboptions |> Seq.map (fun x -> ExternalFileFormatOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.ExternalFileFormatLiteralOption as src ->
        ExternalFileFormatOption.ExternalFileFormatLiteralOption((src.OptionKind),(src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ExternalFileFormatUseDefaultTypeOption as src ->
        ExternalFileFormatOption.ExternalFileFormatUseDefaultTypeOption((src.ExternalFileFormatUseDefaultType),(src.OptionKind))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ExternalTableDistributionPolicy = (* IsAbstract = true *)
  | ExternalTableReplicatedDistributionPolicy 
  | ExternalTableRoundRobinDistributionPolicy 
  | ExternalTableShardedDistributionPolicy of ShardingColumn:Identifier option
  member this.ToCs() : ScriptDom.ExternalTableDistributionPolicy =
    match this with
    | ExternalTableReplicatedDistributionPolicy -> ScriptDom.ExternalTableReplicatedDistributionPolicy() :> ScriptDom.ExternalTableDistributionPolicy (* 327 *)
    | ExternalTableRoundRobinDistributionPolicy -> ScriptDom.ExternalTableRoundRobinDistributionPolicy() :> ScriptDom.ExternalTableDistributionPolicy (* 327 *)
    | ExternalTableShardedDistributionPolicy(ShardingColumn=aShardingColumn) ->
      let ret = ScriptDom.ExternalTableShardedDistributionPolicy()
      ret.ShardingColumn <- aShardingColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ExternalTableDistributionPolicy (* 335 *)
  static member FromCs(src:ScriptDom.ExternalTableDistributionPolicy, fragmentMapping:FragmentMapping) : ExternalTableDistributionPolicy =
    let ret =
      match src with
      | :? ScriptDom.ExternalTableReplicatedDistributionPolicy as src ->
        ExternalTableDistributionPolicy.ExternalTableReplicatedDistributionPolicy
      | :? ScriptDom.ExternalTableRoundRobinDistributionPolicy as src ->
        ExternalTableDistributionPolicy.ExternalTableRoundRobinDistributionPolicy
      | :? ScriptDom.ExternalTableShardedDistributionPolicy as src ->
        ExternalTableDistributionPolicy.ExternalTableShardedDistributionPolicy((src.ShardingColumn |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ExternalTableOption = (* IsAbstract = true *)
  | ExternalTableDistributionOption of OptionKind:ScriptDom.ExternalTableOptionKind * Value:ExternalTableDistributionPolicy option
  | ExternalTableLiteralOrIdentifierOption of OptionKind:ScriptDom.ExternalTableOptionKind * Value:IdentifierOrValueExpression option
  | ExternalTableRejectTypeOption of OptionKind:ScriptDom.ExternalTableOptionKind * Value:ScriptDom.ExternalTableRejectType
  member this.ToCs() : ScriptDom.ExternalTableOption =
    match this with
    | ExternalTableDistributionOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.ExternalTableDistributionOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ExternalTableOption (* 335 *)
    | ExternalTableLiteralOrIdentifierOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.ExternalTableLiteralOrIdentifierOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ExternalTableOption (* 335 *)
    | ExternalTableRejectTypeOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.ExternalTableRejectTypeOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.ExternalTableOption (* 335 *)
  static member FromCs(src:ScriptDom.ExternalTableOption, fragmentMapping:FragmentMapping) : ExternalTableOption =
    let ret =
      match src with
      | :? ScriptDom.ExternalTableDistributionOption as src ->
        ExternalTableOption.ExternalTableDistributionOption((src.OptionKind),(src.Value |> Option.ofObj |> Option.map (fun x -> ExternalTableDistributionPolicy.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ExternalTableLiteralOrIdentifierOption as src ->
        ExternalTableOption.ExternalTableLiteralOrIdentifierOption((src.OptionKind),(src.Value |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ExternalTableRejectTypeOption as src ->
        ExternalTableOption.ExternalTableRejectTypeOption((src.OptionKind),(src.Value))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] FileDeclarationOption = (* IsAbstract = false *)
  | Base of OptionKind:ScriptDom.FileDeclarationOptionKind
  | FileGrowthFileDeclarationOption of GrowthIncrement:Literal option * OptionKind:ScriptDom.FileDeclarationOptionKind * Units:ScriptDom.MemoryUnit
  | FileNameFileDeclarationOption of OSFileName:Literal option * OptionKind:ScriptDom.FileDeclarationOptionKind
  | MaxSizeFileDeclarationOption of MaxSize:Literal option * OptionKind:ScriptDom.FileDeclarationOptionKind * Units:ScriptDom.MemoryUnit * Unlimited:bool
  | NameFileDeclarationOption of IsNewName:bool * LogicalFileName:IdentifierOrValueExpression option * OptionKind:ScriptDom.FileDeclarationOptionKind
  | SizeFileDeclarationOption of OptionKind:ScriptDom.FileDeclarationOptionKind * Size:Literal option * Units:ScriptDom.MemoryUnit
  member this.ToCs() : ScriptDom.FileDeclarationOption =
    match this with
    | FileGrowthFileDeclarationOption(GrowthIncrement=aGrowthIncrement; OptionKind=aOptionKind; Units=aUnits) ->
      let ret = ScriptDom.FileGrowthFileDeclarationOption()
      ret.GrowthIncrement <- aGrowthIncrement |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret.Units <- aUnits
      ret :> ScriptDom.FileDeclarationOption (* 335 *)
    | FileNameFileDeclarationOption(OSFileName=aOSFileName; OptionKind=aOptionKind) ->
      let ret = ScriptDom.FileNameFileDeclarationOption()
      ret.OSFileName <- aOSFileName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.FileDeclarationOption (* 335 *)
    | MaxSizeFileDeclarationOption(MaxSize=aMaxSize; OptionKind=aOptionKind; Units=aUnits; Unlimited=aUnlimited) ->
      let ret = ScriptDom.MaxSizeFileDeclarationOption()
      ret.MaxSize <- aMaxSize |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret.Units <- aUnits
      ret.Unlimited <- aUnlimited
      ret :> ScriptDom.FileDeclarationOption (* 335 *)
    | NameFileDeclarationOption(IsNewName=aIsNewName; LogicalFileName=aLogicalFileName; OptionKind=aOptionKind) ->
      let ret = ScriptDom.NameFileDeclarationOption()
      ret.IsNewName <- aIsNewName
      ret.LogicalFileName <- aLogicalFileName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.FileDeclarationOption (* 335 *)
    | SizeFileDeclarationOption(OptionKind=aOptionKind; Size=aSize; Units=aUnits) ->
      let ret = ScriptDom.SizeFileDeclarationOption()
      ret.OptionKind <- aOptionKind
      ret.Size <- aSize |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Units <- aUnits
      ret :> ScriptDom.FileDeclarationOption (* 335 *)
    | Base(OptionKind=aOptionKind) ->

      let ret = ScriptDom.FileDeclarationOption()
      ret.OptionKind <- aOptionKind
      ret
  static member FromCs(src:ScriptDom.FileDeclarationOption, fragmentMapping:FragmentMapping) : FileDeclarationOption =
    let ret =
      match src with
      | :? ScriptDom.FileGrowthFileDeclarationOption as src ->
        FileDeclarationOption.FileGrowthFileDeclarationOption((src.GrowthIncrement |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.OptionKind),(src.Units))
      | :? ScriptDom.FileNameFileDeclarationOption as src ->
        FileDeclarationOption.FileNameFileDeclarationOption((src.OSFileName |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.OptionKind))
      | :? ScriptDom.MaxSizeFileDeclarationOption as src ->
        FileDeclarationOption.MaxSizeFileDeclarationOption((src.MaxSize |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.OptionKind),(src.Units),(src.Unlimited))
      | :? ScriptDom.NameFileDeclarationOption as src ->
        FileDeclarationOption.NameFileDeclarationOption((src.IsNewName),(src.LogicalFileName |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))),(src.OptionKind))
      | :? ScriptDom.SizeFileDeclarationOption as src ->
        FileDeclarationOption.SizeFileDeclarationOption((src.OptionKind),(src.Size |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.Units))
      | _ -> (* :? ScriptDom.FileDeclarationOption as src *)
        FileDeclarationOption.Base(((src.OptionKind))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ForClause = (* IsAbstract = true *)
  | BrowseForClause 
  | JsonForClause of Options:(JsonForClauseOption) list
  | JsonForClauseOption of OptionKind:ScriptDom.JsonForClauseOptions * Value:Literal option
  | ReadOnlyForClause 
  | UpdateForClause of Columns:(ColumnReferenceExpression) list
  | XmlForClause of Options:(XmlForClauseOption) list
  | XmlForClauseOption of OptionKind:ScriptDom.XmlForClauseOptions * Value:Literal option
  member this.ToCs() : ScriptDom.ForClause =
    match this with
    | BrowseForClause -> ScriptDom.BrowseForClause() :> ScriptDom.ForClause (* 327 *)
    | JsonForClause(Options=aOptions) ->
      let ret = ScriptDom.JsonForClause()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.ForClause (* 335 *)
    | JsonForClauseOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.JsonForClauseOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ForClause (* 335 *)
    | ReadOnlyForClause -> ScriptDom.ReadOnlyForClause() :> ScriptDom.ForClause (* 327 *)
    | UpdateForClause(Columns=aColumns) ->
      let ret = ScriptDom.UpdateForClause()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret :> ScriptDom.ForClause (* 335 *)
    | XmlForClause(Options=aOptions) ->
      let ret = ScriptDom.XmlForClause()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.ForClause (* 335 *)
    | XmlForClauseOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.XmlForClauseOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ForClause (* 335 *)
  static member FromCs(src:ScriptDom.ForClause, fragmentMapping:FragmentMapping) : ForClause =
    let ret =
      match src with
      | :? ScriptDom.BrowseForClause as src ->
        ForClause.BrowseForClause
      | :? ScriptDom.JsonForClause as src ->
        ForClause.JsonForClause((src.Options |> Seq.map (fun src -> JsonForClauseOption.JsonForClauseOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq))
      | :? ScriptDom.JsonForClauseOption as src ->
        ForClause.JsonForClauseOption((src.OptionKind),(src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ReadOnlyForClause as src ->
        ForClause.ReadOnlyForClause
      | :? ScriptDom.UpdateForClause as src ->
        ForClause.UpdateForClause((src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq))
      | :? ScriptDom.XmlForClause as src ->
        ForClause.XmlForClause((src.Options |> Seq.map (fun src -> XmlForClauseOption.XmlForClauseOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq))
      | :? ScriptDom.XmlForClauseOption as src ->
        ForClause.XmlForClauseOption((src.OptionKind),(src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] FullTextCatalogOption = (* IsAbstract = true *)
  | OnOffFullTextCatalogOption of OptionKind:ScriptDom.FullTextCatalogOptionKind * OptionState:ScriptDom.OptionState
  member this.ToCs() : ScriptDom.FullTextCatalogOption =
    match this with
    | OnOffFullTextCatalogOption(OptionKind=aOptionKind; OptionState=aOptionState) ->
      let ret = ScriptDom.OnOffFullTextCatalogOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret :> ScriptDom.FullTextCatalogOption (* 335 *)
  static member FromCs(src:ScriptDom.FullTextCatalogOption, fragmentMapping:FragmentMapping) : FullTextCatalogOption =
    let ret =
      match src with
      | :? ScriptDom.OnOffFullTextCatalogOption as src ->
        FullTextCatalogOption.OnOffFullTextCatalogOption((src.OptionKind),(src.OptionState))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] FullTextIndexOption = (* IsAbstract = true *)
  | ChangeTrackingFullTextIndexOption of OptionKind:ScriptDom.FullTextIndexOptionKind * Value:ScriptDom.ChangeTrackingOption
  | SearchPropertyListFullTextIndexOption of IsOff:bool * OptionKind:ScriptDom.FullTextIndexOptionKind * PropertyListName:Identifier option
  | StopListFullTextIndexOption of IsOff:bool * OptionKind:ScriptDom.FullTextIndexOptionKind * StopListName:Identifier option
  member this.ToCs() : ScriptDom.FullTextIndexOption =
    match this with
    | ChangeTrackingFullTextIndexOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.ChangeTrackingFullTextIndexOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.FullTextIndexOption (* 335 *)
    | SearchPropertyListFullTextIndexOption(IsOff=aIsOff; OptionKind=aOptionKind; PropertyListName=aPropertyListName) ->
      let ret = ScriptDom.SearchPropertyListFullTextIndexOption()
      ret.IsOff <- aIsOff
      ret.OptionKind <- aOptionKind
      ret.PropertyListName <- aPropertyListName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.FullTextIndexOption (* 335 *)
    | StopListFullTextIndexOption(IsOff=aIsOff; OptionKind=aOptionKind; StopListName=aStopListName) ->
      let ret = ScriptDom.StopListFullTextIndexOption()
      ret.IsOff <- aIsOff
      ret.OptionKind <- aOptionKind
      ret.StopListName <- aStopListName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.FullTextIndexOption (* 335 *)
  static member FromCs(src:ScriptDom.FullTextIndexOption, fragmentMapping:FragmentMapping) : FullTextIndexOption =
    let ret =
      match src with
      | :? ScriptDom.ChangeTrackingFullTextIndexOption as src ->
        FullTextIndexOption.ChangeTrackingFullTextIndexOption((src.OptionKind),(src.Value))
      | :? ScriptDom.SearchPropertyListFullTextIndexOption as src ->
        FullTextIndexOption.SearchPropertyListFullTextIndexOption((src.IsOff),(src.OptionKind),(src.PropertyListName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.StopListFullTextIndexOption as src ->
        FullTextIndexOption.StopListFullTextIndexOption((src.IsOff),(src.OptionKind),(src.StopListName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] FunctionOption = (* IsAbstract = false *)
  | Base of OptionKind:ScriptDom.FunctionOptionKind
  | ExecuteAsFunctionOption of ExecuteAs:ExecuteAsClause option * OptionKind:ScriptDom.FunctionOptionKind
  | InlineFunctionOption of OptionKind:ScriptDom.FunctionOptionKind * OptionState:ScriptDom.OptionState
  member this.ToCs() : ScriptDom.FunctionOption =
    match this with
    | ExecuteAsFunctionOption(ExecuteAs=aExecuteAs; OptionKind=aOptionKind) ->
      let ret = ScriptDom.ExecuteAsFunctionOption()
      ret.ExecuteAs <- aExecuteAs |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.FunctionOption (* 335 *)
    | InlineFunctionOption(OptionKind=aOptionKind; OptionState=aOptionState) ->
      let ret = ScriptDom.InlineFunctionOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret :> ScriptDom.FunctionOption (* 335 *)
    | Base(OptionKind=aOptionKind) ->

      let ret = ScriptDom.FunctionOption()
      ret.OptionKind <- aOptionKind
      ret
  static member FromCs(src:ScriptDom.FunctionOption, fragmentMapping:FragmentMapping) : FunctionOption =
    let ret =
      match src with
      | :? ScriptDom.ExecuteAsFunctionOption as src ->
        FunctionOption.ExecuteAsFunctionOption((src.ExecuteAs |> Option.ofObj |> Option.map (fun x -> ExecuteAsClause.FromCs(x, fragmentMapping))),(src.OptionKind))
      | :? ScriptDom.InlineFunctionOption as src ->
        FunctionOption.InlineFunctionOption((src.OptionKind),(src.OptionState))
      | _ -> (* :? ScriptDom.FunctionOption as src *)
        FunctionOption.Base(((src.OptionKind))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] FunctionReturnType = (* IsAbstract = true *)
  | ScalarFunctionReturnType of DataType:DataTypeReference option
  | SelectFunctionReturnType of SelectStatement:SelectStatement option
  | TableValuedFunctionReturnType of DeclareTableVariableBody:DeclareTableVariableBody option
  member this.ToCs() : ScriptDom.FunctionReturnType =
    match this with
    | ScalarFunctionReturnType(DataType=aDataType) ->
      let ret = ScriptDom.ScalarFunctionReturnType()
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.FunctionReturnType (* 335 *)
    | SelectFunctionReturnType(SelectStatement=aSelectStatement) ->
      let ret = ScriptDom.SelectFunctionReturnType()
      ret.SelectStatement <- aSelectStatement |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.FunctionReturnType (* 335 *)
    | TableValuedFunctionReturnType(DeclareTableVariableBody=aDeclareTableVariableBody) ->
      let ret = ScriptDom.TableValuedFunctionReturnType()
      ret.DeclareTableVariableBody <- aDeclareTableVariableBody |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.FunctionReturnType (* 335 *)
  static member FromCs(src:ScriptDom.FunctionReturnType, fragmentMapping:FragmentMapping) : FunctionReturnType =
    let ret =
      match src with
      | :? ScriptDom.ScalarFunctionReturnType as src ->
        FunctionReturnType.ScalarFunctionReturnType((src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))))
      | :? ScriptDom.SelectFunctionReturnType as src ->
        FunctionReturnType.SelectFunctionReturnType((src.SelectStatement |> Option.ofObj |> Option.map (fun x -> SelectStatement.FromCs(x, fragmentMapping))))
      | :? ScriptDom.TableValuedFunctionReturnType as src ->
        FunctionReturnType.TableValuedFunctionReturnType((src.DeclareTableVariableBody |> Option.ofObj |> Option.map (fun x -> DeclareTableVariableBody.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] GroupingSpecification = (* IsAbstract = true *)
  | CompositeGroupingSpecification of Items:(GroupingSpecification) list
  | CubeGroupingSpecification of Arguments:(GroupingSpecification) list
  | ExpressionGroupingSpecification of DistributedAggregation:bool * Expression:ScalarExpression option
  | GrandTotalGroupingSpecification 
  | GroupingSetsGroupingSpecification of Sets:(GroupingSpecification) list
  | RollupGroupingSpecification of Arguments:(GroupingSpecification) list
  member this.ToCs() : ScriptDom.GroupingSpecification =
    match this with
    | CompositeGroupingSpecification(Items=aItems) ->
      let ret = ScriptDom.CompositeGroupingSpecification()
      for e in aItems do ret.Items.Add (e.ToCs())
      ret :> ScriptDom.GroupingSpecification (* 335 *)
    | CubeGroupingSpecification(Arguments=aArguments) ->
      let ret = ScriptDom.CubeGroupingSpecification()
      for e in aArguments do ret.Arguments.Add (e.ToCs())
      ret :> ScriptDom.GroupingSpecification (* 335 *)
    | ExpressionGroupingSpecification(DistributedAggregation=aDistributedAggregation; Expression=aExpression) ->
      let ret = ScriptDom.ExpressionGroupingSpecification()
      ret.DistributedAggregation <- aDistributedAggregation
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.GroupingSpecification (* 335 *)
    | GrandTotalGroupingSpecification -> ScriptDom.GrandTotalGroupingSpecification() :> ScriptDom.GroupingSpecification (* 327 *)
    | GroupingSetsGroupingSpecification(Sets=aSets) ->
      let ret = ScriptDom.GroupingSetsGroupingSpecification()
      for e in aSets do ret.Sets.Add (e.ToCs())
      ret :> ScriptDom.GroupingSpecification (* 335 *)
    | RollupGroupingSpecification(Arguments=aArguments) ->
      let ret = ScriptDom.RollupGroupingSpecification()
      for e in aArguments do ret.Arguments.Add (e.ToCs())
      ret :> ScriptDom.GroupingSpecification (* 335 *)
  static member FromCs(src:ScriptDom.GroupingSpecification, fragmentMapping:FragmentMapping) : GroupingSpecification =
    let ret =
      match src with
      | :? ScriptDom.CompositeGroupingSpecification as src ->
        GroupingSpecification.CompositeGroupingSpecification((src.Items |> Seq.map (fun x -> GroupingSpecification.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.CubeGroupingSpecification as src ->
        GroupingSpecification.CubeGroupingSpecification((src.Arguments |> Seq.map (fun x -> GroupingSpecification.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.ExpressionGroupingSpecification as src ->
        GroupingSpecification.ExpressionGroupingSpecification((src.DistributedAggregation),(src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.GrandTotalGroupingSpecification as src ->
        GroupingSpecification.GrandTotalGroupingSpecification
      | :? ScriptDom.GroupingSetsGroupingSpecification as src ->
        GroupingSpecification.GroupingSetsGroupingSpecification((src.Sets |> Seq.map (fun x -> GroupingSpecification.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.RollupGroupingSpecification as src ->
        GroupingSpecification.RollupGroupingSpecification((src.Arguments |> Seq.map (fun x -> GroupingSpecification.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] Identifier = (* IsAbstract = false *)
  | Base of QuoteType:ScriptDom.QuoteType * Value:String option
  | IdentifierSnippet of QuoteType:ScriptDom.QuoteType * Script:String option * Value:String option
  | SqlCommandIdentifier of QuoteType:ScriptDom.QuoteType * Value:String option
  member this.ToCs() : ScriptDom.Identifier =
    match this with
    | IdentifierSnippet(QuoteType=aQuoteType; Script=aScript; Value=aValue) ->
      let ret = ScriptDom.IdentifierSnippet()
      ret.QuoteType <- aQuoteType
      ret.Script <- aScript |> Option.toObj
      ret.Value <- aValue |> Option.toObj
      ret :> ScriptDom.Identifier (* 335 *)
    | SqlCommandIdentifier(QuoteType=aQuoteType; Value=aValue) ->
      let ret = ScriptDom.SqlCommandIdentifier()
      ret.QuoteType <- aQuoteType
      ret.Value <- aValue |> Option.toObj
      ret :> ScriptDom.Identifier (* 335 *)
    | Base(QuoteType=aQuoteType; Value=aValue) ->

      let ret = ScriptDom.Identifier()
      ret.QuoteType <- aQuoteType
      ret.Value <- aValue |> Option.toObj
      ret
  static member FromCs(src:ScriptDom.Identifier, fragmentMapping:FragmentMapping) : Identifier =
    let ret =
      match src with
      | :? ScriptDom.IdentifierSnippet as src ->
        Identifier.IdentifierSnippet((src.QuoteType),(Option.ofObj (src.Script)),(Option.ofObj (src.Value)))
      | :? ScriptDom.SqlCommandIdentifier as src ->
        Identifier.SqlCommandIdentifier((src.QuoteType),(Option.ofObj (src.Value)))
      | _ -> (* :? ScriptDom.Identifier as src *)
        Identifier.Base(((src.QuoteType), (Option.ofObj (src.Value)))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] IndexOption = (* IsAbstract = true *)
  | CompressionDelayIndexOption of Expression:ScalarExpression option * OptionKind:ScriptDom.IndexOptionKind * TimeUnit:ScriptDom.CompressionDelayTimeUnit
  | DataCompressionOption of CompressionLevel:ScriptDom.DataCompressionLevel * OptionKind:ScriptDom.IndexOptionKind * PartitionRanges:(CompressionPartitionRange) list
  | FileStreamOnDropIndexOption of FileStreamOn:IdentifierOrValueExpression option * OptionKind:ScriptDom.IndexOptionKind
  | IndexExpressionOption of Expression:ScalarExpression option * OptionKind:ScriptDom.IndexOptionKind
  | IndexStateOption of IndexStateOption
  | MaxDurationOption of MaxDuration:Literal option * OptionKind:ScriptDom.IndexOptionKind * Unit:(ScriptDom.TimeUnit) option
  | MoveToDropIndexOption of MoveTo:FileGroupOrPartitionScheme option * OptionKind:ScriptDom.IndexOptionKind
  | OrderIndexOption of Columns:(ColumnReferenceExpression) list * OptionKind:ScriptDom.IndexOptionKind
  | WaitAtLowPriorityOption of OptionKind:ScriptDom.IndexOptionKind * Options:(LowPriorityLockWaitOption) list
  member this.ToCs() : ScriptDom.IndexOption =
    match this with
    | CompressionDelayIndexOption(Expression=aExpression; OptionKind=aOptionKind; TimeUnit=aTimeUnit) ->
      let ret = ScriptDom.CompressionDelayIndexOption()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret.TimeUnit <- aTimeUnit
      ret :> ScriptDom.IndexOption (* 335 *)
    | DataCompressionOption(CompressionLevel=aCompressionLevel; OptionKind=aOptionKind; PartitionRanges=aPartitionRanges) ->
      let ret = ScriptDom.DataCompressionOption()
      ret.CompressionLevel <- aCompressionLevel
      ret.OptionKind <- aOptionKind
      for e in aPartitionRanges do ret.PartitionRanges.Add (e.ToCs())
      ret :> ScriptDom.IndexOption (* 335 *)
    | FileStreamOnDropIndexOption(FileStreamOn=aFileStreamOn; OptionKind=aOptionKind) ->
      let ret = ScriptDom.FileStreamOnDropIndexOption()
      ret.FileStreamOn <- aFileStreamOn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.IndexOption (* 335 *)
    | IndexExpressionOption(Expression=aExpression; OptionKind=aOptionKind) ->
      let ret = ScriptDom.IndexExpressionOption()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.IndexOption (* 335 *)
    | IndexStateOption(x) -> x.ToCs() :> ScriptDom.IndexOption (* 345 *)
    | MaxDurationOption(MaxDuration=aMaxDuration; OptionKind=aOptionKind; Unit=aUnit) ->
      let ret = ScriptDom.MaxDurationOption()
      ret.MaxDuration <- aMaxDuration |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret.Unit <- Option.toNullable aUnit
      ret :> ScriptDom.IndexOption (* 335 *)
    | MoveToDropIndexOption(MoveTo=aMoveTo; OptionKind=aOptionKind) ->
      let ret = ScriptDom.MoveToDropIndexOption()
      ret.MoveTo <- aMoveTo |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.IndexOption (* 335 *)
    | OrderIndexOption(Columns=aColumns; OptionKind=aOptionKind) ->
      let ret = ScriptDom.OrderIndexOption()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.IndexOption (* 335 *)
    | WaitAtLowPriorityOption(OptionKind=aOptionKind; Options=aOptions) ->
      let ret = ScriptDom.WaitAtLowPriorityOption()
      ret.OptionKind <- aOptionKind
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.IndexOption (* 335 *)
  static member FromCs(src:ScriptDom.IndexOption, fragmentMapping:FragmentMapping) : IndexOption =
    let ret =
      match src with
      | :? ScriptDom.CompressionDelayIndexOption as src ->
        IndexOption.CompressionDelayIndexOption((src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.OptionKind),(src.TimeUnit))
      | :? ScriptDom.DataCompressionOption as src ->
        IndexOption.DataCompressionOption((src.CompressionLevel),(src.OptionKind),(src.PartitionRanges |> Seq.map (fun src -> CompressionPartitionRange.CompressionPartitionRange((src.From |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.To |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq))
      | :? ScriptDom.FileStreamOnDropIndexOption as src ->
        IndexOption.FileStreamOnDropIndexOption((src.FileStreamOn |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))),(src.OptionKind))
      | :? ScriptDom.IndexExpressionOption as src ->
        IndexOption.IndexExpressionOption((src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.OptionKind))
      | :? ScriptDom.IndexStateOption as src ->
        match src with
        | :? ScriptDom.IgnoreDupKeyIndexOption as src->
          IndexOption.IndexStateOption((IndexStateOption.IgnoreDupKeyIndexOption((src.OptionKind), (src.OptionState), (Option.ofNullable (src.SuppressMessagesOption)))  ))
        | :? ScriptDom.OnlineIndexOption as src->
          IndexOption.IndexStateOption((IndexStateOption.OnlineIndexOption((src.LowPriorityLockWaitOption |> Option.ofObj |> Option.map (fun x -> OnlineIndexLowPriorityLockWaitOption.FromCs(x, fragmentMapping))), (src.OptionKind), (src.OptionState))  ))
        | _ -> (* :? ScriptDom.IndexStateOption as src *)
          IndexOption.IndexStateOption((IndexStateOption.Base((src.OptionKind), (src.OptionState))))
      | :? ScriptDom.MaxDurationOption as src ->
        IndexOption.MaxDurationOption((src.MaxDuration |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.OptionKind),(Option.ofNullable (src.Unit)))
      | :? ScriptDom.MoveToDropIndexOption as src ->
        IndexOption.MoveToDropIndexOption((src.MoveTo |> Option.ofObj |> Option.map (fun x -> FileGroupOrPartitionScheme.FromCs(x, fragmentMapping))),(src.OptionKind))
      | :? ScriptDom.OrderIndexOption as src ->
        IndexOption.OrderIndexOption((src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.OptionKind))
      | :? ScriptDom.WaitAtLowPriorityOption as src ->
        IndexOption.WaitAtLowPriorityOption((src.OptionKind),(src.Options |> Seq.map (fun x -> LowPriorityLockWaitOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] InsertSource = (* IsAbstract = true *)
  | ExecuteInsertSource of Execute:ExecuteSpecification option
  | SelectInsertSource of Select:QueryExpression option
  | ValuesInsertSource of IsDefaultValues:bool * RowValues:(RowValue) list
  member this.ToCs() : ScriptDom.InsertSource =
    match this with
    | ExecuteInsertSource(Execute=aExecute) ->
      let ret = ScriptDom.ExecuteInsertSource()
      ret.Execute <- aExecute |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.InsertSource (* 335 *)
    | SelectInsertSource(Select=aSelect) ->
      let ret = ScriptDom.SelectInsertSource()
      ret.Select <- aSelect |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.InsertSource (* 335 *)
    | ValuesInsertSource(IsDefaultValues=aIsDefaultValues; RowValues=aRowValues) ->
      let ret = ScriptDom.ValuesInsertSource()
      ret.IsDefaultValues <- aIsDefaultValues
      for e in aRowValues do ret.RowValues.Add (e.ToCs())
      ret :> ScriptDom.InsertSource (* 335 *)
  static member FromCs(src:ScriptDom.InsertSource, fragmentMapping:FragmentMapping) : InsertSource =
    let ret =
      match src with
      | :? ScriptDom.ExecuteInsertSource as src ->
        InsertSource.ExecuteInsertSource((src.Execute |> Option.ofObj |> Option.map (fun x -> ExecuteSpecification.FromCs(x, fragmentMapping))))
      | :? ScriptDom.SelectInsertSource as src ->
        InsertSource.SelectInsertSource((src.Select |> Option.ofObj |> Option.map (fun x -> QueryExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ValuesInsertSource as src ->
        InsertSource.ValuesInsertSource((src.IsDefaultValues),(src.RowValues |> Seq.map (fun src -> RowValue.RowValue((src.ColumnValues |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq))) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] KeyOption = (* IsAbstract = true *)
  | AlgorithmKeyOption of Algorithm:ScriptDom.EncryptionAlgorithm * OptionKind:ScriptDom.KeyOptionKind
  | CreationDispositionKeyOption of IsCreateNew:bool * OptionKind:ScriptDom.KeyOptionKind
  | IdentityValueKeyOption of IdentityPhrase:Literal option * OptionKind:ScriptDom.KeyOptionKind
  | KeySourceKeyOption of OptionKind:ScriptDom.KeyOptionKind * PassPhrase:Literal option
  | ProviderKeyNameKeyOption of KeyName:Literal option * OptionKind:ScriptDom.KeyOptionKind
  member this.ToCs() : ScriptDom.KeyOption =
    match this with
    | AlgorithmKeyOption(Algorithm=aAlgorithm; OptionKind=aOptionKind) ->
      let ret = ScriptDom.AlgorithmKeyOption()
      ret.Algorithm <- aAlgorithm
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.KeyOption (* 335 *)
    | CreationDispositionKeyOption(IsCreateNew=aIsCreateNew; OptionKind=aOptionKind) ->
      let ret = ScriptDom.CreationDispositionKeyOption()
      ret.IsCreateNew <- aIsCreateNew
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.KeyOption (* 335 *)
    | IdentityValueKeyOption(IdentityPhrase=aIdentityPhrase; OptionKind=aOptionKind) ->
      let ret = ScriptDom.IdentityValueKeyOption()
      ret.IdentityPhrase <- aIdentityPhrase |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.KeyOption (* 335 *)
    | KeySourceKeyOption(OptionKind=aOptionKind; PassPhrase=aPassPhrase) ->
      let ret = ScriptDom.KeySourceKeyOption()
      ret.OptionKind <- aOptionKind
      ret.PassPhrase <- aPassPhrase |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.KeyOption (* 335 *)
    | ProviderKeyNameKeyOption(KeyName=aKeyName; OptionKind=aOptionKind) ->
      let ret = ScriptDom.ProviderKeyNameKeyOption()
      ret.KeyName <- aKeyName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.KeyOption (* 335 *)
  static member FromCs(src:ScriptDom.KeyOption, fragmentMapping:FragmentMapping) : KeyOption =
    let ret =
      match src with
      | :? ScriptDom.AlgorithmKeyOption as src ->
        KeyOption.AlgorithmKeyOption((src.Algorithm),(src.OptionKind))
      | :? ScriptDom.CreationDispositionKeyOption as src ->
        KeyOption.CreationDispositionKeyOption((src.IsCreateNew),(src.OptionKind))
      | :? ScriptDom.IdentityValueKeyOption as src ->
        KeyOption.IdentityValueKeyOption((src.IdentityPhrase |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.OptionKind))
      | :? ScriptDom.KeySourceKeyOption as src ->
        KeyOption.KeySourceKeyOption((src.OptionKind),(src.PassPhrase |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ProviderKeyNameKeyOption as src ->
        KeyOption.ProviderKeyNameKeyOption((src.KeyName |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.OptionKind))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] LiteralRange = (* IsAbstract = false *)
  | Base of From:Literal option * To:Literal option
  | ProcessAffinityRange of From:Literal option * To:Literal option
  member this.ToCs() : ScriptDom.LiteralRange =
    match this with
    | ProcessAffinityRange(From=aFrom; To=aTo) ->
      let ret = ScriptDom.ProcessAffinityRange()
      ret.From <- aFrom |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.To <- aTo |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.LiteralRange (* 335 *)
    | Base(From=aFrom; To=aTo) ->

      let ret = ScriptDom.LiteralRange()
      ret.From <- aFrom |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.To <- aTo |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret
  static member FromCs(src:ScriptDom.LiteralRange, fragmentMapping:FragmentMapping) : LiteralRange =
    let ret =
      match src with
      | :? ScriptDom.ProcessAffinityRange as src ->
        LiteralRange.ProcessAffinityRange((src.From |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.To |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | _ -> (* :? ScriptDom.LiteralRange as src *)
        LiteralRange.Base(((src.From |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.To |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] LowPriorityLockWaitOption = (* IsAbstract = true *)
  | LowPriorityLockWaitAbortAfterWaitOption of AbortAfterWait:ScriptDom.AbortAfterWaitType * OptionKind:ScriptDom.LowPriorityLockWaitOptionKind
  | LowPriorityLockWaitMaxDurationOption of MaxDuration:Literal option * OptionKind:ScriptDom.LowPriorityLockWaitOptionKind * Unit:(ScriptDom.TimeUnit) option
  member this.ToCs() : ScriptDom.LowPriorityLockWaitOption =
    match this with
    | LowPriorityLockWaitAbortAfterWaitOption(AbortAfterWait=aAbortAfterWait; OptionKind=aOptionKind) ->
      let ret = ScriptDom.LowPriorityLockWaitAbortAfterWaitOption()
      ret.AbortAfterWait <- aAbortAfterWait
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.LowPriorityLockWaitOption (* 335 *)
    | LowPriorityLockWaitMaxDurationOption(MaxDuration=aMaxDuration; OptionKind=aOptionKind; Unit=aUnit) ->
      let ret = ScriptDom.LowPriorityLockWaitMaxDurationOption()
      ret.MaxDuration <- aMaxDuration |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret.Unit <- Option.toNullable aUnit
      ret :> ScriptDom.LowPriorityLockWaitOption (* 335 *)
  static member FromCs(src:ScriptDom.LowPriorityLockWaitOption, fragmentMapping:FragmentMapping) : LowPriorityLockWaitOption =
    let ret =
      match src with
      | :? ScriptDom.LowPriorityLockWaitAbortAfterWaitOption as src ->
        LowPriorityLockWaitOption.LowPriorityLockWaitAbortAfterWaitOption((src.AbortAfterWait),(src.OptionKind))
      | :? ScriptDom.LowPriorityLockWaitMaxDurationOption as src ->
        LowPriorityLockWaitOption.LowPriorityLockWaitMaxDurationOption((src.MaxDuration |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.OptionKind),(Option.ofNullable (src.Unit)))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] MergeAction = (* IsAbstract = true *)
  | DeleteMergeAction 
  | InsertMergeAction of Columns:(ColumnReferenceExpression) list * Source:ValuesInsertSource option
  | UpdateMergeAction of SetClauses:(SetClause) list
  member this.ToCs() : ScriptDom.MergeAction =
    match this with
    | DeleteMergeAction -> ScriptDom.DeleteMergeAction() :> ScriptDom.MergeAction (* 327 *)
    | InsertMergeAction(Columns=aColumns; Source=aSource) ->
      let ret = ScriptDom.InsertMergeAction()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.Source <- aSource |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.MergeAction (* 335 *)
    | UpdateMergeAction(SetClauses=aSetClauses) ->
      let ret = ScriptDom.UpdateMergeAction()
      for e in aSetClauses do ret.SetClauses.Add (e.ToCs())
      ret :> ScriptDom.MergeAction (* 335 *)
  static member FromCs(src:ScriptDom.MergeAction, fragmentMapping:FragmentMapping) : MergeAction =
    let ret =
      match src with
      | :? ScriptDom.DeleteMergeAction as src ->
        MergeAction.DeleteMergeAction
      | :? ScriptDom.InsertMergeAction as src ->
        MergeAction.InsertMergeAction((src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.Source |> Option.ofObj |> Option.map (fun x -> ValuesInsertSource.FromCs(x, fragmentMapping))))
      | :? ScriptDom.UpdateMergeAction as src ->
        MergeAction.UpdateMergeAction((src.SetClauses |> Seq.map (fun x -> SetClause.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] MultiPartIdentifier = (* IsAbstract = false *)
  | Base of Count:Int32 * Identifiers:(Identifier) list
  | SchemaObjectName of SchemaObjectName
  member this.ToCs() : ScriptDom.MultiPartIdentifier =
    match this with
    | SchemaObjectName(x) -> x.ToCs() :> ScriptDom.MultiPartIdentifier (* 345 *)
    | Base(Count=aCount; Identifiers=aIdentifiers) ->

      let ret = ScriptDom.MultiPartIdentifier()
       // Skipping prop Count - it is Readonly
      for e in aIdentifiers do ret.Identifiers.Add (e.ToCs())
      ret
  static member FromCs(src:ScriptDom.MultiPartIdentifier, fragmentMapping:FragmentMapping) : MultiPartIdentifier =
    let ret =
      match src with
      | :? ScriptDom.SchemaObjectName as src ->
        match src with
        | :? ScriptDom.ChildObjectName as src->
          MultiPartIdentifier.SchemaObjectName((SchemaObjectName.ChildObjectName((src.BaseIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ChildIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Count), (src.DatabaseIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Identifiers |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.SchemaIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ServerIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.SchemaObjectNameSnippet as src->
          MultiPartIdentifier.SchemaObjectName((SchemaObjectName.SchemaObjectNameSnippet((src.BaseIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Count), (src.DatabaseIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Identifiers |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.SchemaIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (Option.ofObj (src.Script)), (src.ServerIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | _ -> (* :? ScriptDom.SchemaObjectName as src *)
          MultiPartIdentifier.SchemaObjectName((SchemaObjectName.Base((src.BaseIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Count), (src.DatabaseIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Identifiers |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.SchemaIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ServerIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))))
      | _ -> (* :? ScriptDom.MultiPartIdentifier as src *)
        MultiPartIdentifier.Base(((src.Count), (src.Identifiers |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] OptimizerHint = (* IsAbstract = false *)
  | Base of HintKind:ScriptDom.OptimizerHintKind
  | LiteralOptimizerHint of HintKind:ScriptDom.OptimizerHintKind * Value:Literal option
  | OptimizeForOptimizerHint of HintKind:ScriptDom.OptimizerHintKind * IsForUnknown:bool * Pairs:(VariableValuePair) list
  | TableHintsOptimizerHint of HintKind:ScriptDom.OptimizerHintKind * ObjectName:SchemaObjectName option * TableHints:(TableHint) list
  | UseHintList of HintKind:ScriptDom.OptimizerHintKind * Hints:(StringLiteral) list
  member this.ToCs() : ScriptDom.OptimizerHint =
    match this with
    | LiteralOptimizerHint(HintKind=aHintKind; Value=aValue) ->
      let ret = ScriptDom.LiteralOptimizerHint()
      ret.HintKind <- aHintKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.OptimizerHint (* 335 *)
    | OptimizeForOptimizerHint(HintKind=aHintKind; IsForUnknown=aIsForUnknown; Pairs=aPairs) ->
      let ret = ScriptDom.OptimizeForOptimizerHint()
      ret.HintKind <- aHintKind
      ret.IsForUnknown <- aIsForUnknown
      for e in aPairs do ret.Pairs.Add (e.ToCs())
      ret :> ScriptDom.OptimizerHint (* 335 *)
    | TableHintsOptimizerHint(HintKind=aHintKind; ObjectName=aObjectName; TableHints=aTableHints) ->
      let ret = ScriptDom.TableHintsOptimizerHint()
      ret.HintKind <- aHintKind
      ret.ObjectName <- aObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aTableHints do ret.TableHints.Add (e.ToCs())
      ret :> ScriptDom.OptimizerHint (* 335 *)
    | UseHintList(HintKind=aHintKind; Hints=aHints) ->
      let ret = ScriptDom.UseHintList()
      ret.HintKind <- aHintKind
      for e in aHints do ret.Hints.Add (e.ToCs())
      ret :> ScriptDom.OptimizerHint (* 335 *)
    | Base(HintKind=aHintKind) ->

      let ret = ScriptDom.OptimizerHint()
      ret.HintKind <- aHintKind
      ret
  static member FromCs(src:ScriptDom.OptimizerHint, fragmentMapping:FragmentMapping) : OptimizerHint =
    let ret =
      match src with
      | :? ScriptDom.LiteralOptimizerHint as src ->
        OptimizerHint.LiteralOptimizerHint((src.HintKind),(src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.OptimizeForOptimizerHint as src ->
        OptimizerHint.OptimizeForOptimizerHint((src.HintKind),(src.IsForUnknown),(src.Pairs |> Seq.map (fun src -> VariableValuePair.VariableValuePair((src.IsForUnknown), (src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.Variable |> Option.ofObj |> Option.map (fun x -> VariableReference.FromCs(x, fragmentMapping))))) |> List.ofSeq))
      | :? ScriptDom.TableHintsOptimizerHint as src ->
        OptimizerHint.TableHintsOptimizerHint((src.HintKind),(src.ObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.TableHints |> Seq.map (fun x -> TableHint.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.UseHintList as src ->
        OptimizerHint.UseHintList((src.HintKind),(src.Hints |> Seq.map (fun src -> StringLiteral.StringLiteral((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.IsLargeObject), (src.IsNational), (src.LiteralType), (Option.ofObj (src.Value)))) |> List.ofSeq))
      | _ -> (* :? ScriptDom.OptimizerHint as src *)
        OptimizerHint.Base(((src.HintKind))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] OptionValue = (* IsAbstract = true *)
  | LiteralOptionValue of Value:Literal option
  | OnOffOptionValue of OptionState:ScriptDom.OptionState
  member this.ToCs() : ScriptDom.OptionValue =
    match this with
    | LiteralOptionValue(Value=aValue) ->
      let ret = ScriptDom.LiteralOptionValue()
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.OptionValue (* 335 *)
    | OnOffOptionValue(OptionState=aOptionState) ->
      let ret = ScriptDom.OnOffOptionValue()
      ret.OptionState <- aOptionState
      ret :> ScriptDom.OptionValue (* 335 *)
  static member FromCs(src:ScriptDom.OptionValue, fragmentMapping:FragmentMapping) : OptionValue =
    let ret =
      match src with
      | :? ScriptDom.LiteralOptionValue as src ->
        OptionValue.LiteralOptionValue((src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.OnOffOptionValue as src ->
        OptionValue.OnOffOptionValue((src.OptionState))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] PartitionSpecifications = (* IsAbstract = true *)
  | TablePartitionOptionSpecifications of BoundaryValues:(ScalarExpression) list * Range:ScriptDom.PartitionTableOptionRange
  member this.ToCs() : ScriptDom.PartitionSpecifications =
    match this with
    | TablePartitionOptionSpecifications(BoundaryValues=aBoundaryValues; Range=aRange) ->
      let ret = ScriptDom.TablePartitionOptionSpecifications()
      for e in aBoundaryValues do ret.BoundaryValues.Add (e.ToCs())
      ret.Range <- aRange
      ret :> ScriptDom.PartitionSpecifications (* 335 *)
  static member FromCs(src:ScriptDom.PartitionSpecifications, fragmentMapping:FragmentMapping) : PartitionSpecifications =
    let ret =
      match src with
      | :? ScriptDom.TablePartitionOptionSpecifications as src ->
        PartitionSpecifications.TablePartitionOptionSpecifications((src.BoundaryValues |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Range))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] PayloadOption = (* IsAbstract = true *)
  | AuthenticationPayloadOption of Certificate:Identifier option * Kind:ScriptDom.PayloadOptionKinds * Protocol:ScriptDom.AuthenticationProtocol * TryCertificateFirst:bool
  | CharacterSetPayloadOption of IsSql:bool * Kind:ScriptDom.PayloadOptionKinds
  | EnabledDisabledPayloadOption of IsEnabled:bool * Kind:ScriptDom.PayloadOptionKinds
  | EncryptionPayloadOption of AlgorithmPartOne:ScriptDom.EncryptionAlgorithmPreference * AlgorithmPartTwo:ScriptDom.EncryptionAlgorithmPreference * EncryptionSupport:ScriptDom.EndpointEncryptionSupport * Kind:ScriptDom.PayloadOptionKinds
  | LiteralPayloadOption of Kind:ScriptDom.PayloadOptionKinds * Value:Literal option
  | LoginTypePayloadOption of IsWindows:bool * Kind:ScriptDom.PayloadOptionKinds
  | RolePayloadOption of Kind:ScriptDom.PayloadOptionKinds * Role:ScriptDom.DatabaseMirroringEndpointRole
  | SchemaPayloadOption of IsStandard:bool * Kind:ScriptDom.PayloadOptionKinds
  | SessionTimeoutPayloadOption of IsNever:bool * Kind:ScriptDom.PayloadOptionKinds * Timeout:Literal option
  | SoapMethod of Action:ScriptDom.SoapMethodAction * Alias:Literal option * Format:ScriptDom.SoapMethodFormat * Kind:ScriptDom.PayloadOptionKinds * Name:Literal option * Namespace:Literal option * Schema:ScriptDom.SoapMethodSchemas
  | WsdlPayloadOption of IsNone:bool * Kind:ScriptDom.PayloadOptionKinds * Value:Literal option
  member this.ToCs() : ScriptDom.PayloadOption =
    match this with
    | AuthenticationPayloadOption(Certificate=aCertificate; Kind=aKind; Protocol=aProtocol; TryCertificateFirst=aTryCertificateFirst) ->
      let ret = ScriptDom.AuthenticationPayloadOption()
      ret.Certificate <- aCertificate |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Kind <- aKind
      ret.Protocol <- aProtocol
      ret.TryCertificateFirst <- aTryCertificateFirst
      ret :> ScriptDom.PayloadOption (* 335 *)
    | CharacterSetPayloadOption(IsSql=aIsSql; Kind=aKind) ->
      let ret = ScriptDom.CharacterSetPayloadOption()
      ret.IsSql <- aIsSql
      ret.Kind <- aKind
      ret :> ScriptDom.PayloadOption (* 335 *)
    | EnabledDisabledPayloadOption(IsEnabled=aIsEnabled; Kind=aKind) ->
      let ret = ScriptDom.EnabledDisabledPayloadOption()
      ret.IsEnabled <- aIsEnabled
      ret.Kind <- aKind
      ret :> ScriptDom.PayloadOption (* 335 *)
    | EncryptionPayloadOption(AlgorithmPartOne=aAlgorithmPartOne; AlgorithmPartTwo=aAlgorithmPartTwo; EncryptionSupport=aEncryptionSupport; Kind=aKind) ->
      let ret = ScriptDom.EncryptionPayloadOption()
      ret.AlgorithmPartOne <- aAlgorithmPartOne
      ret.AlgorithmPartTwo <- aAlgorithmPartTwo
      ret.EncryptionSupport <- aEncryptionSupport
      ret.Kind <- aKind
      ret :> ScriptDom.PayloadOption (* 335 *)
    | LiteralPayloadOption(Kind=aKind; Value=aValue) ->
      let ret = ScriptDom.LiteralPayloadOption()
      ret.Kind <- aKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PayloadOption (* 335 *)
    | LoginTypePayloadOption(IsWindows=aIsWindows; Kind=aKind) ->
      let ret = ScriptDom.LoginTypePayloadOption()
      ret.IsWindows <- aIsWindows
      ret.Kind <- aKind
      ret :> ScriptDom.PayloadOption (* 335 *)
    | RolePayloadOption(Kind=aKind; Role=aRole) ->
      let ret = ScriptDom.RolePayloadOption()
      ret.Kind <- aKind
      ret.Role <- aRole
      ret :> ScriptDom.PayloadOption (* 335 *)
    | SchemaPayloadOption(IsStandard=aIsStandard; Kind=aKind) ->
      let ret = ScriptDom.SchemaPayloadOption()
      ret.IsStandard <- aIsStandard
      ret.Kind <- aKind
      ret :> ScriptDom.PayloadOption (* 335 *)
    | SessionTimeoutPayloadOption(IsNever=aIsNever; Kind=aKind; Timeout=aTimeout) ->
      let ret = ScriptDom.SessionTimeoutPayloadOption()
      ret.IsNever <- aIsNever
      ret.Kind <- aKind
      ret.Timeout <- aTimeout |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PayloadOption (* 335 *)
    | SoapMethod(Action=aAction; Alias=aAlias; Format=aFormat; Kind=aKind; Name=aName; Namespace=aNamespace; Schema=aSchema) ->
      let ret = ScriptDom.SoapMethod()
      ret.Action <- aAction
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Format <- aFormat
      ret.Kind <- aKind
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Namespace <- aNamespace |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Schema <- aSchema
      ret :> ScriptDom.PayloadOption (* 335 *)
    | WsdlPayloadOption(IsNone=aIsNone; Kind=aKind; Value=aValue) ->
      let ret = ScriptDom.WsdlPayloadOption()
      ret.IsNone <- aIsNone
      ret.Kind <- aKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PayloadOption (* 335 *)
  static member FromCs(src:ScriptDom.PayloadOption, fragmentMapping:FragmentMapping) : PayloadOption =
    let ret =
      match src with
      | :? ScriptDom.AuthenticationPayloadOption as src ->
        PayloadOption.AuthenticationPayloadOption((src.Certificate |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Kind),(src.Protocol),(src.TryCertificateFirst))
      | :? ScriptDom.CharacterSetPayloadOption as src ->
        PayloadOption.CharacterSetPayloadOption((src.IsSql),(src.Kind))
      | :? ScriptDom.EnabledDisabledPayloadOption as src ->
        PayloadOption.EnabledDisabledPayloadOption((src.IsEnabled),(src.Kind))
      | :? ScriptDom.EncryptionPayloadOption as src ->
        PayloadOption.EncryptionPayloadOption((src.AlgorithmPartOne),(src.AlgorithmPartTwo),(src.EncryptionSupport),(src.Kind))
      | :? ScriptDom.LiteralPayloadOption as src ->
        PayloadOption.LiteralPayloadOption((src.Kind),(src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.LoginTypePayloadOption as src ->
        PayloadOption.LoginTypePayloadOption((src.IsWindows),(src.Kind))
      | :? ScriptDom.RolePayloadOption as src ->
        PayloadOption.RolePayloadOption((src.Kind),(src.Role))
      | :? ScriptDom.SchemaPayloadOption as src ->
        PayloadOption.SchemaPayloadOption((src.IsStandard),(src.Kind))
      | :? ScriptDom.SessionTimeoutPayloadOption as src ->
        PayloadOption.SessionTimeoutPayloadOption((src.IsNever),(src.Kind),(src.Timeout |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.SoapMethod as src ->
        PayloadOption.SoapMethod((src.Action),(src.Alias |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.Format),(src.Kind),(src.Name |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.Namespace |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.Schema))
      | :? ScriptDom.WsdlPayloadOption as src ->
        PayloadOption.WsdlPayloadOption((src.IsNone),(src.Kind),(src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] PrincipalOption = (* IsAbstract = false *)
  | Base of OptionKind:ScriptDom.PrincipalOptionKind
  | IdentifierPrincipalOption of Identifier:Identifier option * OptionKind:ScriptDom.PrincipalOptionKind
  | LiteralPrincipalOption of OptionKind:ScriptDom.PrincipalOptionKind * Value:Literal option
  | OnOffPrincipalOption of OptionKind:ScriptDom.PrincipalOptionKind * OptionState:ScriptDom.OptionState
  | PasswordAlterPrincipalOption of Hashed:bool * MustChange:bool * OldPassword:Literal option * OptionKind:ScriptDom.PrincipalOptionKind * Password:Literal option * Unlock:bool
  member this.ToCs() : ScriptDom.PrincipalOption =
    match this with
    | IdentifierPrincipalOption(Identifier=aIdentifier; OptionKind=aOptionKind) ->
      let ret = ScriptDom.IdentifierPrincipalOption()
      ret.Identifier <- aIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.PrincipalOption (* 335 *)
    | LiteralPrincipalOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.LiteralPrincipalOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PrincipalOption (* 335 *)
    | OnOffPrincipalOption(OptionKind=aOptionKind; OptionState=aOptionState) ->
      let ret = ScriptDom.OnOffPrincipalOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret :> ScriptDom.PrincipalOption (* 335 *)
    | PasswordAlterPrincipalOption(Hashed=aHashed; MustChange=aMustChange; OldPassword=aOldPassword; OptionKind=aOptionKind; Password=aPassword; Unlock=aUnlock) ->
      let ret = ScriptDom.PasswordAlterPrincipalOption()
      ret.Hashed <- aHashed
      ret.MustChange <- aMustChange
      ret.OldPassword <- aOldPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret.Password <- aPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Unlock <- aUnlock
      ret :> ScriptDom.PrincipalOption (* 335 *)
    | Base(OptionKind=aOptionKind) ->

      let ret = ScriptDom.PrincipalOption()
      ret.OptionKind <- aOptionKind
      ret
  static member FromCs(src:ScriptDom.PrincipalOption, fragmentMapping:FragmentMapping) : PrincipalOption =
    let ret =
      match src with
      | :? ScriptDom.IdentifierPrincipalOption as src ->
        PrincipalOption.IdentifierPrincipalOption((src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.OptionKind))
      | :? ScriptDom.LiteralPrincipalOption as src ->
        PrincipalOption.LiteralPrincipalOption((src.OptionKind),(src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.OnOffPrincipalOption as src ->
        PrincipalOption.OnOffPrincipalOption((src.OptionKind),(src.OptionState))
      | :? ScriptDom.PasswordAlterPrincipalOption as src ->
        PrincipalOption.PasswordAlterPrincipalOption((src.Hashed),(src.MustChange),(src.OldPassword |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.OptionKind),(src.Password |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.Unlock))
      | _ -> (* :? ScriptDom.PrincipalOption as src *)
        PrincipalOption.Base(((src.OptionKind))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ProcedureOption = (* IsAbstract = false *)
  | Base of OptionKind:ScriptDom.ProcedureOptionKind
  | ExecuteAsProcedureOption of ExecuteAs:ExecuteAsClause option * OptionKind:ScriptDom.ProcedureOptionKind
  member this.ToCs() : ScriptDom.ProcedureOption =
    match this with
    | ExecuteAsProcedureOption(ExecuteAs=aExecuteAs; OptionKind=aOptionKind) ->
      let ret = ScriptDom.ExecuteAsProcedureOption()
      ret.ExecuteAs <- aExecuteAs |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.ProcedureOption (* 335 *)
    | Base(OptionKind=aOptionKind) ->

      let ret = ScriptDom.ProcedureOption()
      ret.OptionKind <- aOptionKind
      ret
  static member FromCs(src:ScriptDom.ProcedureOption, fragmentMapping:FragmentMapping) : ProcedureOption =
    let ret =
      match src with
      | :? ScriptDom.ExecuteAsProcedureOption as src ->
        ProcedureOption.ExecuteAsProcedureOption((src.ExecuteAs |> Option.ofObj |> Option.map (fun x -> ExecuteAsClause.FromCs(x, fragmentMapping))),(src.OptionKind))
      | _ -> (* :? ScriptDom.ProcedureOption as src *)
        ProcedureOption.Base(((src.OptionKind))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] QueryExpression = (* IsAbstract = true *)
  | BinaryQueryExpression of All:bool * BinaryQueryExpressionType:ScriptDom.BinaryQueryExpressionType * FirstQueryExpression:QueryExpression option * ForClause:ForClause option * OffsetClause:OffsetClause option * OrderByClause:OrderByClause option * SecondQueryExpression:QueryExpression option
  | QueryParenthesisExpression of ForClause:ForClause option * OffsetClause:OffsetClause option * OrderByClause:OrderByClause option * QueryExpression:QueryExpression option
  | QuerySpecification of ForClause:ForClause option * FromClause:FromClause option * GroupByClause:GroupByClause option * HavingClause:HavingClause option * OffsetClause:OffsetClause option * OrderByClause:OrderByClause option * SelectElements:(SelectElement) list * TopRowFilter:TopRowFilter option * UniqueRowFilter:ScriptDom.UniqueRowFilter * WhereClause:WhereClause option
  member this.ToCs() : ScriptDom.QueryExpression =
    match this with
    | BinaryQueryExpression(All=aAll; BinaryQueryExpressionType=aBinaryQueryExpressionType; FirstQueryExpression=aFirstQueryExpression; ForClause=aForClause; OffsetClause=aOffsetClause; OrderByClause=aOrderByClause; SecondQueryExpression=aSecondQueryExpression) ->
      let ret = ScriptDom.BinaryQueryExpression()
      ret.All <- aAll
      ret.BinaryQueryExpressionType <- aBinaryQueryExpressionType
      ret.FirstQueryExpression <- aFirstQueryExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ForClause <- aForClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OffsetClause <- aOffsetClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OrderByClause <- aOrderByClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SecondQueryExpression <- aSecondQueryExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.QueryExpression (* 335 *)
    | QueryParenthesisExpression(ForClause=aForClause; OffsetClause=aOffsetClause; OrderByClause=aOrderByClause; QueryExpression=aQueryExpression) ->
      let ret = ScriptDom.QueryParenthesisExpression()
      ret.ForClause <- aForClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OffsetClause <- aOffsetClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OrderByClause <- aOrderByClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.QueryExpression <- aQueryExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.QueryExpression (* 335 *)
    | QuerySpecification(ForClause=aForClause; FromClause=aFromClause; GroupByClause=aGroupByClause; HavingClause=aHavingClause; OffsetClause=aOffsetClause; OrderByClause=aOrderByClause; SelectElements=aSelectElements; TopRowFilter=aTopRowFilter; UniqueRowFilter=aUniqueRowFilter; WhereClause=aWhereClause) ->
      let ret = ScriptDom.QuerySpecification()
      ret.ForClause <- aForClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FromClause <- aFromClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.GroupByClause <- aGroupByClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.HavingClause <- aHavingClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OffsetClause <- aOffsetClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OrderByClause <- aOrderByClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aSelectElements do ret.SelectElements.Add (e.ToCs())
      ret.TopRowFilter <- aTopRowFilter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UniqueRowFilter <- aUniqueRowFilter
      ret.WhereClause <- aWhereClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.QueryExpression (* 335 *)
  static member FromCs(src:ScriptDom.QueryExpression, fragmentMapping:FragmentMapping) : QueryExpression =
    let ret =
      match src with
      | :? ScriptDom.BinaryQueryExpression as src ->
        QueryExpression.BinaryQueryExpression((src.All),(src.BinaryQueryExpressionType),(src.FirstQueryExpression |> Option.ofObj |> Option.map (fun x -> QueryExpression.FromCs(x, fragmentMapping))),(src.ForClause |> Option.ofObj |> Option.map (fun x -> ForClause.FromCs(x, fragmentMapping))),(src.OffsetClause |> Option.ofObj |> Option.map (fun x -> OffsetClause.FromCs(x, fragmentMapping))),(src.OrderByClause |> Option.ofObj |> Option.map (fun x -> OrderByClause.FromCs(x, fragmentMapping))),(src.SecondQueryExpression |> Option.ofObj |> Option.map (fun x -> QueryExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.QueryParenthesisExpression as src ->
        QueryExpression.QueryParenthesisExpression((src.ForClause |> Option.ofObj |> Option.map (fun x -> ForClause.FromCs(x, fragmentMapping))),(src.OffsetClause |> Option.ofObj |> Option.map (fun x -> OffsetClause.FromCs(x, fragmentMapping))),(src.OrderByClause |> Option.ofObj |> Option.map (fun x -> OrderByClause.FromCs(x, fragmentMapping))),(src.QueryExpression |> Option.ofObj |> Option.map (fun x -> QueryExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.QuerySpecification as src ->
        QueryExpression.QuerySpecification((src.ForClause |> Option.ofObj |> Option.map (fun x -> ForClause.FromCs(x, fragmentMapping))),(src.FromClause |> Option.ofObj |> Option.map (fun x -> FromClause.FromCs(x, fragmentMapping))),(src.GroupByClause |> Option.ofObj |> Option.map (fun x -> GroupByClause.FromCs(x, fragmentMapping))),(src.HavingClause |> Option.ofObj |> Option.map (fun x -> HavingClause.FromCs(x, fragmentMapping))),(src.OffsetClause |> Option.ofObj |> Option.map (fun x -> OffsetClause.FromCs(x, fragmentMapping))),(src.OrderByClause |> Option.ofObj |> Option.map (fun x -> OrderByClause.FromCs(x, fragmentMapping))),(src.SelectElements |> Seq.map (fun x -> SelectElement.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.TopRowFilter |> Option.ofObj |> Option.map (fun x -> TopRowFilter.FromCs(x, fragmentMapping))),(src.UniqueRowFilter),(src.WhereClause |> Option.ofObj |> Option.map (fun x -> WhereClause.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] QueryStoreOption = (* IsAbstract = true *)
  | QueryStoreCapturePolicyOption of OptionKind:ScriptDom.QueryStoreOptionKind * Value:ScriptDom.QueryStoreCapturePolicyOptionKind
  | QueryStoreDataFlushIntervalOption of FlushInterval:Literal option * OptionKind:ScriptDom.QueryStoreOptionKind
  | QueryStoreDesiredStateOption of OperationModeSpecified:bool * OptionKind:ScriptDom.QueryStoreOptionKind * Value:ScriptDom.QueryStoreDesiredStateOptionKind
  | QueryStoreIntervalLengthOption of OptionKind:ScriptDom.QueryStoreOptionKind * StatsIntervalLength:Literal option
  | QueryStoreMaxPlansPerQueryOption of MaxPlansPerQuery:Literal option * OptionKind:ScriptDom.QueryStoreOptionKind
  | QueryStoreMaxStorageSizeOption of MaxQdsSize:Literal option * OptionKind:ScriptDom.QueryStoreOptionKind
  | QueryStoreSizeCleanupPolicyOption of OptionKind:ScriptDom.QueryStoreOptionKind * Value:ScriptDom.QueryStoreSizeCleanupPolicyOptionKind
  | QueryStoreTimeCleanupPolicyOption of OptionKind:ScriptDom.QueryStoreOptionKind * StaleQueryThreshold:Literal option
  member this.ToCs() : ScriptDom.QueryStoreOption =
    match this with
    | QueryStoreCapturePolicyOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.QueryStoreCapturePolicyOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.QueryStoreOption (* 335 *)
    | QueryStoreDataFlushIntervalOption(FlushInterval=aFlushInterval; OptionKind=aOptionKind) ->
      let ret = ScriptDom.QueryStoreDataFlushIntervalOption()
      ret.FlushInterval <- aFlushInterval |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.QueryStoreOption (* 335 *)
    | QueryStoreDesiredStateOption(OperationModeSpecified=aOperationModeSpecified; OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.QueryStoreDesiredStateOption()
      ret.OperationModeSpecified <- aOperationModeSpecified
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.QueryStoreOption (* 335 *)
    | QueryStoreIntervalLengthOption(OptionKind=aOptionKind; StatsIntervalLength=aStatsIntervalLength) ->
      let ret = ScriptDom.QueryStoreIntervalLengthOption()
      ret.OptionKind <- aOptionKind
      ret.StatsIntervalLength <- aStatsIntervalLength |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.QueryStoreOption (* 335 *)
    | QueryStoreMaxPlansPerQueryOption(MaxPlansPerQuery=aMaxPlansPerQuery; OptionKind=aOptionKind) ->
      let ret = ScriptDom.QueryStoreMaxPlansPerQueryOption()
      ret.MaxPlansPerQuery <- aMaxPlansPerQuery |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.QueryStoreOption (* 335 *)
    | QueryStoreMaxStorageSizeOption(MaxQdsSize=aMaxQdsSize; OptionKind=aOptionKind) ->
      let ret = ScriptDom.QueryStoreMaxStorageSizeOption()
      ret.MaxQdsSize <- aMaxQdsSize |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.QueryStoreOption (* 335 *)
    | QueryStoreSizeCleanupPolicyOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.QueryStoreSizeCleanupPolicyOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.QueryStoreOption (* 335 *)
    | QueryStoreTimeCleanupPolicyOption(OptionKind=aOptionKind; StaleQueryThreshold=aStaleQueryThreshold) ->
      let ret = ScriptDom.QueryStoreTimeCleanupPolicyOption()
      ret.OptionKind <- aOptionKind
      ret.StaleQueryThreshold <- aStaleQueryThreshold |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.QueryStoreOption (* 335 *)
  static member FromCs(src:ScriptDom.QueryStoreOption, fragmentMapping:FragmentMapping) : QueryStoreOption =
    let ret =
      match src with
      | :? ScriptDom.QueryStoreCapturePolicyOption as src ->
        QueryStoreOption.QueryStoreCapturePolicyOption((src.OptionKind),(src.Value))
      | :? ScriptDom.QueryStoreDataFlushIntervalOption as src ->
        QueryStoreOption.QueryStoreDataFlushIntervalOption((src.FlushInterval |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.OptionKind))
      | :? ScriptDom.QueryStoreDesiredStateOption as src ->
        QueryStoreOption.QueryStoreDesiredStateOption((src.OperationModeSpecified),(src.OptionKind),(src.Value))
      | :? ScriptDom.QueryStoreIntervalLengthOption as src ->
        QueryStoreOption.QueryStoreIntervalLengthOption((src.OptionKind),(src.StatsIntervalLength |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.QueryStoreMaxPlansPerQueryOption as src ->
        QueryStoreOption.QueryStoreMaxPlansPerQueryOption((src.MaxPlansPerQuery |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.OptionKind))
      | :? ScriptDom.QueryStoreMaxStorageSizeOption as src ->
        QueryStoreOption.QueryStoreMaxStorageSizeOption((src.MaxQdsSize |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.OptionKind))
      | :? ScriptDom.QueryStoreSizeCleanupPolicyOption as src ->
        QueryStoreOption.QueryStoreSizeCleanupPolicyOption((src.OptionKind),(src.Value))
      | :? ScriptDom.QueryStoreTimeCleanupPolicyOption as src ->
        QueryStoreOption.QueryStoreTimeCleanupPolicyOption((src.OptionKind),(src.StaleQueryThreshold |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] QueueOption = (* IsAbstract = false *)
  | Base of OptionKind:ScriptDom.QueueOptionKind
  | QueueExecuteAsOption of OptionKind:ScriptDom.QueueOptionKind * OptionValue:ExecuteAsClause option
  | QueueProcedureOption of OptionKind:ScriptDom.QueueOptionKind * OptionValue:SchemaObjectName option
  | QueueStateOption of OptionKind:ScriptDom.QueueOptionKind * OptionState:ScriptDom.OptionState
  | QueueValueOption of OptionKind:ScriptDom.QueueOptionKind * OptionValue:ValueExpression option
  member this.ToCs() : ScriptDom.QueueOption =
    match this with
    | QueueExecuteAsOption(OptionKind=aOptionKind; OptionValue=aOptionValue) ->
      let ret = ScriptDom.QueueExecuteAsOption()
      ret.OptionKind <- aOptionKind
      ret.OptionValue <- aOptionValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.QueueOption (* 335 *)
    | QueueProcedureOption(OptionKind=aOptionKind; OptionValue=aOptionValue) ->
      let ret = ScriptDom.QueueProcedureOption()
      ret.OptionKind <- aOptionKind
      ret.OptionValue <- aOptionValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.QueueOption (* 335 *)
    | QueueStateOption(OptionKind=aOptionKind; OptionState=aOptionState) ->
      let ret = ScriptDom.QueueStateOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret :> ScriptDom.QueueOption (* 335 *)
    | QueueValueOption(OptionKind=aOptionKind; OptionValue=aOptionValue) ->
      let ret = ScriptDom.QueueValueOption()
      ret.OptionKind <- aOptionKind
      ret.OptionValue <- aOptionValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.QueueOption (* 335 *)
    | Base(OptionKind=aOptionKind) ->

      let ret = ScriptDom.QueueOption()
      ret.OptionKind <- aOptionKind
      ret
  static member FromCs(src:ScriptDom.QueueOption, fragmentMapping:FragmentMapping) : QueueOption =
    let ret =
      match src with
      | :? ScriptDom.QueueExecuteAsOption as src ->
        QueueOption.QueueExecuteAsOption((src.OptionKind),(src.OptionValue |> Option.ofObj |> Option.map (fun x -> ExecuteAsClause.FromCs(x, fragmentMapping))))
      | :? ScriptDom.QueueProcedureOption as src ->
        QueueOption.QueueProcedureOption((src.OptionKind),(src.OptionValue |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.QueueStateOption as src ->
        QueueOption.QueueStateOption((src.OptionKind),(src.OptionState))
      | :? ScriptDom.QueueValueOption as src ->
        QueueOption.QueueValueOption((src.OptionKind),(src.OptionValue |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))
      | _ -> (* :? ScriptDom.QueueOption as src *)
        QueueOption.Base(((src.OptionKind))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] RemoteDataArchiveDatabaseSetting = (* IsAbstract = true *)
  | RemoteDataArchiveDbCredentialSetting of Credential:Identifier option * SettingKind:ScriptDom.RemoteDataArchiveDatabaseSettingKind
  | RemoteDataArchiveDbFederatedServiceAccountSetting of IsOn:bool * SettingKind:ScriptDom.RemoteDataArchiveDatabaseSettingKind
  | RemoteDataArchiveDbServerSetting of Server:StringLiteral option * SettingKind:ScriptDom.RemoteDataArchiveDatabaseSettingKind
  member this.ToCs() : ScriptDom.RemoteDataArchiveDatabaseSetting =
    match this with
    | RemoteDataArchiveDbCredentialSetting(Credential=aCredential; SettingKind=aSettingKind) ->
      let ret = ScriptDom.RemoteDataArchiveDbCredentialSetting()
      ret.Credential <- aCredential |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SettingKind <- aSettingKind
      ret :> ScriptDom.RemoteDataArchiveDatabaseSetting (* 335 *)
    | RemoteDataArchiveDbFederatedServiceAccountSetting(IsOn=aIsOn; SettingKind=aSettingKind) ->
      let ret = ScriptDom.RemoteDataArchiveDbFederatedServiceAccountSetting()
      ret.IsOn <- aIsOn
      ret.SettingKind <- aSettingKind
      ret :> ScriptDom.RemoteDataArchiveDatabaseSetting (* 335 *)
    | RemoteDataArchiveDbServerSetting(Server=aServer; SettingKind=aSettingKind) ->
      let ret = ScriptDom.RemoteDataArchiveDbServerSetting()
      ret.Server <- aServer |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SettingKind <- aSettingKind
      ret :> ScriptDom.RemoteDataArchiveDatabaseSetting (* 335 *)
  static member FromCs(src:ScriptDom.RemoteDataArchiveDatabaseSetting, fragmentMapping:FragmentMapping) : RemoteDataArchiveDatabaseSetting =
    let ret =
      match src with
      | :? ScriptDom.RemoteDataArchiveDbCredentialSetting as src ->
        RemoteDataArchiveDatabaseSetting.RemoteDataArchiveDbCredentialSetting((src.Credential |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.SettingKind))
      | :? ScriptDom.RemoteDataArchiveDbFederatedServiceAccountSetting as src ->
        RemoteDataArchiveDatabaseSetting.RemoteDataArchiveDbFederatedServiceAccountSetting((src.IsOn),(src.SettingKind))
      | :? ScriptDom.RemoteDataArchiveDbServerSetting as src ->
        RemoteDataArchiveDatabaseSetting.RemoteDataArchiveDbServerSetting((src.Server |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))),(src.SettingKind))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] RemoteServiceBindingOption = (* IsAbstract = true *)
  | OnOffRemoteServiceBindingOption of OptionKind:ScriptDom.RemoteServiceBindingOptionKind * OptionState:ScriptDom.OptionState
  | UserRemoteServiceBindingOption of OptionKind:ScriptDom.RemoteServiceBindingOptionKind * User:Identifier option
  member this.ToCs() : ScriptDom.RemoteServiceBindingOption =
    match this with
    | OnOffRemoteServiceBindingOption(OptionKind=aOptionKind; OptionState=aOptionState) ->
      let ret = ScriptDom.OnOffRemoteServiceBindingOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret :> ScriptDom.RemoteServiceBindingOption (* 335 *)
    | UserRemoteServiceBindingOption(OptionKind=aOptionKind; User=aUser) ->
      let ret = ScriptDom.UserRemoteServiceBindingOption()
      ret.OptionKind <- aOptionKind
      ret.User <- aUser |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.RemoteServiceBindingOption (* 335 *)
  static member FromCs(src:ScriptDom.RemoteServiceBindingOption, fragmentMapping:FragmentMapping) : RemoteServiceBindingOption =
    let ret =
      match src with
      | :? ScriptDom.OnOffRemoteServiceBindingOption as src ->
        RemoteServiceBindingOption.OnOffRemoteServiceBindingOption((src.OptionKind),(src.OptionState))
      | :? ScriptDom.UserRemoteServiceBindingOption as src ->
        RemoteServiceBindingOption.UserRemoteServiceBindingOption((src.OptionKind),(src.User |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] RestoreOption = (* IsAbstract = false *)
  | Base of OptionKind:ScriptDom.RestoreOptionKind
  | FileStreamRestoreOption of FileStreamOption:FileStreamDatabaseOption option * OptionKind:ScriptDom.RestoreOptionKind
  | MoveRestoreOption of LogicalFileName:ValueExpression option * OSFileName:ValueExpression option * OptionKind:ScriptDom.RestoreOptionKind
  | ScalarExpressionRestoreOption of OptionKind:ScriptDom.RestoreOptionKind * Value:ScalarExpression option
  | StopRestoreOption of After:ValueExpression option * IsStopAt:bool * Mark:ValueExpression option * OptionKind:ScriptDom.RestoreOptionKind
  member this.ToCs() : ScriptDom.RestoreOption =
    match this with
    | FileStreamRestoreOption(FileStreamOption=aFileStreamOption; OptionKind=aOptionKind) ->
      let ret = ScriptDom.FileStreamRestoreOption()
      ret.FileStreamOption <- aFileStreamOption |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.RestoreOption (* 335 *)
    | MoveRestoreOption(LogicalFileName=aLogicalFileName; OSFileName=aOSFileName; OptionKind=aOptionKind) ->
      let ret = ScriptDom.MoveRestoreOption()
      ret.LogicalFileName <- aLogicalFileName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OSFileName <- aOSFileName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.RestoreOption (* 335 *)
    | ScalarExpressionRestoreOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.ScalarExpressionRestoreOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.RestoreOption (* 335 *)
    | StopRestoreOption(After=aAfter; IsStopAt=aIsStopAt; Mark=aMark; OptionKind=aOptionKind) ->
      let ret = ScriptDom.StopRestoreOption()
      ret.After <- aAfter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsStopAt <- aIsStopAt
      ret.Mark <- aMark |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.RestoreOption (* 335 *)
    | Base(OptionKind=aOptionKind) ->

      let ret = ScriptDom.RestoreOption()
      ret.OptionKind <- aOptionKind
      ret
  static member FromCs(src:ScriptDom.RestoreOption, fragmentMapping:FragmentMapping) : RestoreOption =
    let ret =
      match src with
      | :? ScriptDom.FileStreamRestoreOption as src ->
        RestoreOption.FileStreamRestoreOption((src.FileStreamOption |> Option.ofObj |> Option.map (fun x -> FileStreamDatabaseOption.FromCs(x, fragmentMapping))),(src.OptionKind))
      | :? ScriptDom.MoveRestoreOption as src ->
        RestoreOption.MoveRestoreOption((src.LogicalFileName |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))),(src.OSFileName |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))),(src.OptionKind))
      | :? ScriptDom.ScalarExpressionRestoreOption as src ->
        RestoreOption.ScalarExpressionRestoreOption((src.OptionKind),(src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.StopRestoreOption as src ->
        RestoreOption.StopRestoreOption((src.After |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))),(src.IsStopAt),(src.Mark |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))),(src.OptionKind))
      | _ -> (* :? ScriptDom.RestoreOption as src *)
        RestoreOption.Base(((src.OptionKind))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ResultSetDefinition = (* IsAbstract = false *)
  | Base of ResultSetType:ScriptDom.ResultSetType
  | InlineResultSetDefinition of ResultColumnDefinitions:(ResultColumnDefinition) list * ResultSetType:ScriptDom.ResultSetType
  | SchemaObjectResultSetDefinition of Name:SchemaObjectName option * ResultSetType:ScriptDom.ResultSetType
  member this.ToCs() : ScriptDom.ResultSetDefinition =
    match this with
    | InlineResultSetDefinition(ResultColumnDefinitions=aResultColumnDefinitions; ResultSetType=aResultSetType) ->
      let ret = ScriptDom.InlineResultSetDefinition()
      for e in aResultColumnDefinitions do ret.ResultColumnDefinitions.Add (e.ToCs())
      ret.ResultSetType <- aResultSetType
      ret :> ScriptDom.ResultSetDefinition (* 335 *)
    | SchemaObjectResultSetDefinition(Name=aName; ResultSetType=aResultSetType) ->
      let ret = ScriptDom.SchemaObjectResultSetDefinition()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ResultSetType <- aResultSetType
      ret :> ScriptDom.ResultSetDefinition (* 335 *)
    | Base(ResultSetType=aResultSetType) ->

      let ret = ScriptDom.ResultSetDefinition()
      ret.ResultSetType <- aResultSetType
      ret
  static member FromCs(src:ScriptDom.ResultSetDefinition, fragmentMapping:FragmentMapping) : ResultSetDefinition =
    let ret =
      match src with
      | :? ScriptDom.InlineResultSetDefinition as src ->
        ResultSetDefinition.InlineResultSetDefinition((src.ResultColumnDefinitions |> Seq.map (fun src -> ResultColumnDefinition.ResultColumnDefinition((src.ColumnDefinition |> Option.ofObj |> Option.map (fun x -> ColumnDefinitionBase.FromCs(x, fragmentMapping))), (src.Nullable |> Option.ofObj |> Option.map (fun x -> NullableConstraintDefinition.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.ResultSetType))
      | :? ScriptDom.SchemaObjectResultSetDefinition as src ->
        ResultSetDefinition.SchemaObjectResultSetDefinition((src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.ResultSetType))
      | _ -> (* :? ScriptDom.ResultSetDefinition as src *)
        ResultSetDefinition.Base(((src.ResultSetType))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ScalarExpression = (* IsAbstract = true *)
  | BinaryExpression of BinaryExpressionType:ScriptDom.BinaryExpressionType * FirstExpression:ScalarExpression option * SecondExpression:ScalarExpression option
  | ExtractFromExpression of Expression:ScalarExpression option * ExtractedElement:Identifier option
  | IdentityFunctionCall of DataType:DataTypeReference option * Increment:ScalarExpression option * Seed:ScalarExpression option
  | OdbcConvertSpecification of Identifier:Identifier option
  | PrimaryExpression of PrimaryExpression
  | ScalarExpressionSnippet of Script:String option
  | SourceDeclaration of Value:EventSessionObjectName option
  | UnaryExpression of Expression:ScalarExpression option * UnaryExpressionType:ScriptDom.UnaryExpressionType
  member this.ToCs() : ScriptDom.ScalarExpression =
    match this with
    | BinaryExpression(BinaryExpressionType=aBinaryExpressionType; FirstExpression=aFirstExpression; SecondExpression=aSecondExpression) ->
      let ret = ScriptDom.BinaryExpression()
      ret.BinaryExpressionType <- aBinaryExpressionType
      ret.FirstExpression <- aFirstExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SecondExpression <- aSecondExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ScalarExpression (* 335 *)
    | ExtractFromExpression(Expression=aExpression; ExtractedElement=aExtractedElement) ->
      let ret = ScriptDom.ExtractFromExpression()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ExtractedElement <- aExtractedElement |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ScalarExpression (* 335 *)
    | IdentityFunctionCall(DataType=aDataType; Increment=aIncrement; Seed=aSeed) ->
      let ret = ScriptDom.IdentityFunctionCall()
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Increment <- aIncrement |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Seed <- aSeed |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ScalarExpression (* 335 *)
    | OdbcConvertSpecification(Identifier=aIdentifier) ->
      let ret = ScriptDom.OdbcConvertSpecification()
      ret.Identifier <- aIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ScalarExpression (* 335 *)
    | PrimaryExpression(x) -> x.ToCs() :> ScriptDom.ScalarExpression (* 345 *)
    | ScalarExpressionSnippet(Script=aScript) ->
      let ret = ScriptDom.ScalarExpressionSnippet()
      ret.Script <- aScript |> Option.toObj
      ret :> ScriptDom.ScalarExpression (* 335 *)
    | SourceDeclaration(Value=aValue) ->
      let ret = ScriptDom.SourceDeclaration()
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ScalarExpression (* 335 *)
    | UnaryExpression(Expression=aExpression; UnaryExpressionType=aUnaryExpressionType) ->
      let ret = ScriptDom.UnaryExpression()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UnaryExpressionType <- aUnaryExpressionType
      ret :> ScriptDom.ScalarExpression (* 335 *)
  static member FromCs(src:ScriptDom.ScalarExpression, fragmentMapping:FragmentMapping) : ScalarExpression =
    let ret =
      match src with
      | :? ScriptDom.BinaryExpression as src ->
        ScalarExpression.BinaryExpression((src.BinaryExpressionType),(src.FirstExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.SecondExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ExtractFromExpression as src ->
        ScalarExpression.ExtractFromExpression((src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.ExtractedElement |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.IdentityFunctionCall as src ->
        ScalarExpression.IdentityFunctionCall((src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))),(src.Increment |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.Seed |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.OdbcConvertSpecification as src ->
        ScalarExpression.OdbcConvertSpecification((src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.PrimaryExpression as src ->
        match src with
        | :? ScriptDom.AtTimeZoneCall as src->
          ScalarExpression.PrimaryExpression((PrimaryExpression.AtTimeZoneCall((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.DateValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.TimeZone |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CaseExpression as src->
          ScalarExpression.PrimaryExpression((PrimaryExpression.CaseExpression((CaseExpression.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.CastCall as src->
          ScalarExpression.PrimaryExpression((PrimaryExpression.CastCall((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.Parameter |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CoalesceExpression as src->
          ScalarExpression.PrimaryExpression((PrimaryExpression.CoalesceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Expressions |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.ColumnReferenceExpression as src->
          ScalarExpression.PrimaryExpression((PrimaryExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.ConvertCall as src->
          ScalarExpression.PrimaryExpression((PrimaryExpression.ConvertCall((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.Parameter |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.Style |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.FunctionCall as src->
          ScalarExpression.PrimaryExpression((PrimaryExpression.FunctionCall((src.CallTarget |> Option.ofObj |> Option.map (fun x -> CallTarget.FromCs(x, fragmentMapping))), (src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.FunctionName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.OverClause |> Option.ofObj |> Option.map (fun x -> OverClause.FromCs(x, fragmentMapping))), (src.Parameters |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.UniqueRowFilter), (src.WithinGroupClause |> Option.ofObj |> Option.map (fun x -> WithinGroupClause.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.IIfCall as src->
          ScalarExpression.PrimaryExpression((PrimaryExpression.IIfCall((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ElseExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.Predicate |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))), (src.ThenExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.LeftFunctionCall as src->
          ScalarExpression.PrimaryExpression((PrimaryExpression.LeftFunctionCall((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Parameters |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.NextValueForExpression as src->
          ScalarExpression.PrimaryExpression((PrimaryExpression.NextValueForExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.OverClause |> Option.ofObj |> Option.map (fun x -> OverClause.FromCs(x, fragmentMapping))), (src.SequenceName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.NullIfExpression as src->
          ScalarExpression.PrimaryExpression((PrimaryExpression.NullIfExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.FirstExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.SecondExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.OdbcFunctionCall as src->
          ScalarExpression.PrimaryExpression((PrimaryExpression.OdbcFunctionCall((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Parameters |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.ParametersUsed))  ))
        | :? ScriptDom.ParameterlessCall as src->
          ScalarExpression.PrimaryExpression((PrimaryExpression.ParameterlessCall((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ParameterlessCallType))  ))
        | :? ScriptDom.ParenthesisExpression as src->
          ScalarExpression.PrimaryExpression((PrimaryExpression.ParenthesisExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.ParseCall as src->
          ScalarExpression.PrimaryExpression((PrimaryExpression.ParseCall((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Culture |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.StringValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.PartitionFunctionCall as src->
          ScalarExpression.PrimaryExpression((PrimaryExpression.PartitionFunctionCall((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.DatabaseName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.FunctionName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Parameters |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.RightFunctionCall as src->
          ScalarExpression.PrimaryExpression((PrimaryExpression.RightFunctionCall((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Parameters |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.ScalarSubquery as src->
          ScalarExpression.PrimaryExpression((PrimaryExpression.ScalarSubquery((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.QueryExpression |> Option.ofObj |> Option.map (fun x -> QueryExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.TryCastCall as src->
          ScalarExpression.PrimaryExpression((PrimaryExpression.TryCastCall((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.Parameter |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.TryConvertCall as src->
          ScalarExpression.PrimaryExpression((PrimaryExpression.TryConvertCall((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.Parameter |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.Style |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.TryParseCall as src->
          ScalarExpression.PrimaryExpression((PrimaryExpression.TryParseCall((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Culture |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.StringValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.UserDefinedTypePropertyAccess as src->
          ScalarExpression.PrimaryExpression((PrimaryExpression.UserDefinedTypePropertyAccess((src.CallTarget |> Option.ofObj |> Option.map (fun x -> CallTarget.FromCs(x, fragmentMapping))), (src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.PropertyName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.ValueExpression as src->
          ScalarExpression.PrimaryExpression((PrimaryExpression.ValueExpression((ValueExpression.FromCs(src, fragmentMapping)))  ))
      | :? ScriptDom.ScalarExpressionSnippet as src ->
        ScalarExpression.ScalarExpressionSnippet((Option.ofObj (src.Script)))
      | :? ScriptDom.SourceDeclaration as src ->
        ScalarExpression.SourceDeclaration((src.Value |> Option.ofObj |> Option.map (fun x -> EventSessionObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.UnaryExpression as src ->
        ScalarExpression.UnaryExpression((src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.UnaryExpressionType))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] SchemaDeclarationItem = (* IsAbstract = false *)
  | Base of ColumnDefinition:ColumnDefinitionBase option * Mapping:ValueExpression option
  | SchemaDeclarationItemOpenjson of AsJson:bool * ColumnDefinition:ColumnDefinitionBase option * Mapping:ValueExpression option
  member this.ToCs() : ScriptDom.SchemaDeclarationItem =
    match this with
    | SchemaDeclarationItemOpenjson(AsJson=aAsJson; ColumnDefinition=aColumnDefinition; Mapping=aMapping) ->
      let ret = ScriptDom.SchemaDeclarationItemOpenjson()
      ret.AsJson <- aAsJson
      ret.ColumnDefinition <- aColumnDefinition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Mapping <- aMapping |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SchemaDeclarationItem (* 335 *)
    | Base(ColumnDefinition=aColumnDefinition; Mapping=aMapping) ->

      let ret = ScriptDom.SchemaDeclarationItem()
      ret.ColumnDefinition <- aColumnDefinition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Mapping <- aMapping |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret
  static member FromCs(src:ScriptDom.SchemaDeclarationItem, fragmentMapping:FragmentMapping) : SchemaDeclarationItem =
    let ret =
      match src with
      | :? ScriptDom.SchemaDeclarationItemOpenjson as src ->
        SchemaDeclarationItem.SchemaDeclarationItemOpenjson((src.AsJson),(src.ColumnDefinition |> Option.ofObj |> Option.map (fun x -> ColumnDefinitionBase.FromCs(x, fragmentMapping))),(src.Mapping |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))
      | _ -> (* :? ScriptDom.SchemaDeclarationItem as src *)
        SchemaDeclarationItem.Base(((src.ColumnDefinition |> Option.ofObj |> Option.map (fun x -> ColumnDefinitionBase.FromCs(x, fragmentMapping))), (src.Mapping |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] SearchPropertyListAction = (* IsAbstract = true *)
  | AddSearchPropertyListAction of Description:StringLiteral option * Guid:StringLiteral option * Id:IntegerLiteral option * PropertyName:StringLiteral option
  | DropSearchPropertyListAction of PropertyName:StringLiteral option
  member this.ToCs() : ScriptDom.SearchPropertyListAction =
    match this with
    | AddSearchPropertyListAction(Description=aDescription; Guid=aGuid; Id=aId; PropertyName=aPropertyName) ->
      let ret = ScriptDom.AddSearchPropertyListAction()
      ret.Description <- aDescription |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Guid <- aGuid |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Id <- aId |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PropertyName <- aPropertyName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SearchPropertyListAction (* 335 *)
    | DropSearchPropertyListAction(PropertyName=aPropertyName) ->
      let ret = ScriptDom.DropSearchPropertyListAction()
      ret.PropertyName <- aPropertyName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SearchPropertyListAction (* 335 *)
  static member FromCs(src:ScriptDom.SearchPropertyListAction, fragmentMapping:FragmentMapping) : SearchPropertyListAction =
    let ret =
      match src with
      | :? ScriptDom.AddSearchPropertyListAction as src ->
        SearchPropertyListAction.AddSearchPropertyListAction((src.Description |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))),(src.Guid |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))),(src.Id |> Option.ofObj |> Option.map (fun x -> IntegerLiteral.FromCs(x, fragmentMapping))),(src.PropertyName |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropSearchPropertyListAction as src ->
        SearchPropertyListAction.DropSearchPropertyListAction((src.PropertyName |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] SecurityElement80 = (* IsAbstract = true *)
  | CommandSecurityElement80 of All:bool * CommandOptions:ScriptDom.CommandOptions
  | PrivilegeSecurityElement80 of Columns:(Identifier) list * Privileges:(Privilege80) list * SchemaObjectName:SchemaObjectName option
  member this.ToCs() : ScriptDom.SecurityElement80 =
    match this with
    | CommandSecurityElement80(All=aAll; CommandOptions=aCommandOptions) ->
      let ret = ScriptDom.CommandSecurityElement80()
      ret.All <- aAll
      ret.CommandOptions <- aCommandOptions
      ret :> ScriptDom.SecurityElement80 (* 335 *)
    | PrivilegeSecurityElement80(Columns=aColumns; Privileges=aPrivileges; SchemaObjectName=aSchemaObjectName) ->
      let ret = ScriptDom.PrivilegeSecurityElement80()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      for e in aPrivileges do ret.Privileges.Add (e.ToCs())
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SecurityElement80 (* 335 *)
  static member FromCs(src:ScriptDom.SecurityElement80, fragmentMapping:FragmentMapping) : SecurityElement80 =
    let ret =
      match src with
      | :? ScriptDom.CommandSecurityElement80 as src ->
        SecurityElement80.CommandSecurityElement80((src.All),(src.CommandOptions))
      | :? ScriptDom.PrivilegeSecurityElement80 as src ->
        SecurityElement80.PrivilegeSecurityElement80((src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Privileges |> Seq.map (fun src -> Privilege80.Privilege80((src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.PrivilegeType80))) |> List.ofSeq),(src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] SelectElement = (* IsAbstract = true *)
  | SelectScalarExpression of ColumnName:IdentifierOrValueExpression option * Expression:ScalarExpression option
  | SelectSetVariable of AssignmentKind:ScriptDom.AssignmentKind * Expression:ScalarExpression option * Variable:VariableReference option
  | SelectStarExpression of Qualifier:MultiPartIdentifier option
  member this.ToCs() : ScriptDom.SelectElement =
    match this with
    | SelectScalarExpression(ColumnName=aColumnName; Expression=aExpression) ->
      let ret = ScriptDom.SelectScalarExpression()
      ret.ColumnName <- aColumnName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SelectElement (* 335 *)
    | SelectSetVariable(AssignmentKind=aAssignmentKind; Expression=aExpression; Variable=aVariable) ->
      let ret = ScriptDom.SelectSetVariable()
      ret.AssignmentKind <- aAssignmentKind
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Variable <- aVariable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SelectElement (* 335 *)
    | SelectStarExpression(Qualifier=aQualifier) ->
      let ret = ScriptDom.SelectStarExpression()
      ret.Qualifier <- aQualifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SelectElement (* 335 *)
  static member FromCs(src:ScriptDom.SelectElement, fragmentMapping:FragmentMapping) : SelectElement =
    let ret =
      match src with
      | :? ScriptDom.SelectScalarExpression as src ->
        SelectElement.SelectScalarExpression((src.ColumnName |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))),(src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.SelectSetVariable as src ->
        SelectElement.SelectSetVariable((src.AssignmentKind),(src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.Variable |> Option.ofObj |> Option.map (fun x -> VariableReference.FromCs(x, fragmentMapping))))
      | :? ScriptDom.SelectStarExpression as src ->
        SelectElement.SelectStarExpression((src.Qualifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] SequenceOption = (* IsAbstract = false *)
  | Base of NoValue:bool * OptionKind:ScriptDom.SequenceOptionKind
  | DataTypeSequenceOption of DataType:DataTypeReference option * NoValue:bool * OptionKind:ScriptDom.SequenceOptionKind
  | ScalarExpressionSequenceOption of NoValue:bool * OptionKind:ScriptDom.SequenceOptionKind * OptionValue:ScalarExpression option
  member this.ToCs() : ScriptDom.SequenceOption =
    match this with
    | DataTypeSequenceOption(DataType=aDataType; NoValue=aNoValue; OptionKind=aOptionKind) ->
      let ret = ScriptDom.DataTypeSequenceOption()
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.NoValue <- aNoValue
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.SequenceOption (* 335 *)
    | ScalarExpressionSequenceOption(NoValue=aNoValue; OptionKind=aOptionKind; OptionValue=aOptionValue) ->
      let ret = ScriptDom.ScalarExpressionSequenceOption()
      ret.NoValue <- aNoValue
      ret.OptionKind <- aOptionKind
      ret.OptionValue <- aOptionValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SequenceOption (* 335 *)
    | Base(NoValue=aNoValue; OptionKind=aOptionKind) ->

      let ret = ScriptDom.SequenceOption()
      ret.NoValue <- aNoValue
      ret.OptionKind <- aOptionKind
      ret
  static member FromCs(src:ScriptDom.SequenceOption, fragmentMapping:FragmentMapping) : SequenceOption =
    let ret =
      match src with
      | :? ScriptDom.DataTypeSequenceOption as src ->
        SequenceOption.DataTypeSequenceOption((src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))),(src.NoValue),(src.OptionKind))
      | :? ScriptDom.ScalarExpressionSequenceOption as src ->
        SequenceOption.ScalarExpressionSequenceOption((src.NoValue),(src.OptionKind),(src.OptionValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | _ -> (* :? ScriptDom.SequenceOption as src *)
        SequenceOption.Base(((src.NoValue), (src.OptionKind))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] SessionOption = (* IsAbstract = true *)
  | EventRetentionSessionOption of OptionKind:ScriptDom.SessionOptionKind * Value:ScriptDom.EventSessionEventRetentionModeType
  | LiteralSessionOption of OptionKind:ScriptDom.SessionOptionKind * Unit:ScriptDom.MemoryUnit * Value:Literal option
  | MaxDispatchLatencySessionOption of IsInfinite:bool * OptionKind:ScriptDom.SessionOptionKind * Value:Literal option
  | MemoryPartitionSessionOption of OptionKind:ScriptDom.SessionOptionKind * Value:ScriptDom.EventSessionMemoryPartitionModeType
  | OnOffSessionOption of OptionKind:ScriptDom.SessionOptionKind * OptionState:ScriptDom.OptionState
  member this.ToCs() : ScriptDom.SessionOption =
    match this with
    | EventRetentionSessionOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.EventRetentionSessionOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.SessionOption (* 335 *)
    | LiteralSessionOption(OptionKind=aOptionKind; Unit=aUnit; Value=aValue) ->
      let ret = ScriptDom.LiteralSessionOption()
      ret.OptionKind <- aOptionKind
      ret.Unit <- aUnit
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SessionOption (* 335 *)
    | MaxDispatchLatencySessionOption(IsInfinite=aIsInfinite; OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.MaxDispatchLatencySessionOption()
      ret.IsInfinite <- aIsInfinite
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SessionOption (* 335 *)
    | MemoryPartitionSessionOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.MemoryPartitionSessionOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.SessionOption (* 335 *)
    | OnOffSessionOption(OptionKind=aOptionKind; OptionState=aOptionState) ->
      let ret = ScriptDom.OnOffSessionOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret :> ScriptDom.SessionOption (* 335 *)
  static member FromCs(src:ScriptDom.SessionOption, fragmentMapping:FragmentMapping) : SessionOption =
    let ret =
      match src with
      | :? ScriptDom.EventRetentionSessionOption as src ->
        SessionOption.EventRetentionSessionOption((src.OptionKind),(src.Value))
      | :? ScriptDom.LiteralSessionOption as src ->
        SessionOption.LiteralSessionOption((src.OptionKind),(src.Unit),(src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.MaxDispatchLatencySessionOption as src ->
        SessionOption.MaxDispatchLatencySessionOption((src.IsInfinite),(src.OptionKind),(src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.MemoryPartitionSessionOption as src ->
        SessionOption.MemoryPartitionSessionOption((src.OptionKind),(src.Value))
      | :? ScriptDom.OnOffSessionOption as src ->
        SessionOption.OnOffSessionOption((src.OptionKind),(src.OptionState))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] SetClause = (* IsAbstract = true *)
  | AssignmentSetClause of AssignmentKind:ScriptDom.AssignmentKind * Column:ColumnReferenceExpression option * NewValue:ScalarExpression option * Variable:VariableReference option
  | FunctionCallSetClause of MutatorFunction:FunctionCall option
  member this.ToCs() : ScriptDom.SetClause =
    match this with
    | AssignmentSetClause(AssignmentKind=aAssignmentKind; Column=aColumn; NewValue=aNewValue; Variable=aVariable) ->
      let ret = ScriptDom.AssignmentSetClause()
      ret.AssignmentKind <- aAssignmentKind
      ret.Column <- aColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.NewValue <- aNewValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Variable <- aVariable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SetClause (* 335 *)
    | FunctionCallSetClause(MutatorFunction=aMutatorFunction) ->
      let ret = ScriptDom.FunctionCallSetClause()
      ret.MutatorFunction <- aMutatorFunction |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SetClause (* 335 *)
  static member FromCs(src:ScriptDom.SetClause, fragmentMapping:FragmentMapping) : SetClause =
    let ret =
      match src with
      | :? ScriptDom.AssignmentSetClause as src ->
        SetClause.AssignmentSetClause((src.AssignmentKind),(src.Column |> Option.ofObj |> Option.map (fun x -> ColumnReferenceExpression.FromCs(x, fragmentMapping))),(src.NewValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.Variable |> Option.ofObj |> Option.map (fun x -> VariableReference.FromCs(x, fragmentMapping))))
      | :? ScriptDom.FunctionCallSetClause as src ->
        SetClause.FunctionCallSetClause((src.MutatorFunction |> Option.ofObj |> Option.map (fun x -> FunctionCall.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] SetCommand = (* IsAbstract = true *)
  | GeneralSetCommand of CommandType:ScriptDom.GeneralSetCommandType * Parameter:ScalarExpression option
  | SetFipsFlaggerCommand of ComplianceLevel:ScriptDom.FipsComplianceLevel
  member this.ToCs() : ScriptDom.SetCommand =
    match this with
    | GeneralSetCommand(CommandType=aCommandType; Parameter=aParameter) ->
      let ret = ScriptDom.GeneralSetCommand()
      ret.CommandType <- aCommandType
      ret.Parameter <- aParameter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SetCommand (* 335 *)
    | SetFipsFlaggerCommand(ComplianceLevel=aComplianceLevel) ->
      let ret = ScriptDom.SetFipsFlaggerCommand()
      ret.ComplianceLevel <- aComplianceLevel
      ret :> ScriptDom.SetCommand (* 335 *)
  static member FromCs(src:ScriptDom.SetCommand, fragmentMapping:FragmentMapping) : SetCommand =
    let ret =
      match src with
      | :? ScriptDom.GeneralSetCommand as src ->
        SetCommand.GeneralSetCommand((src.CommandType),(src.Parameter |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.SetFipsFlaggerCommand as src ->
        SetCommand.SetFipsFlaggerCommand((src.ComplianceLevel))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] SpatialIndexOption = (* IsAbstract = true *)
  | BoundingBoxSpatialIndexOption of BoundingBoxParameters:(BoundingBoxParameter) list
  | CellsPerObjectSpatialIndexOption of Value:Literal option
  | GridsSpatialIndexOption of GridParameters:(GridParameter) list
  | SpatialIndexRegularOption of Option:IndexOption option
  member this.ToCs() : ScriptDom.SpatialIndexOption =
    match this with
    | BoundingBoxSpatialIndexOption(BoundingBoxParameters=aBoundingBoxParameters) ->
      let ret = ScriptDom.BoundingBoxSpatialIndexOption()
      for e in aBoundingBoxParameters do ret.BoundingBoxParameters.Add (e.ToCs())
      ret :> ScriptDom.SpatialIndexOption (* 335 *)
    | CellsPerObjectSpatialIndexOption(Value=aValue) ->
      let ret = ScriptDom.CellsPerObjectSpatialIndexOption()
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SpatialIndexOption (* 335 *)
    | GridsSpatialIndexOption(GridParameters=aGridParameters) ->
      let ret = ScriptDom.GridsSpatialIndexOption()
      for e in aGridParameters do ret.GridParameters.Add (e.ToCs())
      ret :> ScriptDom.SpatialIndexOption (* 335 *)
    | SpatialIndexRegularOption(Option=aOption) ->
      let ret = ScriptDom.SpatialIndexRegularOption()
      ret.Option <- aOption |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SpatialIndexOption (* 335 *)
  static member FromCs(src:ScriptDom.SpatialIndexOption, fragmentMapping:FragmentMapping) : SpatialIndexOption =
    let ret =
      match src with
      | :? ScriptDom.BoundingBoxSpatialIndexOption as src ->
        SpatialIndexOption.BoundingBoxSpatialIndexOption((src.BoundingBoxParameters |> Seq.map (fun src -> BoundingBoxParameter.BoundingBoxParameter((src.Parameter), (src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq))
      | :? ScriptDom.CellsPerObjectSpatialIndexOption as src ->
        SpatialIndexOption.CellsPerObjectSpatialIndexOption((src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.GridsSpatialIndexOption as src ->
        SpatialIndexOption.GridsSpatialIndexOption((src.GridParameters |> Seq.map (fun src -> GridParameter.GridParameter((src.Parameter), (src.Value))) |> List.ofSeq))
      | :? ScriptDom.SpatialIndexRegularOption as src ->
        SpatialIndexOption.SpatialIndexRegularOption((src.Option |> Option.ofObj |> Option.map (fun x -> IndexOption.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] StatementList = (* IsAbstract = false *)
  | Base of Statements:(TSqlStatement) list
  | StatementListSnippet of Script:String option * Statements:(TSqlStatement) list
  member this.ToCs() : ScriptDom.StatementList =
    match this with
    | StatementListSnippet(Script=aScript; Statements=aStatements) ->
      let ret = ScriptDom.StatementListSnippet()
      ret.Script <- aScript |> Option.toObj
      for e in aStatements do ret.Statements.Add (e.ToCs())
      ret :> ScriptDom.StatementList (* 335 *)
    | Base(Statements=aStatements) ->

      let ret = ScriptDom.StatementList()
      for e in aStatements do ret.Statements.Add (e.ToCs())
      ret
  static member FromCs(src:ScriptDom.StatementList, fragmentMapping:FragmentMapping) : StatementList =
    let ret =
      match src with
      | :? ScriptDom.StatementListSnippet as src ->
        StatementList.StatementListSnippet((Option.ofObj (src.Script)),(src.Statements |> Seq.map (fun x -> TSqlStatement.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | _ -> (* :? ScriptDom.StatementList as src *)
        StatementList.Base(((src.Statements |> Seq.map (fun x -> TSqlStatement.FromCs(x, fragmentMapping)) |> List.ofSeq))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] StatisticsOption = (* IsAbstract = false *)
  | Base of OptionKind:ScriptDom.StatisticsOptionKind
  | LiteralStatisticsOption of Literal:Literal option * OptionKind:ScriptDom.StatisticsOptionKind
  | OnOffStatisticsOption of OptionKind:ScriptDom.StatisticsOptionKind * OptionState:ScriptDom.OptionState
  | ResampleStatisticsOption of OptionKind:ScriptDom.StatisticsOptionKind * Partitions:(StatisticsPartitionRange) list
  member this.ToCs() : ScriptDom.StatisticsOption =
    match this with
    | LiteralStatisticsOption(Literal=aLiteral; OptionKind=aOptionKind) ->
      let ret = ScriptDom.LiteralStatisticsOption()
      ret.Literal <- aLiteral |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.StatisticsOption (* 335 *)
    | OnOffStatisticsOption(OptionKind=aOptionKind; OptionState=aOptionState) ->
      let ret = ScriptDom.OnOffStatisticsOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret :> ScriptDom.StatisticsOption (* 335 *)
    | ResampleStatisticsOption(OptionKind=aOptionKind; Partitions=aPartitions) ->
      let ret = ScriptDom.ResampleStatisticsOption()
      ret.OptionKind <- aOptionKind
      for e in aPartitions do ret.Partitions.Add (e.ToCs())
      ret :> ScriptDom.StatisticsOption (* 335 *)
    | Base(OptionKind=aOptionKind) ->

      let ret = ScriptDom.StatisticsOption()
      ret.OptionKind <- aOptionKind
      ret
  static member FromCs(src:ScriptDom.StatisticsOption, fragmentMapping:FragmentMapping) : StatisticsOption =
    let ret =
      match src with
      | :? ScriptDom.LiteralStatisticsOption as src ->
        StatisticsOption.LiteralStatisticsOption((src.Literal |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.OptionKind))
      | :? ScriptDom.OnOffStatisticsOption as src ->
        StatisticsOption.OnOffStatisticsOption((src.OptionKind),(src.OptionState))
      | :? ScriptDom.ResampleStatisticsOption as src ->
        StatisticsOption.ResampleStatisticsOption((src.OptionKind),(src.Partitions |> Seq.map (fun src -> StatisticsPartitionRange.StatisticsPartitionRange((src.From |> Option.ofObj |> Option.map (fun x -> IntegerLiteral.FromCs(x, fragmentMapping))), (src.To |> Option.ofObj |> Option.map (fun x -> IntegerLiteral.FromCs(x, fragmentMapping))))) |> List.ofSeq))
      | _ -> (* :? ScriptDom.StatisticsOption as src *)
        StatisticsOption.Base(((src.OptionKind))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] TSqlStatement = (* IsAbstract = true *)
  | AlterAsymmetricKeyStatement of AttestedBy:Literal option * DecryptionPassword:Literal option * EncryptionPassword:Literal option * Kind:ScriptDom.AlterCertificateStatementKind * Name:Identifier option
  | AlterAuthorizationStatement of PrincipalName:Identifier option * SecurityTargetObject:SecurityTargetObject option * ToSchemaOwner:bool
  | AlterCreateEndpointStatementBase of AlterCreateEndpointStatementBase
  | AlterCreateServiceStatementBase of AlterCreateServiceStatementBase
  | AlterCryptographicProviderStatement of File:Literal option * Name:Identifier option * Option:ScriptDom.EnableDisableOptionType
  | AlterDatabaseScopedConfigurationStatement of AlterDatabaseScopedConfigurationStatement
  | AlterDatabaseStatement of AlterDatabaseStatement
  | AlterFederationStatement of Boundary:ScalarExpression option * DistributionName:Identifier option * Kind:ScriptDom.AlterFederationKind * Name:Identifier option
  | AlterFullTextIndexStatement of Action:AlterFullTextIndexAction option * OnName:SchemaObjectName option
  | AlterFullTextStopListStatement of Action:FullTextStopListAction option * Name:Identifier option
  | AlterLoginStatement of AlterLoginStatement
  | AlterPartitionFunctionStatement of Boundary:ScalarExpression option * IsSplit:bool * Name:Identifier option
  | AlterPartitionSchemeStatement of FileGroup:IdentifierOrValueExpression option * Name:Identifier option
  | AlterResourceGovernorStatement of ClassifierFunction:SchemaObjectName option * Command:ScriptDom.AlterResourceGovernorCommandType
  | AlterSchemaStatement of Name:Identifier option * ObjectKind:ScriptDom.SecurityObjectKind * ObjectName:SchemaObjectName option
  | AlterSearchPropertyListStatement of Action:SearchPropertyListAction option * Name:Identifier option
  | AlterServerConfigurationSetBufferPoolExtensionStatement of Options:(AlterServerConfigurationBufferPoolExtensionOption) list
  | AlterServerConfigurationSetDiagnosticsLogStatement of Options:(AlterServerConfigurationDiagnosticsLogOption) list
  | AlterServerConfigurationSetExternalAuthenticationStatement of Options:(AlterServerConfigurationExternalAuthenticationOption) list
  | AlterServerConfigurationSetFailoverClusterPropertyStatement of Options:(AlterServerConfigurationFailoverClusterPropertyOption) list
  | AlterServerConfigurationSetHadrClusterStatement of Options:(AlterServerConfigurationHadrClusterOption) list
  | AlterServerConfigurationSetSoftNumaStatement of Options:(AlterServerConfigurationSoftNumaOption) list
  | AlterServerConfigurationStatement of ProcessAffinity:ScriptDom.ProcessAffinityType * ProcessAffinityRanges:(ProcessAffinityRange) list
  | AlterServiceMasterKeyStatement of Account:Literal option * Kind:ScriptDom.AlterServiceMasterKeyOption * Password:Literal option
  | AlterTableStatement of AlterTableStatement
  | AlterXmlSchemaCollectionStatement of Expression:ScalarExpression option * Name:SchemaObjectName option
  | ApplicationRoleStatement of ApplicationRoleStatement
  | AssemblyStatement of AssemblyStatement
  | AuditSpecificationStatement of AuditSpecificationStatement
  | AvailabilityGroupStatement of AvailabilityGroupStatement
  | BackupRestoreMasterKeyStatementBase of BackupRestoreMasterKeyStatementBase
  | BackupStatement of BackupStatement
  | BeginConversationTimerStatement of Handle:ScalarExpression option * Timeout:ScalarExpression option
  | BeginDialogStatement of ContractName:IdentifierOrValueExpression option * Handle:VariableReference option * InitiatorServiceName:IdentifierOrValueExpression option * InstanceSpec:ValueExpression option * IsConversation:bool * Options:(DialogOption) list * TargetServiceName:ValueExpression option
  | BeginEndBlockStatement of BeginEndBlockStatement
  | BreakStatement 
  | BrokerPriorityStatement of BrokerPriorityStatement
  | BulkInsertBase of BulkInsertBase
  | CertificateStatementBase of CertificateStatementBase
  | CheckpointStatement of Duration:Literal option
  | CloseMasterKeyStatement 
  | CloseSymmetricKeyStatement of All:bool * Name:Identifier option
  | ColumnEncryptionKeyStatement of ColumnEncryptionKeyStatement
  | ContinueStatement 
  | CopyStatement of From:(StringLiteral) list * Into:SchemaObjectName option * OptimizerHints:(OptimizerHint) list * Options:(CopyOption) list
  | CreateAggregateStatement of AssemblyName:AssemblyName option * Name:SchemaObjectName option * Parameters:(ProcedureParameter) list * ReturnType:DataTypeReference option
  | CreateAsymmetricKeyStatement of EncryptionAlgorithm:ScriptDom.EncryptionAlgorithm * KeySource:EncryptionSource option * Name:Identifier option * Owner:Identifier option * Password:Literal option
  | CreateColumnMasterKeyStatement of Name:Identifier option * Parameters:(ColumnMasterKeyParameter) list
  | CreateColumnStoreIndexStatement of Clustered:(bool) option * Columns:(ColumnReferenceExpression) list * FilterPredicate:BooleanExpression option * IndexOptions:(IndexOption) list * Name:Identifier option * OnFileGroupOrPartitionScheme:FileGroupOrPartitionScheme option * OnName:SchemaObjectName option * OrderedColumns:(ColumnReferenceExpression) list
  | CreateContractStatement of Messages:(ContractMessage) list * Name:Identifier option * Owner:Identifier option
  | CreateCryptographicProviderStatement of File:Literal option * Name:Identifier option
  | CreateDatabaseStatement of AttachMode:ScriptDom.AttachMode * Collation:Identifier option * Containment:ContainmentDatabaseOption option * CopyOf:MultiPartIdentifier option * DatabaseName:Identifier option * DatabaseSnapshot:Identifier option * FileGroups:(FileGroupDefinition) list * LogOn:(FileDeclaration) list * Options:(DatabaseOption) list
  | CreateDefaultStatement of Expression:ScalarExpression option * Name:SchemaObjectName option
  | CreateEventNotificationStatement of BrokerInstanceSpecifier:Literal option * BrokerService:Literal option * EventTypeGroups:(EventTypeGroupContainer) list * Name:Identifier option * Scope:EventNotificationObjectScope option * WithFanIn:bool
  | CreateFederationStatement of DataType:DataTypeReference option * DistributionName:Identifier option * Name:Identifier option
  | CreateFullTextIndexStatement of CatalogAndFileGroup:FullTextCatalogAndFileGroup option * FullTextIndexColumns:(FullTextIndexColumn) list * KeyIndexName:Identifier option * OnName:SchemaObjectName option * Options:(FullTextIndexOption) list
  | CreateFullTextStopListStatement of DatabaseName:Identifier option * IsSystemStopList:bool * Name:Identifier option * Owner:Identifier option * SourceStopListName:Identifier option
  | CreateLoginStatement of Name:Identifier option * Source:CreateLoginSource option
  | CreatePartitionFunctionStatement of BoundaryValues:(ScalarExpression) list * Name:Identifier option * ParameterType:PartitionParameterType option * Range:ScriptDom.PartitionFunctionRange
  | CreatePartitionSchemeStatement of FileGroups:(IdentifierOrValueExpression) list * IsAll:bool * Name:Identifier option * PartitionFunction:Identifier option
  | CreateRuleStatement of Expression:BooleanExpression option * Name:SchemaObjectName option
  | CreateSchemaStatement of Name:Identifier option * Owner:Identifier option * StatementList:StatementList option
  | CreateSearchPropertyListStatement of Name:Identifier option * Owner:Identifier option * SourceSearchPropertyList:MultiPartIdentifier option
  | CreateSpatialIndexStatement of Name:Identifier option * Object:SchemaObjectName option * OnFileGroup:IdentifierOrValueExpression option * SpatialColumnName:Identifier option * SpatialIndexOptions:(SpatialIndexOption) list * SpatialIndexingScheme:ScriptDom.SpatialIndexingSchemeType
  | CreateStatisticsStatement of Columns:(ColumnReferenceExpression) list * FilterPredicate:BooleanExpression option * Name:Identifier option * OnName:SchemaObjectName option * StatisticsOptions:(StatisticsOption) list
  | CreateSynonymStatement of ForName:SchemaObjectName option * Name:SchemaObjectName option
  | CreateTableStatement of AsEdge:bool * AsFileTable:bool * AsNode:bool * CtasColumns:(Identifier) list * Definition:TableDefinition option * FederationScheme:FederationScheme option * FileStreamOn:IdentifierOrValueExpression option * OnFileGroupOrPartitionScheme:FileGroupOrPartitionScheme option * Options:(TableOption) list * SchemaObjectName:SchemaObjectName option * SelectStatement:SelectStatement option * TextImageOn:IdentifierOrValueExpression option
  | CreateTypeStatement of CreateTypeStatement
  | CreateXmlSchemaCollectionStatement of Expression:ScalarExpression option * Name:SchemaObjectName option
  | CredentialStatement of CredentialStatement
  | CursorStatement of CursorStatement
  | DatabaseEncryptionKeyStatement of DatabaseEncryptionKeyStatement
  | DbccStatement of Command:ScriptDom.DbccCommand * DllName:String option * Literals:(DbccNamedLiteral) list * Options:(DbccOption) list * OptionsUseJoin:bool * ParenthesisRequired:bool
  | DeclareCursorStatement of CursorDefinition:CursorDefinition option * Name:Identifier option
  | DeclareTableVariableStatement of Body:DeclareTableVariableBody option
  | DeclareVariableStatement of Declarations:(DeclareVariableElement) list
  | DiskStatement of DiskStatementType:ScriptDom.DiskStatementType * Options:(DiskStatementOption) list
  | DropChildObjectsStatement of DropChildObjectsStatement
  | DropDatabaseEncryptionKeyStatement 
  | DropDatabaseStatement of Databases:(Identifier) list * IsIfExists:bool
  | DropEventNotificationStatement of Notifications:(Identifier) list * Scope:EventNotificationObjectScope option
  | DropFullTextIndexStatement of TableName:SchemaObjectName option
  | DropIndexStatement of DropIndexClauses:(DropIndexClauseBase) list * IsIfExists:bool
  | DropMasterKeyStatement 
  | DropObjectsStatement of DropObjectsStatement
  | DropQueueStatement of Name:SchemaObjectName option
  | DropSchemaStatement of DropBehavior:ScriptDom.DropSchemaBehavior * IsIfExists:bool * Schema:SchemaObjectName option
  | DropTypeStatement of IsIfExists:bool * Name:SchemaObjectName option
  | DropUnownedObjectStatement of DropUnownedObjectStatement
  | DropXmlSchemaCollectionStatement of Name:SchemaObjectName option
  | EnableDisableTriggerStatement of All:bool * TriggerEnforcement:ScriptDom.TriggerEnforcement * TriggerNames:(SchemaObjectName) list * TriggerObject:TriggerObject option
  | EndConversationStatement of Conversation:ScalarExpression option * ErrorCode:ValueExpression option * ErrorDescription:ValueExpression option * WithCleanup:bool
  | EventSessionStatement of EventSessionStatement
  | ExecuteAsStatement of Cookie:VariableReference option * ExecuteContext:ExecuteContext option * WithNoRevert:bool
  | ExecuteStatement of ExecuteSpecification:ExecuteSpecification option * Options:(ExecuteOption) list
  | ExternalDataSourceStatement of ExternalDataSourceStatement
  | ExternalFileFormatStatement of ExternalFileFormatStatement
  | ExternalResourcePoolStatement of ExternalResourcePoolStatement
  | ExternalTableStatement of ExternalTableStatement
  | FullTextCatalogStatement of FullTextCatalogStatement
  | GoToStatement of LabelName:Identifier option
  | IfStatement of ElseStatement:TSqlStatement option * Predicate:BooleanExpression option * ThenStatement:TSqlStatement option
  | IndexDefinition of Columns:(ColumnWithSortOrder) list * FileStreamOn:IdentifierOrValueExpression option * FilterPredicate:BooleanExpression option * IndexOptions:(IndexOption) list * IndexType:IndexType option * Name:Identifier option * OnFileGroupOrPartitionScheme:FileGroupOrPartitionScheme option * Unique:bool
  | IndexStatement of IndexStatement
  | KillQueryNotificationSubscriptionStatement of All:bool * SubscriptionId:Literal option
  | KillStatement of Parameter:ScalarExpression option * WithStatusOnly:bool
  | KillStatsJobStatement of JobId:ScalarExpression option
  | LabelStatement of Value:String option
  | LineNoStatement of LineNo:IntegerLiteral option
  | MasterKeyStatement of MasterKeyStatement
  | MessageTypeStatementBase of MessageTypeStatementBase
  | MoveConversationStatement of Conversation:ScalarExpression option * Group:ScalarExpression option
  | OpenMasterKeyStatement of Password:Literal option
  | OpenSymmetricKeyStatement of DecryptionMechanism:CryptoMechanism option * Name:Identifier option
  | PrintStatement of Expression:ScalarExpression option
  | ProcedureStatementBodyBase of ProcedureStatementBodyBase
  | QueueStatement of QueueStatement
  | RaiseErrorLegacyStatement of FirstParameter:ScalarExpression option * SecondParameter:ValueExpression option
  | RaiseErrorStatement of FirstParameter:ScalarExpression option * OptionalParameters:(ScalarExpression) list * RaiseErrorOptions:ScriptDom.RaiseErrorOptions * SecondParameter:ScalarExpression option * ThirdParameter:ScalarExpression option
  | ReadTextStatement of Column:ColumnReferenceExpression option * HoldLock:bool * Offset:ValueExpression option * Size:ValueExpression option * TextPointer:ValueExpression option
  | ReconfigureStatement of WithOverride:bool
  | RemoteServiceBindingStatementBase of RemoteServiceBindingStatementBase
  | RenameEntityStatement of NewName:Identifier option * OldName:SchemaObjectName option * RenameEntityType:ScriptDom.SecurityObjectKind * SeparatorType:(ScriptDom.SeparatorType) option
  | ResourcePoolStatement of ResourcePoolStatement
  | RestoreStatement of DatabaseName:IdentifierOrValueExpression option * Devices:(DeviceInfo) list * Files:(BackupRestoreFileInfo) list * Kind:ScriptDom.RestoreStatementKind * Options:(RestoreOption) list
  | ReturnStatement of Expression:ScalarExpression option
  | RevertStatement of Cookie:ScalarExpression option
  | RoleStatement of RoleStatement
  | RouteStatement of RouteStatement
  | SecurityPolicyStatement of SecurityPolicyStatement
  | SecurityStatement of SecurityStatement
  | SecurityStatementBody80 of SecurityStatementBody80
  | SendStatement of ConversationHandles:(ScalarExpression) list * MessageBody:ScalarExpression option * MessageTypeName:IdentifierOrValueExpression option
  | SensitivityClassificationStatement of SensitivityClassificationStatement
  | SequenceStatement of SequenceStatement
  | ServerAuditStatement of ServerAuditStatement
  | SetCommandStatement of Commands:(SetCommand) list
  | SetErrorLevelStatement of Level:ScalarExpression option
  | SetOnOffStatement of SetOnOffStatement
  | SetRowCountStatement of NumberRows:ValueExpression option
  | SetTextSizeStatement of TextSize:ScalarExpression option
  | SetTransactionIsolationLevelStatement of Level:ScriptDom.IsolationLevel
  | SetUserStatement of UserName:ValueExpression option * WithNoReset:bool
  | SetVariableStatement of AssignmentKind:ScriptDom.AssignmentKind * CursorDefinition:CursorDefinition option * Expression:ScalarExpression option * FunctionCallExists:bool * Identifier:Identifier option * Parameters:(ScalarExpression) list * SeparatorType:ScriptDom.SeparatorType * Variable:VariableReference option
  | ShutdownStatement of WithNoWait:bool
  | SignatureStatementBase of SignatureStatementBase
  | StatementWithCtesAndXmlNamespaces of StatementWithCtesAndXmlNamespaces
  | SymmetricKeyStatement of SymmetricKeyStatement
  | TSqlStatementSnippet of Script:String option
  | TextModificationStatement of TextModificationStatement
  | ThrowStatement of ErrorNumber:ValueExpression option * Message:ValueExpression option * State:ValueExpression option
  | TransactionStatement of TransactionStatement
  | TriggerStatementBody of TriggerStatementBody
  | TruncateTableStatement of PartitionRanges:(CompressionPartitionRange) list * TableName:SchemaObjectName option
  | TryCatchStatement of CatchStatements:StatementList option * TryStatements:StatementList option
  | UpdateStatisticsStatement of SchemaObjectName:SchemaObjectName option * StatisticsOptions:(StatisticsOption) list * SubElements:(Identifier) list
  | UseFederationStatement of DistributionName:Identifier option * FederationName:Identifier option * Filtering:bool * Value:ScalarExpression option
  | UseStatement of DatabaseName:Identifier option
  | UserStatement of UserStatement
  | ViewStatementBody of ViewStatementBody
  | WaitForStatement of Parameter:ValueExpression option * Statement:WaitForSupportedStatement option * Timeout:ScalarExpression option * WaitForOption:ScriptDom.WaitForOption
  | WaitForSupportedStatement of WaitForSupportedStatement
  | WhileStatement of Predicate:BooleanExpression option * Statement:TSqlStatement option
  | WorkloadClassifierStatement of WorkloadClassifierStatement
  | WorkloadGroupStatement of WorkloadGroupStatement
  member this.ToCs() : ScriptDom.TSqlStatement =
    match this with
    | AlterAsymmetricKeyStatement(AttestedBy=aAttestedBy; DecryptionPassword=aDecryptionPassword; EncryptionPassword=aEncryptionPassword; Kind=aKind; Name=aName) ->
      let ret = ScriptDom.AlterAsymmetricKeyStatement()
      ret.AttestedBy <- aAttestedBy |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DecryptionPassword <- aDecryptionPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.EncryptionPassword <- aEncryptionPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Kind <- aKind
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | AlterAuthorizationStatement(PrincipalName=aPrincipalName; SecurityTargetObject=aSecurityTargetObject; ToSchemaOwner=aToSchemaOwner) ->
      let ret = ScriptDom.AlterAuthorizationStatement()
      ret.PrincipalName <- aPrincipalName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SecurityTargetObject <- aSecurityTargetObject |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ToSchemaOwner <- aToSchemaOwner
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | AlterCreateEndpointStatementBase(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | AlterCreateServiceStatementBase(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | AlterCryptographicProviderStatement(File=aFile; Name=aName; Option=aOption) ->
      let ret = ScriptDom.AlterCryptographicProviderStatement()
      ret.File <- aFile |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Option <- aOption
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | AlterDatabaseScopedConfigurationStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | AlterDatabaseStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | AlterFederationStatement(Boundary=aBoundary; DistributionName=aDistributionName; Kind=aKind; Name=aName) ->
      let ret = ScriptDom.AlterFederationStatement()
      ret.Boundary <- aBoundary |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DistributionName <- aDistributionName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Kind <- aKind
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | AlterFullTextIndexStatement(Action=aAction; OnName=aOnName) ->
      let ret = ScriptDom.AlterFullTextIndexStatement()
      ret.Action <- aAction |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OnName <- aOnName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | AlterFullTextStopListStatement(Action=aAction; Name=aName) ->
      let ret = ScriptDom.AlterFullTextStopListStatement()
      ret.Action <- aAction |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | AlterLoginStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | AlterPartitionFunctionStatement(Boundary=aBoundary; IsSplit=aIsSplit; Name=aName) ->
      let ret = ScriptDom.AlterPartitionFunctionStatement()
      ret.Boundary <- aBoundary |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsSplit <- aIsSplit
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | AlterPartitionSchemeStatement(FileGroup=aFileGroup; Name=aName) ->
      let ret = ScriptDom.AlterPartitionSchemeStatement()
      ret.FileGroup <- aFileGroup |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | AlterResourceGovernorStatement(ClassifierFunction=aClassifierFunction; Command=aCommand) ->
      let ret = ScriptDom.AlterResourceGovernorStatement()
      ret.ClassifierFunction <- aClassifierFunction |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Command <- aCommand
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | AlterSchemaStatement(Name=aName; ObjectKind=aObjectKind; ObjectName=aObjectName) ->
      let ret = ScriptDom.AlterSchemaStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ObjectKind <- aObjectKind
      ret.ObjectName <- aObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | AlterSearchPropertyListStatement(Action=aAction; Name=aName) ->
      let ret = ScriptDom.AlterSearchPropertyListStatement()
      ret.Action <- aAction |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | AlterServerConfigurationSetBufferPoolExtensionStatement(Options=aOptions) ->
      let ret = ScriptDom.AlterServerConfigurationSetBufferPoolExtensionStatement()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | AlterServerConfigurationSetDiagnosticsLogStatement(Options=aOptions) ->
      let ret = ScriptDom.AlterServerConfigurationSetDiagnosticsLogStatement()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | AlterServerConfigurationSetExternalAuthenticationStatement(Options=aOptions) ->
      let ret = ScriptDom.AlterServerConfigurationSetExternalAuthenticationStatement()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | AlterServerConfigurationSetFailoverClusterPropertyStatement(Options=aOptions) ->
      let ret = ScriptDom.AlterServerConfigurationSetFailoverClusterPropertyStatement()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | AlterServerConfigurationSetHadrClusterStatement(Options=aOptions) ->
      let ret = ScriptDom.AlterServerConfigurationSetHadrClusterStatement()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | AlterServerConfigurationSetSoftNumaStatement(Options=aOptions) ->
      let ret = ScriptDom.AlterServerConfigurationSetSoftNumaStatement()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | AlterServerConfigurationStatement(ProcessAffinity=aProcessAffinity; ProcessAffinityRanges=aProcessAffinityRanges) ->
      let ret = ScriptDom.AlterServerConfigurationStatement()
      ret.ProcessAffinity <- aProcessAffinity
      for e in aProcessAffinityRanges do ret.ProcessAffinityRanges.Add (e.ToCs())
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | AlterServiceMasterKeyStatement(Account=aAccount; Kind=aKind; Password=aPassword) ->
      let ret = ScriptDom.AlterServiceMasterKeyStatement()
      ret.Account <- aAccount |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Kind <- aKind
      ret.Password <- aPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | AlterTableStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | AlterXmlSchemaCollectionStatement(Expression=aExpression; Name=aName) ->
      let ret = ScriptDom.AlterXmlSchemaCollectionStatement()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | ApplicationRoleStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | AssemblyStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | AuditSpecificationStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | AvailabilityGroupStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | BackupRestoreMasterKeyStatementBase(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | BackupStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | BeginConversationTimerStatement(Handle=aHandle; Timeout=aTimeout) ->
      let ret = ScriptDom.BeginConversationTimerStatement()
      ret.Handle <- aHandle |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Timeout <- aTimeout |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | BeginDialogStatement(ContractName=aContractName; Handle=aHandle; InitiatorServiceName=aInitiatorServiceName; InstanceSpec=aInstanceSpec; IsConversation=aIsConversation; Options=aOptions; TargetServiceName=aTargetServiceName) ->
      let ret = ScriptDom.BeginDialogStatement()
      ret.ContractName <- aContractName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Handle <- aHandle |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.InitiatorServiceName <- aInitiatorServiceName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.InstanceSpec <- aInstanceSpec |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsConversation <- aIsConversation
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.TargetServiceName <- aTargetServiceName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | BeginEndBlockStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | BreakStatement -> ScriptDom.BreakStatement() :> ScriptDom.TSqlStatement (* 327 *)
    | BrokerPriorityStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | BulkInsertBase(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | CertificateStatementBase(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | CheckpointStatement(Duration=aDuration) ->
      let ret = ScriptDom.CheckpointStatement()
      ret.Duration <- aDuration |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | CloseMasterKeyStatement -> ScriptDom.CloseMasterKeyStatement() :> ScriptDom.TSqlStatement (* 327 *)
    | CloseSymmetricKeyStatement(All=aAll; Name=aName) ->
      let ret = ScriptDom.CloseSymmetricKeyStatement()
      ret.All <- aAll
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | ColumnEncryptionKeyStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | ContinueStatement -> ScriptDom.ContinueStatement() :> ScriptDom.TSqlStatement (* 327 *)
    | CopyStatement(From=aFrom; Into=aInto; OptimizerHints=aOptimizerHints; Options=aOptions) ->
      let ret = ScriptDom.CopyStatement()
      for e in aFrom do ret.From.Add (e.ToCs())
      ret.Into <- aInto |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptimizerHints do ret.OptimizerHints.Add (e.ToCs())
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | CreateAggregateStatement(AssemblyName=aAssemblyName; Name=aName; Parameters=aParameters; ReturnType=aReturnType) ->
      let ret = ScriptDom.CreateAggregateStatement()
      ret.AssemblyName <- aAssemblyName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret.ReturnType <- aReturnType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | CreateAsymmetricKeyStatement(EncryptionAlgorithm=aEncryptionAlgorithm; KeySource=aKeySource; Name=aName; Owner=aOwner; Password=aPassword) ->
      let ret = ScriptDom.CreateAsymmetricKeyStatement()
      ret.EncryptionAlgorithm <- aEncryptionAlgorithm
      ret.KeySource <- aKeySource |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Owner <- aOwner |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Password <- aPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | CreateColumnMasterKeyStatement(Name=aName; Parameters=aParameters) ->
      let ret = ScriptDom.CreateColumnMasterKeyStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | CreateColumnStoreIndexStatement(Clustered=aClustered; Columns=aColumns; FilterPredicate=aFilterPredicate; IndexOptions=aIndexOptions; Name=aName; OnFileGroupOrPartitionScheme=aOnFileGroupOrPartitionScheme; OnName=aOnName; OrderedColumns=aOrderedColumns) ->
      let ret = ScriptDom.CreateColumnStoreIndexStatement()
      ret.Clustered <- Option.toNullable aClustered
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.FilterPredicate <- aFilterPredicate |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aIndexOptions do ret.IndexOptions.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OnFileGroupOrPartitionScheme <- aOnFileGroupOrPartitionScheme |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OnName <- aOnName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOrderedColumns do ret.OrderedColumns.Add (e.ToCs())
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | CreateContractStatement(Messages=aMessages; Name=aName; Owner=aOwner) ->
      let ret = ScriptDom.CreateContractStatement()
      for e in aMessages do ret.Messages.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Owner <- aOwner |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | CreateCryptographicProviderStatement(File=aFile; Name=aName) ->
      let ret = ScriptDom.CreateCryptographicProviderStatement()
      ret.File <- aFile |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | CreateDatabaseStatement(AttachMode=aAttachMode; Collation=aCollation; Containment=aContainment; CopyOf=aCopyOf; DatabaseName=aDatabaseName; DatabaseSnapshot=aDatabaseSnapshot; FileGroups=aFileGroups; LogOn=aLogOn; Options=aOptions) ->
      let ret = ScriptDom.CreateDatabaseStatement()
      ret.AttachMode <- aAttachMode
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Containment <- aContainment |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.CopyOf <- aCopyOf |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DatabaseName <- aDatabaseName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DatabaseSnapshot <- aDatabaseSnapshot |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aFileGroups do ret.FileGroups.Add (e.ToCs())
      for e in aLogOn do ret.LogOn.Add (e.ToCs())
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | CreateDefaultStatement(Expression=aExpression; Name=aName) ->
      let ret = ScriptDom.CreateDefaultStatement()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | CreateEventNotificationStatement(BrokerInstanceSpecifier=aBrokerInstanceSpecifier; BrokerService=aBrokerService; EventTypeGroups=aEventTypeGroups; Name=aName; Scope=aScope; WithFanIn=aWithFanIn) ->
      let ret = ScriptDom.CreateEventNotificationStatement()
      ret.BrokerInstanceSpecifier <- aBrokerInstanceSpecifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.BrokerService <- aBrokerService |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aEventTypeGroups do ret.EventTypeGroups.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Scope <- aScope |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WithFanIn <- aWithFanIn
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | CreateFederationStatement(DataType=aDataType; DistributionName=aDistributionName; Name=aName) ->
      let ret = ScriptDom.CreateFederationStatement()
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DistributionName <- aDistributionName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | CreateFullTextIndexStatement(CatalogAndFileGroup=aCatalogAndFileGroup; FullTextIndexColumns=aFullTextIndexColumns; KeyIndexName=aKeyIndexName; OnName=aOnName; Options=aOptions) ->
      let ret = ScriptDom.CreateFullTextIndexStatement()
      ret.CatalogAndFileGroup <- aCatalogAndFileGroup |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aFullTextIndexColumns do ret.FullTextIndexColumns.Add (e.ToCs())
      ret.KeyIndexName <- aKeyIndexName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OnName <- aOnName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | CreateFullTextStopListStatement(DatabaseName=aDatabaseName; IsSystemStopList=aIsSystemStopList; Name=aName; Owner=aOwner; SourceStopListName=aSourceStopListName) ->
      let ret = ScriptDom.CreateFullTextStopListStatement()
      ret.DatabaseName <- aDatabaseName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsSystemStopList <- aIsSystemStopList
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Owner <- aOwner |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SourceStopListName <- aSourceStopListName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | CreateLoginStatement(Name=aName; Source=aSource) ->
      let ret = ScriptDom.CreateLoginStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Source <- aSource |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | CreatePartitionFunctionStatement(BoundaryValues=aBoundaryValues; Name=aName; ParameterType=aParameterType; Range=aRange) ->
      let ret = ScriptDom.CreatePartitionFunctionStatement()
      for e in aBoundaryValues do ret.BoundaryValues.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ParameterType <- aParameterType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Range <- aRange
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | CreatePartitionSchemeStatement(FileGroups=aFileGroups; IsAll=aIsAll; Name=aName; PartitionFunction=aPartitionFunction) ->
      let ret = ScriptDom.CreatePartitionSchemeStatement()
      for e in aFileGroups do ret.FileGroups.Add (e.ToCs())
      ret.IsAll <- aIsAll
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PartitionFunction <- aPartitionFunction |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | CreateRuleStatement(Expression=aExpression; Name=aName) ->
      let ret = ScriptDom.CreateRuleStatement()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | CreateSchemaStatement(Name=aName; Owner=aOwner; StatementList=aStatementList) ->
      let ret = ScriptDom.CreateSchemaStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Owner <- aOwner |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StatementList <- aStatementList |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | CreateSearchPropertyListStatement(Name=aName; Owner=aOwner; SourceSearchPropertyList=aSourceSearchPropertyList) ->
      let ret = ScriptDom.CreateSearchPropertyListStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Owner <- aOwner |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SourceSearchPropertyList <- aSourceSearchPropertyList |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | CreateSpatialIndexStatement(Name=aName; Object=aObject; OnFileGroup=aOnFileGroup; SpatialColumnName=aSpatialColumnName; SpatialIndexOptions=aSpatialIndexOptions; SpatialIndexingScheme=aSpatialIndexingScheme) ->
      let ret = ScriptDom.CreateSpatialIndexStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Object <- aObject |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OnFileGroup <- aOnFileGroup |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SpatialColumnName <- aSpatialColumnName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aSpatialIndexOptions do ret.SpatialIndexOptions.Add (e.ToCs())
      ret.SpatialIndexingScheme <- aSpatialIndexingScheme
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | CreateStatisticsStatement(Columns=aColumns; FilterPredicate=aFilterPredicate; Name=aName; OnName=aOnName; StatisticsOptions=aStatisticsOptions) ->
      let ret = ScriptDom.CreateStatisticsStatement()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.FilterPredicate <- aFilterPredicate |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OnName <- aOnName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aStatisticsOptions do ret.StatisticsOptions.Add (e.ToCs())
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | CreateSynonymStatement(ForName=aForName; Name=aName) ->
      let ret = ScriptDom.CreateSynonymStatement()
      ret.ForName <- aForName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | CreateTableStatement(AsEdge=aAsEdge; AsFileTable=aAsFileTable; AsNode=aAsNode; CtasColumns=aCtasColumns; Definition=aDefinition; FederationScheme=aFederationScheme; FileStreamOn=aFileStreamOn; OnFileGroupOrPartitionScheme=aOnFileGroupOrPartitionScheme; Options=aOptions; SchemaObjectName=aSchemaObjectName; SelectStatement=aSelectStatement; TextImageOn=aTextImageOn) ->
      let ret = ScriptDom.CreateTableStatement()
      ret.AsEdge <- aAsEdge
      ret.AsFileTable <- aAsFileTable
      ret.AsNode <- aAsNode
      for e in aCtasColumns do ret.CtasColumns.Add (e.ToCs())
      ret.Definition <- aDefinition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FederationScheme <- aFederationScheme |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FileStreamOn <- aFileStreamOn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OnFileGroupOrPartitionScheme <- aOnFileGroupOrPartitionScheme |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SelectStatement <- aSelectStatement |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TextImageOn <- aTextImageOn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | CreateTypeStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | CreateXmlSchemaCollectionStatement(Expression=aExpression; Name=aName) ->
      let ret = ScriptDom.CreateXmlSchemaCollectionStatement()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | CredentialStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | CursorStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | DatabaseEncryptionKeyStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | DbccStatement(Command=aCommand; DllName=aDllName; Literals=aLiterals; Options=aOptions; OptionsUseJoin=aOptionsUseJoin; ParenthesisRequired=aParenthesisRequired) ->
      let ret = ScriptDom.DbccStatement()
      ret.Command <- aCommand
      ret.DllName <- aDllName |> Option.toObj
      for e in aLiterals do ret.Literals.Add (e.ToCs())
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.OptionsUseJoin <- aOptionsUseJoin
      ret.ParenthesisRequired <- aParenthesisRequired
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | DeclareCursorStatement(CursorDefinition=aCursorDefinition; Name=aName) ->
      let ret = ScriptDom.DeclareCursorStatement()
      ret.CursorDefinition <- aCursorDefinition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | DeclareTableVariableStatement(Body=aBody) ->
      let ret = ScriptDom.DeclareTableVariableStatement()
      ret.Body <- aBody |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | DeclareVariableStatement(Declarations=aDeclarations) ->
      let ret = ScriptDom.DeclareVariableStatement()
      for e in aDeclarations do ret.Declarations.Add (e.ToCs())
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | DiskStatement(DiskStatementType=aDiskStatementType; Options=aOptions) ->
      let ret = ScriptDom.DiskStatement()
      ret.DiskStatementType <- aDiskStatementType
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | DropChildObjectsStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | DropDatabaseEncryptionKeyStatement -> ScriptDom.DropDatabaseEncryptionKeyStatement() :> ScriptDom.TSqlStatement (* 327 *)
    | DropDatabaseStatement(Databases=aDatabases; IsIfExists=aIsIfExists) ->
      let ret = ScriptDom.DropDatabaseStatement()
      for e in aDatabases do ret.Databases.Add (e.ToCs())
      ret.IsIfExists <- aIsIfExists
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | DropEventNotificationStatement(Notifications=aNotifications; Scope=aScope) ->
      let ret = ScriptDom.DropEventNotificationStatement()
      for e in aNotifications do ret.Notifications.Add (e.ToCs())
      ret.Scope <- aScope |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | DropFullTextIndexStatement(TableName=aTableName) ->
      let ret = ScriptDom.DropFullTextIndexStatement()
      ret.TableName <- aTableName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | DropIndexStatement(DropIndexClauses=aDropIndexClauses; IsIfExists=aIsIfExists) ->
      let ret = ScriptDom.DropIndexStatement()
      for e in aDropIndexClauses do ret.DropIndexClauses.Add (e.ToCs())
      ret.IsIfExists <- aIsIfExists
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | DropMasterKeyStatement -> ScriptDom.DropMasterKeyStatement() :> ScriptDom.TSqlStatement (* 327 *)
    | DropObjectsStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | DropQueueStatement(Name=aName) ->
      let ret = ScriptDom.DropQueueStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | DropSchemaStatement(DropBehavior=aDropBehavior; IsIfExists=aIsIfExists; Schema=aSchema) ->
      let ret = ScriptDom.DropSchemaStatement()
      ret.DropBehavior <- aDropBehavior
      ret.IsIfExists <- aIsIfExists
      ret.Schema <- aSchema |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | DropTypeStatement(IsIfExists=aIsIfExists; Name=aName) ->
      let ret = ScriptDom.DropTypeStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | DropUnownedObjectStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | DropXmlSchemaCollectionStatement(Name=aName) ->
      let ret = ScriptDom.DropXmlSchemaCollectionStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | EnableDisableTriggerStatement(All=aAll; TriggerEnforcement=aTriggerEnforcement; TriggerNames=aTriggerNames; TriggerObject=aTriggerObject) ->
      let ret = ScriptDom.EnableDisableTriggerStatement()
      ret.All <- aAll
      ret.TriggerEnforcement <- aTriggerEnforcement
      for e in aTriggerNames do ret.TriggerNames.Add (e.ToCs())
      ret.TriggerObject <- aTriggerObject |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | EndConversationStatement(Conversation=aConversation; ErrorCode=aErrorCode; ErrorDescription=aErrorDescription; WithCleanup=aWithCleanup) ->
      let ret = ScriptDom.EndConversationStatement()
      ret.Conversation <- aConversation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ErrorCode <- aErrorCode |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ErrorDescription <- aErrorDescription |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WithCleanup <- aWithCleanup
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | EventSessionStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | ExecuteAsStatement(Cookie=aCookie; ExecuteContext=aExecuteContext; WithNoRevert=aWithNoRevert) ->
      let ret = ScriptDom.ExecuteAsStatement()
      ret.Cookie <- aCookie |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ExecuteContext <- aExecuteContext |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WithNoRevert <- aWithNoRevert
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | ExecuteStatement(ExecuteSpecification=aExecuteSpecification; Options=aOptions) ->
      let ret = ScriptDom.ExecuteStatement()
      ret.ExecuteSpecification <- aExecuteSpecification |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | ExternalDataSourceStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | ExternalFileFormatStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | ExternalResourcePoolStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | ExternalTableStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | FullTextCatalogStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | GoToStatement(LabelName=aLabelName) ->
      let ret = ScriptDom.GoToStatement()
      ret.LabelName <- aLabelName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | IfStatement(ElseStatement=aElseStatement; Predicate=aPredicate; ThenStatement=aThenStatement) ->
      let ret = ScriptDom.IfStatement()
      ret.ElseStatement <- aElseStatement |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Predicate <- aPredicate |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ThenStatement <- aThenStatement |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | IndexDefinition(Columns=aColumns; FileStreamOn=aFileStreamOn; FilterPredicate=aFilterPredicate; IndexOptions=aIndexOptions; IndexType=aIndexType; Name=aName; OnFileGroupOrPartitionScheme=aOnFileGroupOrPartitionScheme; Unique=aUnique) ->
      let ret = ScriptDom.IndexDefinition()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.FileStreamOn <- aFileStreamOn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FilterPredicate <- aFilterPredicate |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aIndexOptions do ret.IndexOptions.Add (e.ToCs())
      ret.IndexType <- aIndexType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OnFileGroupOrPartitionScheme <- aOnFileGroupOrPartitionScheme |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Unique <- aUnique
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | IndexStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | KillQueryNotificationSubscriptionStatement(All=aAll; SubscriptionId=aSubscriptionId) ->
      let ret = ScriptDom.KillQueryNotificationSubscriptionStatement()
      ret.All <- aAll
      ret.SubscriptionId <- aSubscriptionId |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | KillStatement(Parameter=aParameter; WithStatusOnly=aWithStatusOnly) ->
      let ret = ScriptDom.KillStatement()
      ret.Parameter <- aParameter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WithStatusOnly <- aWithStatusOnly
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | KillStatsJobStatement(JobId=aJobId) ->
      let ret = ScriptDom.KillStatsJobStatement()
      ret.JobId <- aJobId |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | LabelStatement(Value=aValue) ->
      let ret = ScriptDom.LabelStatement()
      ret.Value <- aValue |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | LineNoStatement(LineNo=aLineNo) ->
      let ret = ScriptDom.LineNoStatement()
      ret.LineNo <- aLineNo |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | MasterKeyStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | MessageTypeStatementBase(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | MoveConversationStatement(Conversation=aConversation; Group=aGroup) ->
      let ret = ScriptDom.MoveConversationStatement()
      ret.Conversation <- aConversation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Group <- aGroup |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | OpenMasterKeyStatement(Password=aPassword) ->
      let ret = ScriptDom.OpenMasterKeyStatement()
      ret.Password <- aPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | OpenSymmetricKeyStatement(DecryptionMechanism=aDecryptionMechanism; Name=aName) ->
      let ret = ScriptDom.OpenSymmetricKeyStatement()
      ret.DecryptionMechanism <- aDecryptionMechanism |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | PrintStatement(Expression=aExpression) ->
      let ret = ScriptDom.PrintStatement()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | ProcedureStatementBodyBase(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | QueueStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | RaiseErrorLegacyStatement(FirstParameter=aFirstParameter; SecondParameter=aSecondParameter) ->
      let ret = ScriptDom.RaiseErrorLegacyStatement()
      ret.FirstParameter <- aFirstParameter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SecondParameter <- aSecondParameter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | RaiseErrorStatement(FirstParameter=aFirstParameter; OptionalParameters=aOptionalParameters; RaiseErrorOptions=aRaiseErrorOptions; SecondParameter=aSecondParameter; ThirdParameter=aThirdParameter) ->
      let ret = ScriptDom.RaiseErrorStatement()
      ret.FirstParameter <- aFirstParameter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptionalParameters do ret.OptionalParameters.Add (e.ToCs())
      ret.RaiseErrorOptions <- aRaiseErrorOptions
      ret.SecondParameter <- aSecondParameter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ThirdParameter <- aThirdParameter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | ReadTextStatement(Column=aColumn; HoldLock=aHoldLock; Offset=aOffset; Size=aSize; TextPointer=aTextPointer) ->
      let ret = ScriptDom.ReadTextStatement()
      ret.Column <- aColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.HoldLock <- aHoldLock
      ret.Offset <- aOffset |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Size <- aSize |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TextPointer <- aTextPointer |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | ReconfigureStatement(WithOverride=aWithOverride) ->
      let ret = ScriptDom.ReconfigureStatement()
      ret.WithOverride <- aWithOverride
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | RemoteServiceBindingStatementBase(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | RenameEntityStatement(NewName=aNewName; OldName=aOldName; RenameEntityType=aRenameEntityType; SeparatorType=aSeparatorType) ->
      let ret = ScriptDom.RenameEntityStatement()
      ret.NewName <- aNewName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OldName <- aOldName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.RenameEntityType <- aRenameEntityType
      ret.SeparatorType <- Option.toNullable aSeparatorType
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | ResourcePoolStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | RestoreStatement(DatabaseName=aDatabaseName; Devices=aDevices; Files=aFiles; Kind=aKind; Options=aOptions) ->
      let ret = ScriptDom.RestoreStatement()
      ret.DatabaseName <- aDatabaseName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aDevices do ret.Devices.Add (e.ToCs())
      for e in aFiles do ret.Files.Add (e.ToCs())
      ret.Kind <- aKind
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | ReturnStatement(Expression=aExpression) ->
      let ret = ScriptDom.ReturnStatement()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | RevertStatement(Cookie=aCookie) ->
      let ret = ScriptDom.RevertStatement()
      ret.Cookie <- aCookie |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | RoleStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | RouteStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | SecurityPolicyStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | SecurityStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | SecurityStatementBody80(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | SendStatement(ConversationHandles=aConversationHandles; MessageBody=aMessageBody; MessageTypeName=aMessageTypeName) ->
      let ret = ScriptDom.SendStatement()
      for e in aConversationHandles do ret.ConversationHandles.Add (e.ToCs())
      ret.MessageBody <- aMessageBody |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.MessageTypeName <- aMessageTypeName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | SensitivityClassificationStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | SequenceStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | ServerAuditStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | SetCommandStatement(Commands=aCommands) ->
      let ret = ScriptDom.SetCommandStatement()
      for e in aCommands do ret.Commands.Add (e.ToCs())
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | SetErrorLevelStatement(Level=aLevel) ->
      let ret = ScriptDom.SetErrorLevelStatement()
      ret.Level <- aLevel |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | SetOnOffStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | SetRowCountStatement(NumberRows=aNumberRows) ->
      let ret = ScriptDom.SetRowCountStatement()
      ret.NumberRows <- aNumberRows |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | SetTextSizeStatement(TextSize=aTextSize) ->
      let ret = ScriptDom.SetTextSizeStatement()
      ret.TextSize <- aTextSize |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | SetTransactionIsolationLevelStatement(Level=aLevel) ->
      let ret = ScriptDom.SetTransactionIsolationLevelStatement()
      ret.Level <- aLevel
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | SetUserStatement(UserName=aUserName; WithNoReset=aWithNoReset) ->
      let ret = ScriptDom.SetUserStatement()
      ret.UserName <- aUserName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WithNoReset <- aWithNoReset
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | SetVariableStatement(AssignmentKind=aAssignmentKind; CursorDefinition=aCursorDefinition; Expression=aExpression; FunctionCallExists=aFunctionCallExists; Identifier=aIdentifier; Parameters=aParameters; SeparatorType=aSeparatorType; Variable=aVariable) ->
      let ret = ScriptDom.SetVariableStatement()
      ret.AssignmentKind <- aAssignmentKind
      ret.CursorDefinition <- aCursorDefinition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FunctionCallExists <- aFunctionCallExists
      ret.Identifier <- aIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret.SeparatorType <- aSeparatorType
      ret.Variable <- aVariable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | ShutdownStatement(WithNoWait=aWithNoWait) ->
      let ret = ScriptDom.ShutdownStatement()
      ret.WithNoWait <- aWithNoWait
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | SignatureStatementBase(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | StatementWithCtesAndXmlNamespaces(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | SymmetricKeyStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | TSqlStatementSnippet(Script=aScript) ->
      let ret = ScriptDom.TSqlStatementSnippet()
      ret.Script <- aScript |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | TextModificationStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | ThrowStatement(ErrorNumber=aErrorNumber; Message=aMessage; State=aState) ->
      let ret = ScriptDom.ThrowStatement()
      ret.ErrorNumber <- aErrorNumber |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Message <- aMessage |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.State <- aState |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | TransactionStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | TriggerStatementBody(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | TruncateTableStatement(PartitionRanges=aPartitionRanges; TableName=aTableName) ->
      let ret = ScriptDom.TruncateTableStatement()
      for e in aPartitionRanges do ret.PartitionRanges.Add (e.ToCs())
      ret.TableName <- aTableName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | TryCatchStatement(CatchStatements=aCatchStatements; TryStatements=aTryStatements) ->
      let ret = ScriptDom.TryCatchStatement()
      ret.CatchStatements <- aCatchStatements |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TryStatements <- aTryStatements |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | UpdateStatisticsStatement(SchemaObjectName=aSchemaObjectName; StatisticsOptions=aStatisticsOptions; SubElements=aSubElements) ->
      let ret = ScriptDom.UpdateStatisticsStatement()
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aStatisticsOptions do ret.StatisticsOptions.Add (e.ToCs())
      for e in aSubElements do ret.SubElements.Add (e.ToCs())
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | UseFederationStatement(DistributionName=aDistributionName; FederationName=aFederationName; Filtering=aFiltering; Value=aValue) ->
      let ret = ScriptDom.UseFederationStatement()
      ret.DistributionName <- aDistributionName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FederationName <- aFederationName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Filtering <- aFiltering
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | UseStatement(DatabaseName=aDatabaseName) ->
      let ret = ScriptDom.UseStatement()
      ret.DatabaseName <- aDatabaseName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | UserStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | ViewStatementBody(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | WaitForStatement(Parameter=aParameter; Statement=aStatement; Timeout=aTimeout; WaitForOption=aWaitForOption) ->
      let ret = ScriptDom.WaitForStatement()
      ret.Parameter <- aParameter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Statement <- aStatement |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Timeout <- aTimeout |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WaitForOption <- aWaitForOption
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | WaitForSupportedStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | WhileStatement(Predicate=aPredicate; Statement=aStatement) ->
      let ret = ScriptDom.WhileStatement()
      ret.Predicate <- aPredicate |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Statement <- aStatement |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 335 *)
    | WorkloadClassifierStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
    | WorkloadGroupStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 345 *)
  static member FromCs(src:ScriptDom.TSqlStatement, fragmentMapping:FragmentMapping) : TSqlStatement =
    let ret =
      match src with
      | :? ScriptDom.AlterAsymmetricKeyStatement as src ->
        TSqlStatement.AlterAsymmetricKeyStatement((src.AttestedBy |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.DecryptionPassword |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.EncryptionPassword |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.Kind),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.AlterAuthorizationStatement as src ->
        TSqlStatement.AlterAuthorizationStatement((src.PrincipalName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.SecurityTargetObject |> Option.ofObj |> Option.map (fun x -> SecurityTargetObject.FromCs(x, fragmentMapping))),(src.ToSchemaOwner))
      | :? ScriptDom.AlterCreateEndpointStatementBase as src ->
        match src with
        | :? ScriptDom.AlterEndpointStatement as src->
          TSqlStatement.AlterCreateEndpointStatementBase((AlterCreateEndpointStatementBase.AlterEndpointStatement((src.Affinity |> Option.ofObj |> Option.map (fun x -> EndpointAffinity.FromCs(x, fragmentMapping))), (src.EndpointType), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.PayloadOptions |> Seq.map (fun x -> PayloadOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Protocol), (src.ProtocolOptions |> Seq.map (fun x -> EndpointProtocolOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.State))  ))
        | :? ScriptDom.CreateEndpointStatement as src->
          TSqlStatement.AlterCreateEndpointStatementBase((AlterCreateEndpointStatementBase.CreateEndpointStatement((src.Affinity |> Option.ofObj |> Option.map (fun x -> EndpointAffinity.FromCs(x, fragmentMapping))), (src.EndpointType), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Owner |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.PayloadOptions |> Seq.map (fun x -> PayloadOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Protocol), (src.ProtocolOptions |> Seq.map (fun x -> EndpointProtocolOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.State))  ))
      | :? ScriptDom.AlterCreateServiceStatementBase as src ->
        match src with
        | :? ScriptDom.AlterServiceStatement as src->
          TSqlStatement.AlterCreateServiceStatementBase((AlterCreateServiceStatementBase.AlterServiceStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.QueueName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.ServiceContracts |> Seq.map (fun src -> ServiceContract.ServiceContract((src.Action), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))) |> List.ofSeq))  ))
        | :? ScriptDom.CreateServiceStatement as src->
          TSqlStatement.AlterCreateServiceStatementBase((AlterCreateServiceStatementBase.CreateServiceStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Owner |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.QueueName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.ServiceContracts |> Seq.map (fun src -> ServiceContract.ServiceContract((src.Action), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))) |> List.ofSeq))  ))
      | :? ScriptDom.AlterCryptographicProviderStatement as src ->
        TSqlStatement.AlterCryptographicProviderStatement((src.File |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Option))
      | :? ScriptDom.AlterDatabaseScopedConfigurationStatement as src ->
        match src with
        | :? ScriptDom.AlterDatabaseScopedConfigurationClearStatement as src->
          TSqlStatement.AlterDatabaseScopedConfigurationStatement((AlterDatabaseScopedConfigurationStatement.AlterDatabaseScopedConfigurationClearStatement((src.Option |> Option.ofObj |> Option.map (fun x -> DatabaseConfigurationClearOption.FromCs(x, fragmentMapping))), (src.Secondary))  ))
        | :? ScriptDom.AlterDatabaseScopedConfigurationSetStatement as src->
          TSqlStatement.AlterDatabaseScopedConfigurationStatement((AlterDatabaseScopedConfigurationStatement.AlterDatabaseScopedConfigurationSetStatement((src.Option |> Option.ofObj |> Option.map (fun x -> DatabaseConfigurationSetOption.FromCs(x, fragmentMapping))), (src.Secondary))  ))
      | :? ScriptDom.AlterDatabaseStatement as src ->
        match src with
        | :? ScriptDom.AlterDatabaseAddFileGroupStatement as src->
          TSqlStatement.AlterDatabaseStatement((AlterDatabaseStatement.AlterDatabaseAddFileGroupStatement((src.ContainsFileStream), (src.ContainsMemoryOptimizedData), (src.DatabaseName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.FileGroup |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.UseCurrent))  ))
        | :? ScriptDom.AlterDatabaseAddFileStatement as src->
          TSqlStatement.AlterDatabaseStatement((AlterDatabaseStatement.AlterDatabaseAddFileStatement((src.DatabaseName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.FileDeclarations |> Seq.map (fun src -> FileDeclaration.FileDeclaration((src.IsPrimary), (src.Options |> Seq.map (fun x -> FileDeclarationOption.FromCs(x, fragmentMapping)) |> List.ofSeq))) |> List.ofSeq), (src.FileGroup |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.IsLog), (src.UseCurrent))  ))
        | :? ScriptDom.AlterDatabaseCollateStatement as src->
          TSqlStatement.AlterDatabaseStatement((AlterDatabaseStatement.AlterDatabaseCollateStatement((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.DatabaseName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.UseCurrent))  ))
        | :? ScriptDom.AlterDatabaseModifyFileGroupStatement as src->
          TSqlStatement.AlterDatabaseStatement((AlterDatabaseStatement.AlterDatabaseModifyFileGroupStatement((src.DatabaseName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.FileGroup |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.MakeDefault), (src.NewFileGroupName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Termination |> Option.ofObj |> Option.map (fun x -> AlterDatabaseTermination.FromCs(x, fragmentMapping))), (src.UpdatabilityOption), (src.UseCurrent))  ))
        | :? ScriptDom.AlterDatabaseModifyFileStatement as src->
          TSqlStatement.AlterDatabaseStatement((AlterDatabaseStatement.AlterDatabaseModifyFileStatement((src.DatabaseName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.FileDeclaration |> Option.ofObj |> Option.map (fun x -> FileDeclaration.FromCs(x, fragmentMapping))), (src.UseCurrent))  ))
        | :? ScriptDom.AlterDatabaseModifyNameStatement as src->
          TSqlStatement.AlterDatabaseStatement((AlterDatabaseStatement.AlterDatabaseModifyNameStatement((src.DatabaseName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.NewDatabaseName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.UseCurrent))  ))
        | :? ScriptDom.AlterDatabaseRebuildLogStatement as src->
          TSqlStatement.AlterDatabaseStatement((AlterDatabaseStatement.AlterDatabaseRebuildLogStatement((src.DatabaseName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.FileDeclaration |> Option.ofObj |> Option.map (fun x -> FileDeclaration.FromCs(x, fragmentMapping))), (src.UseCurrent))  ))
        | :? ScriptDom.AlterDatabaseRemoveFileGroupStatement as src->
          TSqlStatement.AlterDatabaseStatement((AlterDatabaseStatement.AlterDatabaseRemoveFileGroupStatement((src.DatabaseName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.FileGroup |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.UseCurrent))  ))
        | :? ScriptDom.AlterDatabaseRemoveFileStatement as src->
          TSqlStatement.AlterDatabaseStatement((AlterDatabaseStatement.AlterDatabaseRemoveFileStatement((src.DatabaseName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.File |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.UseCurrent))  ))
        | :? ScriptDom.AlterDatabaseSetStatement as src->
          TSqlStatement.AlterDatabaseStatement((AlterDatabaseStatement.AlterDatabaseSetStatement((src.DatabaseName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Options |> Seq.map (fun x -> DatabaseOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Termination |> Option.ofObj |> Option.map (fun x -> AlterDatabaseTermination.FromCs(x, fragmentMapping))), (src.UseCurrent))  ))
      | :? ScriptDom.AlterFederationStatement as src ->
        TSqlStatement.AlterFederationStatement((src.Boundary |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.DistributionName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Kind),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.AlterFullTextIndexStatement as src ->
        TSqlStatement.AlterFullTextIndexStatement((src.Action |> Option.ofObj |> Option.map (fun x -> AlterFullTextIndexAction.FromCs(x, fragmentMapping))),(src.OnName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.AlterFullTextStopListStatement as src ->
        TSqlStatement.AlterFullTextStopListStatement((src.Action |> Option.ofObj |> Option.map (fun x -> FullTextStopListAction.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.AlterLoginStatement as src ->
        match src with
        | :? ScriptDom.AlterLoginAddDropCredentialStatement as src->
          TSqlStatement.AlterLoginStatement((AlterLoginStatement.AlterLoginAddDropCredentialStatement((src.CredentialName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.IsAdd), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.AlterLoginEnableDisableStatement as src->
          TSqlStatement.AlterLoginStatement((AlterLoginStatement.AlterLoginEnableDisableStatement((src.IsEnable), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.AlterLoginOptionsStatement as src->
          TSqlStatement.AlterLoginStatement((AlterLoginStatement.AlterLoginOptionsStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Options |> Seq.map (fun x -> PrincipalOption.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
      | :? ScriptDom.AlterPartitionFunctionStatement as src ->
        TSqlStatement.AlterPartitionFunctionStatement((src.Boundary |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.IsSplit),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.AlterPartitionSchemeStatement as src ->
        TSqlStatement.AlterPartitionSchemeStatement((src.FileGroup |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.AlterResourceGovernorStatement as src ->
        TSqlStatement.AlterResourceGovernorStatement((src.ClassifierFunction |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.Command))
      | :? ScriptDom.AlterSchemaStatement as src ->
        TSqlStatement.AlterSchemaStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.ObjectKind),(src.ObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.AlterSearchPropertyListStatement as src ->
        TSqlStatement.AlterSearchPropertyListStatement((src.Action |> Option.ofObj |> Option.map (fun x -> SearchPropertyListAction.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.AlterServerConfigurationSetBufferPoolExtensionStatement as src ->
        TSqlStatement.AlterServerConfigurationSetBufferPoolExtensionStatement((src.Options |> Seq.map (fun x -> AlterServerConfigurationBufferPoolExtensionOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.AlterServerConfigurationSetDiagnosticsLogStatement as src ->
        TSqlStatement.AlterServerConfigurationSetDiagnosticsLogStatement((src.Options |> Seq.map (fun x -> AlterServerConfigurationDiagnosticsLogOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.AlterServerConfigurationSetExternalAuthenticationStatement as src ->
        TSqlStatement.AlterServerConfigurationSetExternalAuthenticationStatement((src.Options |> Seq.map (fun x -> AlterServerConfigurationExternalAuthenticationOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.AlterServerConfigurationSetFailoverClusterPropertyStatement as src ->
        TSqlStatement.AlterServerConfigurationSetFailoverClusterPropertyStatement((src.Options |> Seq.map (fun src -> AlterServerConfigurationFailoverClusterPropertyOption.AlterServerConfigurationFailoverClusterPropertyOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (fun x -> OptionValue.FromCs(x, fragmentMapping))))) |> List.ofSeq))
      | :? ScriptDom.AlterServerConfigurationSetHadrClusterStatement as src ->
        TSqlStatement.AlterServerConfigurationSetHadrClusterStatement((src.Options |> Seq.map (fun src -> AlterServerConfigurationHadrClusterOption.AlterServerConfigurationHadrClusterOption((src.IsLocal), (src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (fun x -> OptionValue.FromCs(x, fragmentMapping))))) |> List.ofSeq))
      | :? ScriptDom.AlterServerConfigurationSetSoftNumaStatement as src ->
        TSqlStatement.AlterServerConfigurationSetSoftNumaStatement((src.Options |> Seq.map (fun src -> AlterServerConfigurationSoftNumaOption.AlterServerConfigurationSoftNumaOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (fun x -> OptionValue.FromCs(x, fragmentMapping))))) |> List.ofSeq))
      | :? ScriptDom.AlterServerConfigurationStatement as src ->
        TSqlStatement.AlterServerConfigurationStatement((src.ProcessAffinity),(src.ProcessAffinityRanges |> Seq.map (fun src -> ProcessAffinityRange.ProcessAffinityRange((src.From |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.To |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq))
      | :? ScriptDom.AlterServiceMasterKeyStatement as src ->
        TSqlStatement.AlterServiceMasterKeyStatement((src.Account |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.Kind),(src.Password |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.AlterTableStatement as src ->
        match src with
        | :? ScriptDom.AlterTableAddTableElementStatement as src->
          TSqlStatement.AlterTableStatement((AlterTableStatement.AlterTableAddTableElementStatement((src.Definition |> Option.ofObj |> Option.map (fun x -> TableDefinition.FromCs(x, fragmentMapping))), (src.ExistingRowsCheckEnforcement), (src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.AlterTableAlterColumnStatement as src->
          TSqlStatement.AlterTableStatement((AlterTableStatement.AlterTableAlterColumnStatement((src.AlterTableAlterColumnOption), (src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.Encryption |> Option.ofObj |> Option.map (fun x -> ColumnEncryptionDefinition.FromCs(x, fragmentMapping))), (Option.ofNullable (src.GeneratedAlways)), (src.IsHidden), (src.IsMasked), (src.MaskingFunction |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))), (src.Options |> Seq.map (fun x -> IndexOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.StorageOptions |> Option.ofObj |> Option.map (fun x -> ColumnStorageOptions.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.AlterTableAlterIndexStatement as src->
          TSqlStatement.AlterTableStatement((AlterTableStatement.AlterTableAlterIndexStatement((src.AlterIndexType), (src.IndexIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.IndexOptions |> Seq.map (fun x -> IndexOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.AlterTableAlterPartitionStatement as src->
          TSqlStatement.AlterTableStatement((AlterTableStatement.AlterTableAlterPartitionStatement((src.BoundaryValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.IsSplit), (src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.AlterTableChangeTrackingModificationStatement as src->
          TSqlStatement.AlterTableStatement((AlterTableStatement.AlterTableChangeTrackingModificationStatement((src.IsEnable), (src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.TrackColumnsUpdated))  ))
        | :? ScriptDom.AlterTableConstraintModificationStatement as src->
          TSqlStatement.AlterTableStatement((AlterTableStatement.AlterTableConstraintModificationStatement((src.All), (src.ConstraintEnforcement), (src.ConstraintNames |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.ExistingRowsCheckEnforcement), (src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.AlterTableDropTableElementStatement as src->
          TSqlStatement.AlterTableStatement((AlterTableStatement.AlterTableDropTableElementStatement((src.AlterTableDropTableElements |> Seq.map (fun src -> AlterTableDropTableElement.AlterTableDropTableElement((src.DropClusteredConstraintOptions |> Seq.map (fun x -> DropClusteredConstraintOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.TableElementType))) |> List.ofSeq), (src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.AlterTableFileTableNamespaceStatement as src->
          TSqlStatement.AlterTableStatement((AlterTableStatement.AlterTableFileTableNamespaceStatement((src.IsEnable), (src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.AlterTableRebuildStatement as src->
          TSqlStatement.AlterTableStatement((AlterTableStatement.AlterTableRebuildStatement((src.IndexOptions |> Seq.map (fun x -> IndexOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Partition |> Option.ofObj |> Option.map (fun x -> PartitionSpecifier.FromCs(x, fragmentMapping))), (src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.AlterTableSetStatement as src->
          TSqlStatement.AlterTableStatement((AlterTableStatement.AlterTableSetStatement((src.Options |> Seq.map (fun x -> TableOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.AlterTableSwitchStatement as src->
          TSqlStatement.AlterTableStatement((AlterTableStatement.AlterTableSwitchStatement((src.Options |> Seq.map (fun x -> TableSwitchOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.SourcePartitionNumber |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.TargetPartitionNumber |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.TargetTable |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.AlterTableTriggerModificationStatement as src->
          TSqlStatement.AlterTableStatement((AlterTableStatement.AlterTableTriggerModificationStatement((src.All), (src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.TriggerEnforcement), (src.TriggerNames |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
      | :? ScriptDom.AlterXmlSchemaCollectionStatement as src ->
        TSqlStatement.AlterXmlSchemaCollectionStatement((src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ApplicationRoleStatement as src ->
        match src with
        | :? ScriptDom.AlterApplicationRoleStatement as src->
          TSqlStatement.ApplicationRoleStatement((ApplicationRoleStatement.AlterApplicationRoleStatement((src.ApplicationRoleOptions |> Seq.map (fun src -> ApplicationRoleOption.ApplicationRoleOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CreateApplicationRoleStatement as src->
          TSqlStatement.ApplicationRoleStatement((ApplicationRoleStatement.CreateApplicationRoleStatement((src.ApplicationRoleOptions |> Seq.map (fun src -> ApplicationRoleOption.ApplicationRoleOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.AssemblyStatement as src ->
        match src with
        | :? ScriptDom.AlterAssemblyStatement as src->
          TSqlStatement.AssemblyStatement((AssemblyStatement.AlterAssemblyStatement((src.AddFiles |> Seq.map (fun src -> AddFileSpec.AddFileSpec((src.File |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.FileName |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.DropFiles |> Seq.map (fun x -> Literal.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.IsDropAll), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Options |> Seq.map (fun x -> AssemblyOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Parameters |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.CreateAssemblyStatement as src->
          TSqlStatement.AssemblyStatement((AssemblyStatement.CreateAssemblyStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Options |> Seq.map (fun x -> AssemblyOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Owner |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Parameters |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
      | :? ScriptDom.AuditSpecificationStatement as src ->
        match src with
        | :? ScriptDom.AlterDatabaseAuditSpecificationStatement as src->
          TSqlStatement.AuditSpecificationStatement((AuditSpecificationStatement.AlterDatabaseAuditSpecificationStatement((src.AuditName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.AuditState), (src.Parts |> Seq.map (fun src -> AuditSpecificationPart.AuditSpecificationPart((src.Details |> Option.ofObj |> Option.map (fun x -> AuditSpecificationDetail.FromCs(x, fragmentMapping))), (src.IsDrop))) |> List.ofSeq), (src.SpecificationName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.AlterServerAuditSpecificationStatement as src->
          TSqlStatement.AuditSpecificationStatement((AuditSpecificationStatement.AlterServerAuditSpecificationStatement((src.AuditName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.AuditState), (src.Parts |> Seq.map (fun src -> AuditSpecificationPart.AuditSpecificationPart((src.Details |> Option.ofObj |> Option.map (fun x -> AuditSpecificationDetail.FromCs(x, fragmentMapping))), (src.IsDrop))) |> List.ofSeq), (src.SpecificationName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CreateDatabaseAuditSpecificationStatement as src->
          TSqlStatement.AuditSpecificationStatement((AuditSpecificationStatement.CreateDatabaseAuditSpecificationStatement((src.AuditName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.AuditState), (src.Parts |> Seq.map (fun src -> AuditSpecificationPart.AuditSpecificationPart((src.Details |> Option.ofObj |> Option.map (fun x -> AuditSpecificationDetail.FromCs(x, fragmentMapping))), (src.IsDrop))) |> List.ofSeq), (src.SpecificationName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CreateServerAuditSpecificationStatement as src->
          TSqlStatement.AuditSpecificationStatement((AuditSpecificationStatement.CreateServerAuditSpecificationStatement((src.AuditName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.AuditState), (src.Parts |> Seq.map (fun src -> AuditSpecificationPart.AuditSpecificationPart((src.Details |> Option.ofObj |> Option.map (fun x -> AuditSpecificationDetail.FromCs(x, fragmentMapping))), (src.IsDrop))) |> List.ofSeq), (src.SpecificationName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.AvailabilityGroupStatement as src ->
        match src with
        | :? ScriptDom.AlterAvailabilityGroupStatement as src->
          TSqlStatement.AvailabilityGroupStatement((AvailabilityGroupStatement.AlterAvailabilityGroupStatement((src.Action |> Option.ofObj |> Option.map (fun x -> AlterAvailabilityGroupAction.FromCs(x, fragmentMapping))), (src.AlterAvailabilityGroupStatementType), (src.Databases |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Options |> Seq.map (fun x -> AvailabilityGroupOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Replicas |> Seq.map (fun src -> AvailabilityReplica.AvailabilityReplica((src.Options |> Seq.map (fun x -> AvailabilityReplicaOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.ServerName |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))))) |> List.ofSeq))  ))
        | :? ScriptDom.CreateAvailabilityGroupStatement as src->
          TSqlStatement.AvailabilityGroupStatement((AvailabilityGroupStatement.CreateAvailabilityGroupStatement((src.Databases |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Options |> Seq.map (fun x -> AvailabilityGroupOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Replicas |> Seq.map (fun src -> AvailabilityReplica.AvailabilityReplica((src.Options |> Seq.map (fun x -> AvailabilityReplicaOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.ServerName |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))))) |> List.ofSeq))  ))
      | :? ScriptDom.BackupRestoreMasterKeyStatementBase as src ->
        match src with
        | :? ScriptDom.BackupMasterKeyStatement as src->
          TSqlStatement.BackupRestoreMasterKeyStatementBase((BackupRestoreMasterKeyStatementBase.BackupMasterKeyStatement((src.File |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.Password |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.BackupServiceMasterKeyStatement as src->
          TSqlStatement.BackupRestoreMasterKeyStatementBase((BackupRestoreMasterKeyStatementBase.BackupServiceMasterKeyStatement((src.File |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.Password |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.RestoreMasterKeyStatement as src->
          TSqlStatement.BackupRestoreMasterKeyStatementBase((BackupRestoreMasterKeyStatementBase.RestoreMasterKeyStatement((src.EncryptionPassword |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.File |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.IsForce), (src.Password |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.RestoreServiceMasterKeyStatement as src->
          TSqlStatement.BackupRestoreMasterKeyStatementBase((BackupRestoreMasterKeyStatementBase.RestoreServiceMasterKeyStatement((src.File |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.IsForce), (src.Password |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.BackupStatement as src ->
        match src with
        | :? ScriptDom.BackupDatabaseStatement as src->
          TSqlStatement.BackupStatement((BackupStatement.BackupDatabaseStatement((src.DatabaseName |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.Devices |> Seq.map (fun src -> DeviceInfo.DeviceInfo((src.DeviceType), (src.LogicalDevice |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.PhysicalDevice |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.Files |> Seq.map (fun src -> BackupRestoreFileInfo.BackupRestoreFileInfo((src.ItemKind), (src.Items |> Seq.map (fun x -> ValueExpression.FromCs(x, fragmentMapping)) |> List.ofSeq))) |> List.ofSeq), (src.MirrorToClauses |> Seq.map (fun src -> MirrorToClause.MirrorToClause((src.Devices |> Seq.map (fun src -> DeviceInfo.DeviceInfo((src.DeviceType), (src.LogicalDevice |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.PhysicalDevice |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq))) |> List.ofSeq), (src.Options |> Seq.map (fun x -> BackupOption.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.BackupTransactionLogStatement as src->
          TSqlStatement.BackupStatement((BackupStatement.BackupTransactionLogStatement((src.DatabaseName |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.Devices |> Seq.map (fun src -> DeviceInfo.DeviceInfo((src.DeviceType), (src.LogicalDevice |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.PhysicalDevice |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.MirrorToClauses |> Seq.map (fun src -> MirrorToClause.MirrorToClause((src.Devices |> Seq.map (fun src -> DeviceInfo.DeviceInfo((src.DeviceType), (src.LogicalDevice |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.PhysicalDevice |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq))) |> List.ofSeq), (src.Options |> Seq.map (fun x -> BackupOption.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
      | :? ScriptDom.BeginConversationTimerStatement as src ->
        TSqlStatement.BeginConversationTimerStatement((src.Handle |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.Timeout |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.BeginDialogStatement as src ->
        TSqlStatement.BeginDialogStatement((src.ContractName |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))),(src.Handle |> Option.ofObj |> Option.map (fun x -> VariableReference.FromCs(x, fragmentMapping))),(src.InitiatorServiceName |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))),(src.InstanceSpec |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))),(src.IsConversation),(src.Options |> Seq.map (fun x -> DialogOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.TargetServiceName |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.BeginEndBlockStatement as src ->
        match src with
        | :? ScriptDom.BeginEndAtomicBlockStatement as src->
          TSqlStatement.BeginEndBlockStatement((BeginEndBlockStatement.BeginEndAtomicBlockStatement((src.Options |> Seq.map (fun x -> AtomicBlockOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.StatementList |> Option.ofObj |> Option.map (fun x -> StatementList.FromCs(x, fragmentMapping))))  ))
        | _ -> (* :? ScriptDom.BeginEndBlockStatement as src *)
          TSqlStatement.BeginEndBlockStatement((BeginEndBlockStatement.Base((src.StatementList |> Option.ofObj |> Option.map (fun x -> StatementList.FromCs(x, fragmentMapping))))))
      | :? ScriptDom.BreakStatement as src ->
        TSqlStatement.BreakStatement
      | :? ScriptDom.BrokerPriorityStatement as src ->
        match src with
        | :? ScriptDom.AlterBrokerPriorityStatement as src->
          TSqlStatement.BrokerPriorityStatement((BrokerPriorityStatement.AlterBrokerPriorityStatement((src.BrokerPriorityParameters |> Seq.map (fun src -> BrokerPriorityParameter.BrokerPriorityParameter((src.IsDefaultOrAny), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CreateBrokerPriorityStatement as src->
          TSqlStatement.BrokerPriorityStatement((BrokerPriorityStatement.CreateBrokerPriorityStatement((src.BrokerPriorityParameters |> Seq.map (fun src -> BrokerPriorityParameter.BrokerPriorityParameter((src.IsDefaultOrAny), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.BulkInsertBase as src ->
        match src with
        | :? ScriptDom.BulkInsertStatement as src->
          TSqlStatement.BulkInsertBase((BulkInsertBase.BulkInsertStatement((src.From |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.Options |> Seq.map (fun x -> BulkInsertOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.To |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.InsertBulkStatement as src->
          TSqlStatement.BulkInsertBase((BulkInsertBase.InsertBulkStatement((src.ColumnDefinitions |> Seq.map (fun src -> InsertBulkColumnDefinition.InsertBulkColumnDefinition((src.Column |> Option.ofObj |> Option.map (fun x -> ColumnDefinitionBase.FromCs(x, fragmentMapping))), (src.NullNotNull))) |> List.ofSeq), (src.Options |> Seq.map (fun x -> BulkInsertOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.To |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.CertificateStatementBase as src ->
        match src with
        | :? ScriptDom.AlterCertificateStatement as src->
          TSqlStatement.CertificateStatementBase((CertificateStatementBase.AlterCertificateStatement((src.ActiveForBeginDialog), (src.AttestedBy |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.DecryptionPassword |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.EncryptionPassword |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.Kind), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.PrivateKeyPath |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.BackupCertificateStatement as src->
          TSqlStatement.CertificateStatementBase((CertificateStatementBase.BackupCertificateStatement((src.ActiveForBeginDialog), (src.DecryptionPassword |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.EncryptionPassword |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.File |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.PrivateKeyPath |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CreateCertificateStatement as src->
          TSqlStatement.CertificateStatementBase((CertificateStatementBase.CreateCertificateStatement((src.ActiveForBeginDialog), (src.CertificateOptions |> Seq.map (fun src -> CertificateOption.CertificateOption((src.Kind), (src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.CertificateSource |> Option.ofObj |> Option.map (fun x -> EncryptionSource.FromCs(x, fragmentMapping))), (src.DecryptionPassword |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.EncryptionPassword |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Owner |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.PrivateKeyPath |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.CheckpointStatement as src ->
        TSqlStatement.CheckpointStatement((src.Duration |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CloseMasterKeyStatement as src ->
        TSqlStatement.CloseMasterKeyStatement
      | :? ScriptDom.CloseSymmetricKeyStatement as src ->
        TSqlStatement.CloseSymmetricKeyStatement((src.All),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ColumnEncryptionKeyStatement as src ->
        match src with
        | :? ScriptDom.AlterColumnEncryptionKeyStatement as src->
          TSqlStatement.ColumnEncryptionKeyStatement((ColumnEncryptionKeyStatement.AlterColumnEncryptionKeyStatement((src.AlterType), (src.ColumnEncryptionKeyValues |> Seq.map (fun src -> ColumnEncryptionKeyValue.ColumnEncryptionKeyValue((src.Parameters |> Seq.map (fun x -> ColumnEncryptionKeyValueParameter.FromCs(x, fragmentMapping)) |> List.ofSeq))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CreateColumnEncryptionKeyStatement as src->
          TSqlStatement.ColumnEncryptionKeyStatement((ColumnEncryptionKeyStatement.CreateColumnEncryptionKeyStatement((src.ColumnEncryptionKeyValues |> Seq.map (fun src -> ColumnEncryptionKeyValue.ColumnEncryptionKeyValue((src.Parameters |> Seq.map (fun x -> ColumnEncryptionKeyValueParameter.FromCs(x, fragmentMapping)) |> List.ofSeq))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.ContinueStatement as src ->
        TSqlStatement.ContinueStatement
      | :? ScriptDom.CopyStatement as src ->
        TSqlStatement.CopyStatement((src.From |> Seq.map (fun src -> StringLiteral.StringLiteral((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.IsLargeObject), (src.IsNational), (src.LiteralType), (Option.ofObj (src.Value)))) |> List.ofSeq),(src.Into |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.OptimizerHints |> Seq.map (fun x -> OptimizerHint.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Options |> Seq.map (fun src -> CopyOption.CopyOption((src.Kind), (src.Value |> Option.ofObj |> Option.map (fun x -> CopyStatementOptionBase.FromCs(x, fragmentMapping))))) |> List.ofSeq))
      | :? ScriptDom.CreateAggregateStatement as src ->
        TSqlStatement.CreateAggregateStatement((src.AssemblyName |> Option.ofObj |> Option.map (fun x -> AssemblyName.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.Parameters |> Seq.map (fun src -> ProcedureParameter.ProcedureParameter((src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.IsVarying), (src.Modifier), (src.Nullable |> Option.ofObj |> Option.map (fun x -> NullableConstraintDefinition.FromCs(x, fragmentMapping))), (src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.VariableName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.ReturnType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CreateAsymmetricKeyStatement as src ->
        TSqlStatement.CreateAsymmetricKeyStatement((src.EncryptionAlgorithm),(src.KeySource |> Option.ofObj |> Option.map (fun x -> EncryptionSource.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Owner |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Password |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CreateColumnMasterKeyStatement as src ->
        TSqlStatement.CreateColumnMasterKeyStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Parameters |> Seq.map (fun x -> ColumnMasterKeyParameter.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.CreateColumnStoreIndexStatement as src ->
        TSqlStatement.CreateColumnStoreIndexStatement((Option.ofNullable (src.Clustered)),(src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.FilterPredicate |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))),(src.IndexOptions |> Seq.map (fun x -> IndexOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.OnFileGroupOrPartitionScheme |> Option.ofObj |> Option.map (fun x -> FileGroupOrPartitionScheme.FromCs(x, fragmentMapping))),(src.OnName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.OrderedColumns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq))
      | :? ScriptDom.CreateContractStatement as src ->
        TSqlStatement.CreateContractStatement((src.Messages |> Seq.map (fun src -> ContractMessage.ContractMessage((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.SentBy))) |> List.ofSeq),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Owner |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CreateCryptographicProviderStatement as src ->
        TSqlStatement.CreateCryptographicProviderStatement((src.File |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CreateDatabaseStatement as src ->
        TSqlStatement.CreateDatabaseStatement((src.AttachMode),(src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Containment |> Option.ofObj |> Option.map (fun x -> ContainmentDatabaseOption.FromCs(x, fragmentMapping))),(src.CopyOf |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))),(src.DatabaseName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.DatabaseSnapshot |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.FileGroups |> Seq.map (fun src -> FileGroupDefinition.FileGroupDefinition((src.ContainsFileStream), (src.ContainsMemoryOptimizedData), (src.FileDeclarations |> Seq.map (fun src -> FileDeclaration.FileDeclaration((src.IsPrimary), (src.Options |> Seq.map (fun x -> FileDeclarationOption.FromCs(x, fragmentMapping)) |> List.ofSeq))) |> List.ofSeq), (src.IsDefault), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.LogOn |> Seq.map (fun src -> FileDeclaration.FileDeclaration((src.IsPrimary), (src.Options |> Seq.map (fun x -> FileDeclarationOption.FromCs(x, fragmentMapping)) |> List.ofSeq))) |> List.ofSeq),(src.Options |> Seq.map (fun x -> DatabaseOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.CreateDefaultStatement as src ->
        TSqlStatement.CreateDefaultStatement((src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CreateEventNotificationStatement as src ->
        TSqlStatement.CreateEventNotificationStatement((src.BrokerInstanceSpecifier |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.BrokerService |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.EventTypeGroups |> Seq.map (fun x -> EventTypeGroupContainer.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Scope |> Option.ofObj |> Option.map (fun x -> EventNotificationObjectScope.FromCs(x, fragmentMapping))),(src.WithFanIn))
      | :? ScriptDom.CreateFederationStatement as src ->
        TSqlStatement.CreateFederationStatement((src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))),(src.DistributionName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CreateFullTextIndexStatement as src ->
        TSqlStatement.CreateFullTextIndexStatement((src.CatalogAndFileGroup |> Option.ofObj |> Option.map (fun x -> FullTextCatalogAndFileGroup.FromCs(x, fragmentMapping))),(src.FullTextIndexColumns |> Seq.map (fun src -> FullTextIndexColumn.FullTextIndexColumn((src.LanguageTerm |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.StatisticalSemantics), (src.TypeColumn |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.KeyIndexName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.OnName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.Options |> Seq.map (fun x -> FullTextIndexOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.CreateFullTextStopListStatement as src ->
        TSqlStatement.CreateFullTextStopListStatement((src.DatabaseName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.IsSystemStopList),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Owner |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.SourceStopListName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CreateLoginStatement as src ->
        TSqlStatement.CreateLoginStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Source |> Option.ofObj |> Option.map (fun x -> CreateLoginSource.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CreatePartitionFunctionStatement as src ->
        TSqlStatement.CreatePartitionFunctionStatement((src.BoundaryValues |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.ParameterType |> Option.ofObj |> Option.map (fun x -> PartitionParameterType.FromCs(x, fragmentMapping))),(src.Range))
      | :? ScriptDom.CreatePartitionSchemeStatement as src ->
        TSqlStatement.CreatePartitionSchemeStatement((src.FileGroups |> Seq.map (fun src -> IdentifierOrValueExpression.IdentifierOrValueExpression((src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (Option.ofObj (src.Value)), (src.ValueExpression |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.IsAll),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.PartitionFunction |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CreateRuleStatement as src ->
        TSqlStatement.CreateRuleStatement((src.Expression |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CreateSchemaStatement as src ->
        TSqlStatement.CreateSchemaStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Owner |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.StatementList |> Option.ofObj |> Option.map (fun x -> StatementList.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CreateSearchPropertyListStatement as src ->
        TSqlStatement.CreateSearchPropertyListStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Owner |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.SourceSearchPropertyList |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CreateSpatialIndexStatement as src ->
        TSqlStatement.CreateSpatialIndexStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Object |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.OnFileGroup |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))),(src.SpatialColumnName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.SpatialIndexOptions |> Seq.map (fun x -> SpatialIndexOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.SpatialIndexingScheme))
      | :? ScriptDom.CreateStatisticsStatement as src ->
        TSqlStatement.CreateStatisticsStatement((src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.FilterPredicate |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.OnName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.StatisticsOptions |> Seq.map (fun x -> StatisticsOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.CreateSynonymStatement as src ->
        TSqlStatement.CreateSynonymStatement((src.ForName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CreateTableStatement as src ->
        TSqlStatement.CreateTableStatement((src.AsEdge),(src.AsFileTable),(src.AsNode),(src.CtasColumns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Definition |> Option.ofObj |> Option.map (fun x -> TableDefinition.FromCs(x, fragmentMapping))),(src.FederationScheme |> Option.ofObj |> Option.map (fun x -> FederationScheme.FromCs(x, fragmentMapping))),(src.FileStreamOn |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))),(src.OnFileGroupOrPartitionScheme |> Option.ofObj |> Option.map (fun x -> FileGroupOrPartitionScheme.FromCs(x, fragmentMapping))),(src.Options |> Seq.map (fun x -> TableOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.SelectStatement |> Option.ofObj |> Option.map (fun x -> SelectStatement.FromCs(x, fragmentMapping))),(src.TextImageOn |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CreateTypeStatement as src ->
        match src with
        | :? ScriptDom.CreateTypeTableStatement as src->
          TSqlStatement.CreateTypeStatement((CreateTypeStatement.CreateTypeTableStatement((src.Definition |> Option.ofObj |> Option.map (fun x -> TableDefinition.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.Options |> Seq.map (fun x -> TableOption.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.CreateTypeUddtStatement as src->
          TSqlStatement.CreateTypeStatement((CreateTypeStatement.CreateTypeUddtStatement((src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.NullableConstraint |> Option.ofObj |> Option.map (fun x -> NullableConstraintDefinition.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CreateTypeUdtStatement as src->
          TSqlStatement.CreateTypeStatement((CreateTypeStatement.CreateTypeUdtStatement((src.AssemblyName |> Option.ofObj |> Option.map (fun x -> AssemblyName.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.CreateXmlSchemaCollectionStatement as src ->
        TSqlStatement.CreateXmlSchemaCollectionStatement((src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CredentialStatement as src ->
        match src with
        | :? ScriptDom.AlterCredentialStatement as src->
          TSqlStatement.CredentialStatement((CredentialStatement.AlterCredentialStatement((src.Identity |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.IsDatabaseScoped), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Secret |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CreateCredentialStatement as src->
          TSqlStatement.CredentialStatement((CredentialStatement.CreateCredentialStatement((src.CryptographicProviderName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Identity |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.IsDatabaseScoped), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Secret |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.CursorStatement as src ->
        match src with
        | :? ScriptDom.CloseCursorStatement as src->
          TSqlStatement.CursorStatement((CursorStatement.CloseCursorStatement((src.Cursor |> Option.ofObj |> Option.map (fun x -> CursorId.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DeallocateCursorStatement as src->
          TSqlStatement.CursorStatement((CursorStatement.DeallocateCursorStatement((src.Cursor |> Option.ofObj |> Option.map (fun x -> CursorId.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.FetchCursorStatement as src->
          TSqlStatement.CursorStatement((CursorStatement.FetchCursorStatement((src.Cursor |> Option.ofObj |> Option.map (fun x -> CursorId.FromCs(x, fragmentMapping))), (src.FetchType |> Option.ofObj |> Option.map (fun x -> FetchType.FromCs(x, fragmentMapping))), (src.IntoVariables |> Seq.map (fun src -> VariableReference.VariableReference((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (Option.ofObj (src.Name)))) |> List.ofSeq))  ))
        | :? ScriptDom.OpenCursorStatement as src->
          TSqlStatement.CursorStatement((CursorStatement.OpenCursorStatement((src.Cursor |> Option.ofObj |> Option.map (fun x -> CursorId.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.DatabaseEncryptionKeyStatement as src ->
        match src with
        | :? ScriptDom.AlterDatabaseEncryptionKeyStatement as src->
          TSqlStatement.DatabaseEncryptionKeyStatement((DatabaseEncryptionKeyStatement.AlterDatabaseEncryptionKeyStatement((src.Algorithm), (src.Encryptor |> Option.ofObj |> Option.map (fun x -> CryptoMechanism.FromCs(x, fragmentMapping))), (src.Regenerate))  ))
        | :? ScriptDom.CreateDatabaseEncryptionKeyStatement as src->
          TSqlStatement.DatabaseEncryptionKeyStatement((DatabaseEncryptionKeyStatement.CreateDatabaseEncryptionKeyStatement((src.Algorithm), (src.Encryptor |> Option.ofObj |> Option.map (fun x -> CryptoMechanism.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.DbccStatement as src ->
        TSqlStatement.DbccStatement((src.Command),(Option.ofObj (src.DllName)),(src.Literals |> Seq.map (fun src -> DbccNamedLiteral.DbccNamedLiteral((Option.ofObj (src.Name)), (src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.Options |> Seq.map (fun src -> DbccOption.DbccOption((src.OptionKind))) |> List.ofSeq),(src.OptionsUseJoin),(src.ParenthesisRequired))
      | :? ScriptDom.DeclareCursorStatement as src ->
        TSqlStatement.DeclareCursorStatement((src.CursorDefinition |> Option.ofObj |> Option.map (fun x -> CursorDefinition.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DeclareTableVariableStatement as src ->
        TSqlStatement.DeclareTableVariableStatement((src.Body |> Option.ofObj |> Option.map (fun x -> DeclareTableVariableBody.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DeclareVariableStatement as src ->
        TSqlStatement.DeclareVariableStatement((src.Declarations |> Seq.map (fun x -> DeclareVariableElement.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.DiskStatement as src ->
        TSqlStatement.DiskStatement((src.DiskStatementType),(src.Options |> Seq.map (fun src -> DiskStatementOption.DiskStatementOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq))
      | :? ScriptDom.DropChildObjectsStatement as src ->
        match src with
        | :? ScriptDom.DropStatisticsStatement as src->
          TSqlStatement.DropChildObjectsStatement((DropChildObjectsStatement.DropStatisticsStatement((src.Objects |> Seq.map (fun src -> ChildObjectName.ChildObjectName((src.BaseIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ChildIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Count), (src.DatabaseIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Identifiers |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.SchemaIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ServerIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))) |> List.ofSeq))  ))
      | :? ScriptDom.DropDatabaseEncryptionKeyStatement as src ->
        TSqlStatement.DropDatabaseEncryptionKeyStatement
      | :? ScriptDom.DropDatabaseStatement as src ->
        TSqlStatement.DropDatabaseStatement((src.Databases |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.IsIfExists))
      | :? ScriptDom.DropEventNotificationStatement as src ->
        TSqlStatement.DropEventNotificationStatement((src.Notifications |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Scope |> Option.ofObj |> Option.map (fun x -> EventNotificationObjectScope.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropFullTextIndexStatement as src ->
        TSqlStatement.DropFullTextIndexStatement((src.TableName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropIndexStatement as src ->
        TSqlStatement.DropIndexStatement((src.DropIndexClauses |> Seq.map (fun x -> DropIndexClauseBase.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.IsIfExists))
      | :? ScriptDom.DropMasterKeyStatement as src ->
        TSqlStatement.DropMasterKeyStatement
      | :? ScriptDom.DropObjectsStatement as src ->
        match src with
        | :? ScriptDom.DropAggregateStatement as src->
          TSqlStatement.DropObjectsStatement((DropObjectsStatement.DropAggregateStatement((src.IsIfExists), (src.Objects |> Seq.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.DropAssemblyStatement as src->
          TSqlStatement.DropObjectsStatement((DropObjectsStatement.DropAssemblyStatement((src.IsIfExists), (src.Objects |> Seq.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.WithNoDependents))  ))
        | :? ScriptDom.DropDefaultStatement as src->
          TSqlStatement.DropObjectsStatement((DropObjectsStatement.DropDefaultStatement((src.IsIfExists), (src.Objects |> Seq.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.DropExternalTableStatement as src->
          TSqlStatement.DropObjectsStatement((DropObjectsStatement.DropExternalTableStatement((src.IsIfExists), (src.Objects |> Seq.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.DropFunctionStatement as src->
          TSqlStatement.DropObjectsStatement((DropObjectsStatement.DropFunctionStatement((src.IsIfExists), (src.Objects |> Seq.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.DropProcedureStatement as src->
          TSqlStatement.DropObjectsStatement((DropObjectsStatement.DropProcedureStatement((src.IsIfExists), (src.Objects |> Seq.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.DropRuleStatement as src->
          TSqlStatement.DropObjectsStatement((DropObjectsStatement.DropRuleStatement((src.IsIfExists), (src.Objects |> Seq.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.DropSecurityPolicyStatement as src->
          TSqlStatement.DropObjectsStatement((DropObjectsStatement.DropSecurityPolicyStatement((src.IsIfExists), (src.Objects |> Seq.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.DropSequenceStatement as src->
          TSqlStatement.DropObjectsStatement((DropObjectsStatement.DropSequenceStatement((src.IsIfExists), (src.Objects |> Seq.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.DropSynonymStatement as src->
          TSqlStatement.DropObjectsStatement((DropObjectsStatement.DropSynonymStatement((src.IsIfExists), (src.Objects |> Seq.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.DropTableStatement as src->
          TSqlStatement.DropObjectsStatement((DropObjectsStatement.DropTableStatement((src.IsIfExists), (src.Objects |> Seq.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.DropTriggerStatement as src->
          TSqlStatement.DropObjectsStatement((DropObjectsStatement.DropTriggerStatement((src.IsIfExists), (src.Objects |> Seq.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.TriggerScope))  ))
        | :? ScriptDom.DropViewStatement as src->
          TSqlStatement.DropObjectsStatement((DropObjectsStatement.DropViewStatement((src.IsIfExists), (src.Objects |> Seq.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
      | :? ScriptDom.DropQueueStatement as src ->
        TSqlStatement.DropQueueStatement((src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropSchemaStatement as src ->
        TSqlStatement.DropSchemaStatement((src.DropBehavior),(src.IsIfExists),(src.Schema |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropTypeStatement as src ->
        TSqlStatement.DropTypeStatement((src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropUnownedObjectStatement as src ->
        match src with
        | :? ScriptDom.DropApplicationRoleStatement as src->
          TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropApplicationRoleStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropAsymmetricKeyStatement as src->
          TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropAsymmetricKeyStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.RemoveProviderKey))  ))
        | :? ScriptDom.DropAvailabilityGroupStatement as src->
          TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropAvailabilityGroupStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropBrokerPriorityStatement as src->
          TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropBrokerPriorityStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropCertificateStatement as src->
          TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropCertificateStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropColumnEncryptionKeyStatement as src->
          TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropColumnEncryptionKeyStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropColumnMasterKeyStatement as src->
          TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropColumnMasterKeyStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropContractStatement as src->
          TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropContractStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropCredentialStatement as src->
          TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropCredentialStatement((src.IsDatabaseScoped), (src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropCryptographicProviderStatement as src->
          TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropCryptographicProviderStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropDatabaseAuditSpecificationStatement as src->
          TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropDatabaseAuditSpecificationStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropEndpointStatement as src->
          TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropEndpointStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropEventSessionStatement as src->
          TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropEventSessionStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.SessionScope))  ))
        | :? ScriptDom.DropExternalDataSourceStatement as src->
          TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropExternalDataSourceStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropExternalFileFormatStatement as src->
          TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropExternalFileFormatStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropExternalResourcePoolStatement as src->
          TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropExternalResourcePoolStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropFederationStatement as src->
          TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropFederationStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropFullTextCatalogStatement as src->
          TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropFullTextCatalogStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropFullTextStopListStatement as src->
          TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropFullTextStopListStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropLoginStatement as src->
          TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropLoginStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropMessageTypeStatement as src->
          TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropMessageTypeStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropPartitionFunctionStatement as src->
          TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropPartitionFunctionStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropPartitionSchemeStatement as src->
          TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropPartitionSchemeStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropRemoteServiceBindingStatement as src->
          TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropRemoteServiceBindingStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropResourcePoolStatement as src->
          TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropResourcePoolStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropRoleStatement as src->
          TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropRoleStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropRouteStatement as src->
          TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropRouteStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropSearchPropertyListStatement as src->
          TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropSearchPropertyListStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropServerAuditSpecificationStatement as src->
          TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropServerAuditSpecificationStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropServerAuditStatement as src->
          TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropServerAuditStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropServerRoleStatement as src->
          TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropServerRoleStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropServiceStatement as src->
          TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropServiceStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropSymmetricKeyStatement as src->
          TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropSymmetricKeyStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.RemoveProviderKey))  ))
        | :? ScriptDom.DropUserStatement as src->
          TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropUserStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropWorkloadClassifierStatement as src->
          TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropWorkloadClassifierStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DropWorkloadGroupStatement as src->
          TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropWorkloadGroupStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.DropXmlSchemaCollectionStatement as src ->
        TSqlStatement.DropXmlSchemaCollectionStatement((src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.EnableDisableTriggerStatement as src ->
        TSqlStatement.EnableDisableTriggerStatement((src.All),(src.TriggerEnforcement),(src.TriggerNames |> Seq.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.TriggerObject |> Option.ofObj |> Option.map (fun x -> TriggerObject.FromCs(x, fragmentMapping))))
      | :? ScriptDom.EndConversationStatement as src ->
        TSqlStatement.EndConversationStatement((src.Conversation |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.ErrorCode |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))),(src.ErrorDescription |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))),(src.WithCleanup))
      | :? ScriptDom.EventSessionStatement as src ->
        match src with
        | :? ScriptDom.AlterEventSessionStatement as src->
          TSqlStatement.EventSessionStatement((EventSessionStatement.AlterEventSessionStatement((src.DropEventDeclarations |> Seq.map (fun src -> EventSessionObjectName.EventSessionObjectName((src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.DropTargetDeclarations |> Seq.map (fun src -> EventSessionObjectName.EventSessionObjectName((src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.EventDeclarations |> Seq.map (fun src -> EventDeclaration.EventDeclaration((src.EventDeclarationActionParameters |> Seq.map (fun src -> EventSessionObjectName.EventSessionObjectName((src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.EventDeclarationPredicateParameter |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))), (src.EventDeclarationSetParameters |> Seq.map (fun src -> EventDeclarationSetParameter.EventDeclarationSetParameter((src.EventField |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.EventValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.ObjectName |> Option.ofObj |> Option.map (fun x -> EventSessionObjectName.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.SessionOptions |> Seq.map (fun x -> SessionOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.SessionScope), (src.StatementType), (src.TargetDeclarations |> Seq.map (fun src -> TargetDeclaration.TargetDeclaration((src.ObjectName |> Option.ofObj |> Option.map (fun x -> EventSessionObjectName.FromCs(x, fragmentMapping))), (src.TargetDeclarationParameters |> Seq.map (fun src -> EventDeclarationSetParameter.EventDeclarationSetParameter((src.EventField |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.EventValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq))) |> List.ofSeq))  ))
        | :? ScriptDom.CreateEventSessionStatement as src->
          TSqlStatement.EventSessionStatement((EventSessionStatement.CreateEventSessionStatement((src.EventDeclarations |> Seq.map (fun src -> EventDeclaration.EventDeclaration((src.EventDeclarationActionParameters |> Seq.map (fun src -> EventSessionObjectName.EventSessionObjectName((src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.EventDeclarationPredicateParameter |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))), (src.EventDeclarationSetParameters |> Seq.map (fun src -> EventDeclarationSetParameter.EventDeclarationSetParameter((src.EventField |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.EventValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.ObjectName |> Option.ofObj |> Option.map (fun x -> EventSessionObjectName.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.SessionOptions |> Seq.map (fun x -> SessionOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.SessionScope), (src.TargetDeclarations |> Seq.map (fun src -> TargetDeclaration.TargetDeclaration((src.ObjectName |> Option.ofObj |> Option.map (fun x -> EventSessionObjectName.FromCs(x, fragmentMapping))), (src.TargetDeclarationParameters |> Seq.map (fun src -> EventDeclarationSetParameter.EventDeclarationSetParameter((src.EventField |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.EventValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq))) |> List.ofSeq))  ))
        | _ -> (* :? ScriptDom.EventSessionStatement as src *)
          TSqlStatement.EventSessionStatement((EventSessionStatement.Base((src.EventDeclarations |> Seq.map (fun src -> EventDeclaration.EventDeclaration((src.EventDeclarationActionParameters |> Seq.map (fun src -> EventSessionObjectName.EventSessionObjectName((src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.EventDeclarationPredicateParameter |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))), (src.EventDeclarationSetParameters |> Seq.map (fun src -> EventDeclarationSetParameter.EventDeclarationSetParameter((src.EventField |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.EventValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.ObjectName |> Option.ofObj |> Option.map (fun x -> EventSessionObjectName.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.SessionOptions |> Seq.map (fun x -> SessionOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.SessionScope), (src.TargetDeclarations |> Seq.map (fun src -> TargetDeclaration.TargetDeclaration((src.ObjectName |> Option.ofObj |> Option.map (fun x -> EventSessionObjectName.FromCs(x, fragmentMapping))), (src.TargetDeclarationParameters |> Seq.map (fun src -> EventDeclarationSetParameter.EventDeclarationSetParameter((src.EventField |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.EventValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq))) |> List.ofSeq))))
      | :? ScriptDom.ExecuteAsStatement as src ->
        TSqlStatement.ExecuteAsStatement((src.Cookie |> Option.ofObj |> Option.map (fun x -> VariableReference.FromCs(x, fragmentMapping))),(src.ExecuteContext |> Option.ofObj |> Option.map (fun x -> ExecuteContext.FromCs(x, fragmentMapping))),(src.WithNoRevert))
      | :? ScriptDom.ExecuteStatement as src ->
        TSqlStatement.ExecuteStatement((src.ExecuteSpecification |> Option.ofObj |> Option.map (fun x -> ExecuteSpecification.FromCs(x, fragmentMapping))),(src.Options |> Seq.map (fun x -> ExecuteOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.ExternalDataSourceStatement as src ->
        match src with
        | :? ScriptDom.AlterExternalDataSourceStatement as src->
          TSqlStatement.ExternalDataSourceStatement((ExternalDataSourceStatement.AlterExternalDataSourceStatement((src.DataSourceType), (src.ExternalDataSourceOptions |> Seq.map (fun x -> ExternalDataSourceOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Location |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.PreviousPushDownOption), (src.PushdownOption))  ))
        | :? ScriptDom.CreateExternalDataSourceStatement as src->
          TSqlStatement.ExternalDataSourceStatement((ExternalDataSourceStatement.CreateExternalDataSourceStatement((src.DataSourceType), (src.ExternalDataSourceOptions |> Seq.map (fun x -> ExternalDataSourceOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Location |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.PushdownOption))  ))
      | :? ScriptDom.ExternalFileFormatStatement as src ->
        match src with
        | :? ScriptDom.CreateExternalFileFormatStatement as src->
          TSqlStatement.ExternalFileFormatStatement((ExternalFileFormatStatement.CreateExternalFileFormatStatement((src.ExternalFileFormatOptions |> Seq.map (fun x -> ExternalFileFormatOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.FormatType), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.ExternalResourcePoolStatement as src ->
        match src with
        | :? ScriptDom.AlterExternalResourcePoolStatement as src->
          TSqlStatement.ExternalResourcePoolStatement((ExternalResourcePoolStatement.AlterExternalResourcePoolStatement((src.ExternalResourcePoolParameters |> Seq.map (fun src -> ExternalResourcePoolParameter.ExternalResourcePoolParameter((src.AffinitySpecification |> Option.ofObj |> Option.map (fun x -> ExternalResourcePoolAffinitySpecification.FromCs(x, fragmentMapping))), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CreateExternalResourcePoolStatement as src->
          TSqlStatement.ExternalResourcePoolStatement((ExternalResourcePoolStatement.CreateExternalResourcePoolStatement((src.ExternalResourcePoolParameters |> Seq.map (fun src -> ExternalResourcePoolParameter.ExternalResourcePoolParameter((src.AffinitySpecification |> Option.ofObj |> Option.map (fun x -> ExternalResourcePoolAffinitySpecification.FromCs(x, fragmentMapping))), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | _ -> (* :? ScriptDom.ExternalResourcePoolStatement as src *)
          TSqlStatement.ExternalResourcePoolStatement((ExternalResourcePoolStatement.Base((src.ExternalResourcePoolParameters |> Seq.map (fun src -> ExternalResourcePoolParameter.ExternalResourcePoolParameter((src.AffinitySpecification |> Option.ofObj |> Option.map (fun x -> ExternalResourcePoolAffinitySpecification.FromCs(x, fragmentMapping))), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))))
      | :? ScriptDom.ExternalTableStatement as src ->
        match src with
        | :? ScriptDom.CreateExternalTableStatement as src->
          TSqlStatement.ExternalTableStatement((ExternalTableStatement.CreateExternalTableStatement((src.ColumnDefinitions |> Seq.map (fun src -> ExternalTableColumnDefinition.ExternalTableColumnDefinition((src.ColumnDefinition |> Option.ofObj |> Option.map (fun x -> ColumnDefinitionBase.FromCs(x, fragmentMapping))), (src.NullableConstraint |> Option.ofObj |> Option.map (fun x -> NullableConstraintDefinition.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.DataSource |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ExternalTableOptions |> Seq.map (fun x -> ExternalTableOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.SelectStatement |> Option.ofObj |> Option.map (fun x -> SelectStatement.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.FullTextCatalogStatement as src ->
        match src with
        | :? ScriptDom.AlterFullTextCatalogStatement as src->
          TSqlStatement.FullTextCatalogStatement((FullTextCatalogStatement.AlterFullTextCatalogStatement((src.Action), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Options |> Seq.map (fun x -> FullTextCatalogOption.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.CreateFullTextCatalogStatement as src->
          TSqlStatement.FullTextCatalogStatement((FullTextCatalogStatement.CreateFullTextCatalogStatement((src.FileGroup |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.IsDefault), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Options |> Seq.map (fun x -> FullTextCatalogOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Owner |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Path |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.GoToStatement as src ->
        TSqlStatement.GoToStatement((src.LabelName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.IfStatement as src ->
        TSqlStatement.IfStatement((src.ElseStatement |> Option.ofObj |> Option.map (fun x -> TSqlStatement.FromCs(x, fragmentMapping))),(src.Predicate |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))),(src.ThenStatement |> Option.ofObj |> Option.map (fun x -> TSqlStatement.FromCs(x, fragmentMapping))))
      | :? ScriptDom.IndexDefinition as src ->
        TSqlStatement.IndexDefinition((src.Columns |> Seq.map (fun src -> ColumnWithSortOrder.ColumnWithSortOrder((src.Column |> Option.ofObj |> Option.map (fun x -> ColumnReferenceExpression.FromCs(x, fragmentMapping))), (src.SortOrder))) |> List.ofSeq),(src.FileStreamOn |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))),(src.FilterPredicate |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))),(src.IndexOptions |> Seq.map (fun x -> IndexOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.IndexType |> Option.ofObj |> Option.map (fun x -> IndexType.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.OnFileGroupOrPartitionScheme |> Option.ofObj |> Option.map (fun x -> FileGroupOrPartitionScheme.FromCs(x, fragmentMapping))),(src.Unique))
      | :? ScriptDom.IndexStatement as src ->
        match src with
        | :? ScriptDom.AlterIndexStatement as src->
          TSqlStatement.IndexStatement((IndexStatement.AlterIndexStatement((src.All), (src.AlterIndexType), (src.IndexOptions |> Seq.map (fun x -> IndexOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.OnName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.Partition |> Option.ofObj |> Option.map (fun x -> PartitionSpecifier.FromCs(x, fragmentMapping))), (src.PromotedPaths |> Seq.map (fun src -> SelectiveXmlIndexPromotedPath.SelectiveXmlIndexPromotedPath((src.IsSingleton), (src.MaxLength |> Option.ofObj |> Option.map (fun x -> IntegerLiteral.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Path |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.SQLDataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.XQueryDataType |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.XmlNamespaces |> Option.ofObj |> Option.map (fun x -> XmlNamespaces.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CreateIndexStatement as src->
          TSqlStatement.IndexStatement((IndexStatement.CreateIndexStatement((Option.ofNullable (src.Clustered)), (src.Columns |> Seq.map (fun src -> ColumnWithSortOrder.ColumnWithSortOrder((src.Column |> Option.ofObj |> Option.map (fun x -> ColumnReferenceExpression.FromCs(x, fragmentMapping))), (src.SortOrder))) |> List.ofSeq), (src.FileStreamOn |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.FilterPredicate |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))), (src.IncludeColumns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.IndexOptions |> Seq.map (fun x -> IndexOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.OnFileGroupOrPartitionScheme |> Option.ofObj |> Option.map (fun x -> FileGroupOrPartitionScheme.FromCs(x, fragmentMapping))), (src.OnName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.Translated80SyntaxTo90), (src.Unique))  ))
        | :? ScriptDom.CreateSelectiveXmlIndexStatement as src->
          TSqlStatement.IndexStatement((IndexStatement.CreateSelectiveXmlIndexStatement((src.IndexOptions |> Seq.map (fun x -> IndexOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.IsSecondary), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.OnName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.PathName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.PromotedPaths |> Seq.map (fun src -> SelectiveXmlIndexPromotedPath.SelectiveXmlIndexPromotedPath((src.IsSingleton), (src.MaxLength |> Option.ofObj |> Option.map (fun x -> IntegerLiteral.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Path |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.SQLDataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.XQueryDataType |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.UsingXmlIndexName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.XmlColumn |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.XmlNamespaces |> Option.ofObj |> Option.map (fun x -> XmlNamespaces.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CreateXmlIndexStatement as src->
          TSqlStatement.IndexStatement((IndexStatement.CreateXmlIndexStatement((src.IndexOptions |> Seq.map (fun x -> IndexOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.OnName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.Primary), (src.SecondaryXmlIndexName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.SecondaryXmlIndexType), (src.XmlColumn |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.KillQueryNotificationSubscriptionStatement as src ->
        TSqlStatement.KillQueryNotificationSubscriptionStatement((src.All),(src.SubscriptionId |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.KillStatement as src ->
        TSqlStatement.KillStatement((src.Parameter |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.WithStatusOnly))
      | :? ScriptDom.KillStatsJobStatement as src ->
        TSqlStatement.KillStatsJobStatement((src.JobId |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.LabelStatement as src ->
        TSqlStatement.LabelStatement((Option.ofObj (src.Value)))
      | :? ScriptDom.LineNoStatement as src ->
        TSqlStatement.LineNoStatement((src.LineNo |> Option.ofObj |> Option.map (fun x -> IntegerLiteral.FromCs(x, fragmentMapping))))
      | :? ScriptDom.MasterKeyStatement as src ->
        match src with
        | :? ScriptDom.AlterMasterKeyStatement as src->
          TSqlStatement.MasterKeyStatement((MasterKeyStatement.AlterMasterKeyStatement((src.Option), (src.Password |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CreateMasterKeyStatement as src->
          TSqlStatement.MasterKeyStatement((MasterKeyStatement.CreateMasterKeyStatement((src.Password |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.MessageTypeStatementBase as src ->
        match src with
        | :? ScriptDom.AlterMessageTypeStatement as src->
          TSqlStatement.MessageTypeStatementBase((MessageTypeStatementBase.AlterMessageTypeStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ValidationMethod), (src.XmlSchemaCollectionName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CreateMessageTypeStatement as src->
          TSqlStatement.MessageTypeStatementBase((MessageTypeStatementBase.CreateMessageTypeStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Owner |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ValidationMethod), (src.XmlSchemaCollectionName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.MoveConversationStatement as src ->
        TSqlStatement.MoveConversationStatement((src.Conversation |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.Group |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.OpenMasterKeyStatement as src ->
        TSqlStatement.OpenMasterKeyStatement((src.Password |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.OpenSymmetricKeyStatement as src ->
        TSqlStatement.OpenSymmetricKeyStatement((src.DecryptionMechanism |> Option.ofObj |> Option.map (fun x -> CryptoMechanism.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.PrintStatement as src ->
        TSqlStatement.PrintStatement((src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ProcedureStatementBodyBase as src ->
        match src with
        | :? ScriptDom.FunctionStatementBody as src->
          TSqlStatement.ProcedureStatementBodyBase((ProcedureStatementBodyBase.FunctionStatementBody((FunctionStatementBody.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.ProcedureStatementBody as src->
          TSqlStatement.ProcedureStatementBodyBase((ProcedureStatementBodyBase.ProcedureStatementBody((ProcedureStatementBody.FromCs(src, fragmentMapping)))  ))
      | :? ScriptDom.QueueStatement as src ->
        match src with
        | :? ScriptDom.AlterQueueStatement as src->
          TSqlStatement.QueueStatement((QueueStatement.AlterQueueStatement((src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.QueueOptions |> Seq.map (fun x -> QueueOption.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.CreateQueueStatement as src->
          TSqlStatement.QueueStatement((QueueStatement.CreateQueueStatement((src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.OnFileGroup |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.QueueOptions |> Seq.map (fun x -> QueueOption.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
      | :? ScriptDom.RaiseErrorLegacyStatement as src ->
        TSqlStatement.RaiseErrorLegacyStatement((src.FirstParameter |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.SecondParameter |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.RaiseErrorStatement as src ->
        TSqlStatement.RaiseErrorStatement((src.FirstParameter |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.OptionalParameters |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.RaiseErrorOptions),(src.SecondParameter |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.ThirdParameter |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ReadTextStatement as src ->
        TSqlStatement.ReadTextStatement((src.Column |> Option.ofObj |> Option.map (fun x -> ColumnReferenceExpression.FromCs(x, fragmentMapping))),(src.HoldLock),(src.Offset |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))),(src.Size |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))),(src.TextPointer |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ReconfigureStatement as src ->
        TSqlStatement.ReconfigureStatement((src.WithOverride))
      | :? ScriptDom.RemoteServiceBindingStatementBase as src ->
        match src with
        | :? ScriptDom.AlterRemoteServiceBindingStatement as src->
          TSqlStatement.RemoteServiceBindingStatementBase((RemoteServiceBindingStatementBase.AlterRemoteServiceBindingStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Options |> Seq.map (fun x -> RemoteServiceBindingOption.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.CreateRemoteServiceBindingStatement as src->
          TSqlStatement.RemoteServiceBindingStatementBase((RemoteServiceBindingStatementBase.CreateRemoteServiceBindingStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Options |> Seq.map (fun x -> RemoteServiceBindingOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Owner |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Service |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.RenameEntityStatement as src ->
        TSqlStatement.RenameEntityStatement((src.NewName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.OldName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.RenameEntityType),(Option.ofNullable (src.SeparatorType)))
      | :? ScriptDom.ResourcePoolStatement as src ->
        match src with
        | :? ScriptDom.AlterResourcePoolStatement as src->
          TSqlStatement.ResourcePoolStatement((ResourcePoolStatement.AlterResourcePoolStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ResourcePoolParameters |> Seq.map (fun src -> ResourcePoolParameter.ResourcePoolParameter((src.AffinitySpecification |> Option.ofObj |> Option.map (fun x -> ResourcePoolAffinitySpecification.FromCs(x, fragmentMapping))), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq))  ))
        | :? ScriptDom.CreateResourcePoolStatement as src->
          TSqlStatement.ResourcePoolStatement((ResourcePoolStatement.CreateResourcePoolStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ResourcePoolParameters |> Seq.map (fun src -> ResourcePoolParameter.ResourcePoolParameter((src.AffinitySpecification |> Option.ofObj |> Option.map (fun x -> ResourcePoolAffinitySpecification.FromCs(x, fragmentMapping))), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq))  ))
        | _ -> (* :? ScriptDom.ResourcePoolStatement as src *)
          TSqlStatement.ResourcePoolStatement((ResourcePoolStatement.Base((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ResourcePoolParameters |> Seq.map (fun src -> ResourcePoolParameter.ResourcePoolParameter((src.AffinitySpecification |> Option.ofObj |> Option.map (fun x -> ResourcePoolAffinitySpecification.FromCs(x, fragmentMapping))), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq))))
      | :? ScriptDom.RestoreStatement as src ->
        TSqlStatement.RestoreStatement((src.DatabaseName |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))),(src.Devices |> Seq.map (fun src -> DeviceInfo.DeviceInfo((src.DeviceType), (src.LogicalDevice |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.PhysicalDevice |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.Files |> Seq.map (fun src -> BackupRestoreFileInfo.BackupRestoreFileInfo((src.ItemKind), (src.Items |> Seq.map (fun x -> ValueExpression.FromCs(x, fragmentMapping)) |> List.ofSeq))) |> List.ofSeq),(src.Kind),(src.Options |> Seq.map (fun x -> RestoreOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.ReturnStatement as src ->
        TSqlStatement.ReturnStatement((src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.RevertStatement as src ->
        TSqlStatement.RevertStatement((src.Cookie |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.RoleStatement as src ->
        match src with
        | :? ScriptDom.AlterRoleStatement as src->
          TSqlStatement.RoleStatement((RoleStatement.AlterRoleStatement((AlterRoleStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.CreateRoleStatement as src->
          TSqlStatement.RoleStatement((RoleStatement.CreateRoleStatement((CreateRoleStatement.FromCs(src, fragmentMapping)))  ))
      | :? ScriptDom.RouteStatement as src ->
        match src with
        | :? ScriptDom.AlterRouteStatement as src->
          TSqlStatement.RouteStatement((RouteStatement.AlterRouteStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.RouteOptions |> Seq.map (fun src -> RouteOption.RouteOption((src.Literal |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.OptionKind))) |> List.ofSeq))  ))
        | :? ScriptDom.CreateRouteStatement as src->
          TSqlStatement.RouteStatement((RouteStatement.CreateRouteStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Owner |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.RouteOptions |> Seq.map (fun src -> RouteOption.RouteOption((src.Literal |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.OptionKind))) |> List.ofSeq))  ))
      | :? ScriptDom.SecurityPolicyStatement as src ->
        match src with
        | :? ScriptDom.AlterSecurityPolicyStatement as src->
          TSqlStatement.SecurityPolicyStatement((SecurityPolicyStatement.AlterSecurityPolicyStatement((src.ActionType), (src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.NotForReplication), (src.SecurityPolicyOptions |> Seq.map (fun src -> SecurityPolicyOption.SecurityPolicyOption((src.OptionKind), (src.OptionState))) |> List.ofSeq), (src.SecurityPredicateActions |> Seq.map (fun src -> SecurityPredicateAction.SecurityPredicateAction((src.ActionType), (src.FunctionCall |> Option.ofObj |> Option.map (fun x -> FunctionCall.FromCs(x, fragmentMapping))), (src.SecurityPredicateOperation), (src.SecurityPredicateType), (src.TargetObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))) |> List.ofSeq))  ))
        | :? ScriptDom.CreateSecurityPolicyStatement as src->
          TSqlStatement.SecurityPolicyStatement((SecurityPolicyStatement.CreateSecurityPolicyStatement((src.ActionType), (src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.NotForReplication), (src.SecurityPolicyOptions |> Seq.map (fun src -> SecurityPolicyOption.SecurityPolicyOption((src.OptionKind), (src.OptionState))) |> List.ofSeq), (src.SecurityPredicateActions |> Seq.map (fun src -> SecurityPredicateAction.SecurityPredicateAction((src.ActionType), (src.FunctionCall |> Option.ofObj |> Option.map (fun x -> FunctionCall.FromCs(x, fragmentMapping))), (src.SecurityPredicateOperation), (src.SecurityPredicateType), (src.TargetObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))) |> List.ofSeq))  ))
      | :? ScriptDom.SecurityStatement as src ->
        match src with
        | :? ScriptDom.DenyStatement as src->
          TSqlStatement.SecurityStatement((SecurityStatement.DenyStatement((src.AsClause |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.CascadeOption), (src.Permissions |> Seq.map (fun src -> Permission.Permission((src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Identifiers |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq))) |> List.ofSeq), (src.Principals |> Seq.map (fun src -> SecurityPrincipal.SecurityPrincipal((src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.PrincipalType))) |> List.ofSeq), (src.SecurityTargetObject |> Option.ofObj |> Option.map (fun x -> SecurityTargetObject.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.GrantStatement as src->
          TSqlStatement.SecurityStatement((SecurityStatement.GrantStatement((src.AsClause |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Permissions |> Seq.map (fun src -> Permission.Permission((src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Identifiers |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq))) |> List.ofSeq), (src.Principals |> Seq.map (fun src -> SecurityPrincipal.SecurityPrincipal((src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.PrincipalType))) |> List.ofSeq), (src.SecurityTargetObject |> Option.ofObj |> Option.map (fun x -> SecurityTargetObject.FromCs(x, fragmentMapping))), (src.WithGrantOption))  ))
        | :? ScriptDom.RevokeStatement as src->
          TSqlStatement.SecurityStatement((SecurityStatement.RevokeStatement((src.AsClause |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.CascadeOption), (src.GrantOptionFor), (src.Permissions |> Seq.map (fun src -> Permission.Permission((src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Identifiers |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq))) |> List.ofSeq), (src.Principals |> Seq.map (fun src -> SecurityPrincipal.SecurityPrincipal((src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.PrincipalType))) |> List.ofSeq), (src.SecurityTargetObject |> Option.ofObj |> Option.map (fun x -> SecurityTargetObject.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.SecurityStatementBody80 as src ->
        match src with
        | :? ScriptDom.DenyStatement80 as src->
          TSqlStatement.SecurityStatementBody80((SecurityStatementBody80.DenyStatement80((src.CascadeOption), (src.SecurityElement80 |> Option.ofObj |> Option.map (fun x -> SecurityElement80.FromCs(x, fragmentMapping))), (src.SecurityUserClause80 |> Option.ofObj |> Option.map (fun x -> SecurityUserClause80.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.GrantStatement80 as src->
          TSqlStatement.SecurityStatementBody80((SecurityStatementBody80.GrantStatement80((src.AsClause |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.SecurityElement80 |> Option.ofObj |> Option.map (fun x -> SecurityElement80.FromCs(x, fragmentMapping))), (src.SecurityUserClause80 |> Option.ofObj |> Option.map (fun x -> SecurityUserClause80.FromCs(x, fragmentMapping))), (src.WithGrantOption))  ))
        | :? ScriptDom.RevokeStatement80 as src->
          TSqlStatement.SecurityStatementBody80((SecurityStatementBody80.RevokeStatement80((src.AsClause |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.CascadeOption), (src.GrantOptionFor), (src.SecurityElement80 |> Option.ofObj |> Option.map (fun x -> SecurityElement80.FromCs(x, fragmentMapping))), (src.SecurityUserClause80 |> Option.ofObj |> Option.map (fun x -> SecurityUserClause80.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.SendStatement as src ->
        TSqlStatement.SendStatement((src.ConversationHandles |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.MessageBody |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.MessageTypeName |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.SensitivityClassificationStatement as src ->
        match src with
        | :? ScriptDom.AddSensitivityClassificationStatement as src->
          TSqlStatement.SensitivityClassificationStatement((SensitivityClassificationStatement.AddSensitivityClassificationStatement((src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.Options |> Seq.map (fun src -> SensitivityClassificationOption.SensitivityClassificationOption((src.Type), (src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq))  ))
        | :? ScriptDom.DropSensitivityClassificationStatement as src->
          TSqlStatement.SensitivityClassificationStatement((SensitivityClassificationStatement.DropSensitivityClassificationStatement((src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq))  ))
      | :? ScriptDom.SequenceStatement as src ->
        match src with
        | :? ScriptDom.AlterSequenceStatement as src->
          TSqlStatement.SequenceStatement((SequenceStatement.AlterSequenceStatement((src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.SequenceOptions |> Seq.map (fun x -> SequenceOption.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.CreateSequenceStatement as src->
          TSqlStatement.SequenceStatement((SequenceStatement.CreateSequenceStatement((src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.SequenceOptions |> Seq.map (fun x -> SequenceOption.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
      | :? ScriptDom.ServerAuditStatement as src ->
        match src with
        | :? ScriptDom.AlterServerAuditStatement as src->
          TSqlStatement.ServerAuditStatement((ServerAuditStatement.AlterServerAuditStatement((src.AuditName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.AuditTarget |> Option.ofObj |> Option.map (fun x -> AuditTarget.FromCs(x, fragmentMapping))), (src.NewName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Options |> Seq.map (fun x -> AuditOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.PredicateExpression |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))), (src.RemoveWhere))  ))
        | :? ScriptDom.CreateServerAuditStatement as src->
          TSqlStatement.ServerAuditStatement((ServerAuditStatement.CreateServerAuditStatement((src.AuditName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.AuditTarget |> Option.ofObj |> Option.map (fun x -> AuditTarget.FromCs(x, fragmentMapping))), (src.Options |> Seq.map (fun x -> AuditOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.PredicateExpression |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.SetCommandStatement as src ->
        TSqlStatement.SetCommandStatement((src.Commands |> Seq.map (fun x -> SetCommand.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.SetErrorLevelStatement as src ->
        TSqlStatement.SetErrorLevelStatement((src.Level |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.SetOnOffStatement as src ->
        match src with
        | :? ScriptDom.PredicateSetStatement as src->
          TSqlStatement.SetOnOffStatement((SetOnOffStatement.PredicateSetStatement((src.IsOn), (src.Options))  ))
        | :? ScriptDom.SetIdentityInsertStatement as src->
          TSqlStatement.SetOnOffStatement((SetOnOffStatement.SetIdentityInsertStatement((src.IsOn), (src.Table |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.SetOffsetsStatement as src->
          TSqlStatement.SetOnOffStatement((SetOnOffStatement.SetOffsetsStatement((src.IsOn), (src.Options))  ))
        | :? ScriptDom.SetStatisticsStatement as src->
          TSqlStatement.SetOnOffStatement((SetOnOffStatement.SetStatisticsStatement((src.IsOn), (src.Options))  ))
      | :? ScriptDom.SetRowCountStatement as src ->
        TSqlStatement.SetRowCountStatement((src.NumberRows |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.SetTextSizeStatement as src ->
        TSqlStatement.SetTextSizeStatement((src.TextSize |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.SetTransactionIsolationLevelStatement as src ->
        TSqlStatement.SetTransactionIsolationLevelStatement((src.Level))
      | :? ScriptDom.SetUserStatement as src ->
        TSqlStatement.SetUserStatement((src.UserName |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))),(src.WithNoReset))
      | :? ScriptDom.SetVariableStatement as src ->
        TSqlStatement.SetVariableStatement((src.AssignmentKind),(src.CursorDefinition |> Option.ofObj |> Option.map (fun x -> CursorDefinition.FromCs(x, fragmentMapping))),(src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.FunctionCallExists),(src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Parameters |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.SeparatorType),(src.Variable |> Option.ofObj |> Option.map (fun x -> VariableReference.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ShutdownStatement as src ->
        TSqlStatement.ShutdownStatement((src.WithNoWait))
      | :? ScriptDom.SignatureStatementBase as src ->
        match src with
        | :? ScriptDom.AddSignatureStatement as src->
          TSqlStatement.SignatureStatementBase((SignatureStatementBase.AddSignatureStatement((src.Cryptos |> Seq.map (fun src -> CryptoMechanism.CryptoMechanism((src.CryptoMechanismType), (src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.PasswordOrSignature |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.Element |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.ElementKind), (src.IsCounter))  ))
        | :? ScriptDom.DropSignatureStatement as src->
          TSqlStatement.SignatureStatementBase((SignatureStatementBase.DropSignatureStatement((src.Cryptos |> Seq.map (fun src -> CryptoMechanism.CryptoMechanism((src.CryptoMechanismType), (src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.PasswordOrSignature |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.Element |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.ElementKind), (src.IsCounter))  ))
      | :? ScriptDom.StatementWithCtesAndXmlNamespaces as src ->
        match src with
        | :? ScriptDom.DataModificationStatement as src->
          TSqlStatement.StatementWithCtesAndXmlNamespaces((StatementWithCtesAndXmlNamespaces.DataModificationStatement((DataModificationStatement.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.SelectStatement as src->
          TSqlStatement.StatementWithCtesAndXmlNamespaces((StatementWithCtesAndXmlNamespaces.SelectStatement((SelectStatement.FromCs(src, fragmentMapping)))  ))
      | :? ScriptDom.SymmetricKeyStatement as src ->
        match src with
        | :? ScriptDom.AlterSymmetricKeyStatement as src->
          TSqlStatement.SymmetricKeyStatement((SymmetricKeyStatement.AlterSymmetricKeyStatement((src.EncryptingMechanisms |> Seq.map (fun src -> CryptoMechanism.CryptoMechanism((src.CryptoMechanismType), (src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.PasswordOrSignature |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.IsAdd), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CreateSymmetricKeyStatement as src->
          TSqlStatement.SymmetricKeyStatement((SymmetricKeyStatement.CreateSymmetricKeyStatement((src.EncryptingMechanisms |> Seq.map (fun src -> CryptoMechanism.CryptoMechanism((src.CryptoMechanismType), (src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.PasswordOrSignature |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.KeyOptions |> Seq.map (fun x -> KeyOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Owner |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Provider |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.TSqlStatementSnippet as src ->
        TSqlStatement.TSqlStatementSnippet((Option.ofObj (src.Script)))
      | :? ScriptDom.TextModificationStatement as src ->
        match src with
        | :? ScriptDom.UpdateTextStatement as src->
          TSqlStatement.TextModificationStatement((TextModificationStatement.UpdateTextStatement((src.Bulk), (src.Column |> Option.ofObj |> Option.map (fun x -> ColumnReferenceExpression.FromCs(x, fragmentMapping))), (src.DeleteLength |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.InsertOffset |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.SourceColumn |> Option.ofObj |> Option.map (fun x -> ColumnReferenceExpression.FromCs(x, fragmentMapping))), (src.SourceParameter |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))), (src.TextId |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))), (src.Timestamp |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.WithLog))  ))
        | :? ScriptDom.WriteTextStatement as src->
          TSqlStatement.TextModificationStatement((TextModificationStatement.WriteTextStatement((src.Bulk), (src.Column |> Option.ofObj |> Option.map (fun x -> ColumnReferenceExpression.FromCs(x, fragmentMapping))), (src.SourceParameter |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))), (src.TextId |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))), (src.Timestamp |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.WithLog))  ))
      | :? ScriptDom.ThrowStatement as src ->
        TSqlStatement.ThrowStatement((src.ErrorNumber |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))),(src.Message |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))),(src.State |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.TransactionStatement as src ->
        match src with
        | :? ScriptDom.BeginTransactionStatement as src->
          TSqlStatement.TransactionStatement((TransactionStatement.BeginTransactionStatement((src.Distributed), (src.MarkDefined), (src.MarkDescription |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CommitTransactionStatement as src->
          TSqlStatement.TransactionStatement((TransactionStatement.CommitTransactionStatement((src.DelayedDurabilityOption), (src.Name |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.RollbackTransactionStatement as src->
          TSqlStatement.TransactionStatement((TransactionStatement.RollbackTransactionStatement((src.Name |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.SaveTransactionStatement as src->
          TSqlStatement.TransactionStatement((TransactionStatement.SaveTransactionStatement((src.Name |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.TriggerStatementBody as src ->
        match src with
        | :? ScriptDom.AlterTriggerStatement as src->
          TSqlStatement.TriggerStatementBody((TriggerStatementBody.AlterTriggerStatement((src.IsNotForReplication), (src.MethodSpecifier |> Option.ofObj |> Option.map (fun x -> MethodSpecifier.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.Options |> Seq.map (fun x -> TriggerOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.StatementList |> Option.ofObj |> Option.map (fun x -> StatementList.FromCs(x, fragmentMapping))), (src.TriggerActions |> Seq.map (fun src -> TriggerAction.TriggerAction((src.EventTypeGroup |> Option.ofObj |> Option.map (fun x -> EventTypeGroupContainer.FromCs(x, fragmentMapping))), (src.TriggerActionType))) |> List.ofSeq), (src.TriggerObject |> Option.ofObj |> Option.map (fun x -> TriggerObject.FromCs(x, fragmentMapping))), (src.TriggerType), (src.WithAppend))  ))
        | :? ScriptDom.CreateOrAlterTriggerStatement as src->
          TSqlStatement.TriggerStatementBody((TriggerStatementBody.CreateOrAlterTriggerStatement((src.IsNotForReplication), (src.MethodSpecifier |> Option.ofObj |> Option.map (fun x -> MethodSpecifier.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.Options |> Seq.map (fun x -> TriggerOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.StatementList |> Option.ofObj |> Option.map (fun x -> StatementList.FromCs(x, fragmentMapping))), (src.TriggerActions |> Seq.map (fun src -> TriggerAction.TriggerAction((src.EventTypeGroup |> Option.ofObj |> Option.map (fun x -> EventTypeGroupContainer.FromCs(x, fragmentMapping))), (src.TriggerActionType))) |> List.ofSeq), (src.TriggerObject |> Option.ofObj |> Option.map (fun x -> TriggerObject.FromCs(x, fragmentMapping))), (src.TriggerType), (src.WithAppend))  ))
        | :? ScriptDom.CreateTriggerStatement as src->
          TSqlStatement.TriggerStatementBody((TriggerStatementBody.CreateTriggerStatement((src.IsNotForReplication), (src.MethodSpecifier |> Option.ofObj |> Option.map (fun x -> MethodSpecifier.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.Options |> Seq.map (fun x -> TriggerOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.StatementList |> Option.ofObj |> Option.map (fun x -> StatementList.FromCs(x, fragmentMapping))), (src.TriggerActions |> Seq.map (fun src -> TriggerAction.TriggerAction((src.EventTypeGroup |> Option.ofObj |> Option.map (fun x -> EventTypeGroupContainer.FromCs(x, fragmentMapping))), (src.TriggerActionType))) |> List.ofSeq), (src.TriggerObject |> Option.ofObj |> Option.map (fun x -> TriggerObject.FromCs(x, fragmentMapping))), (src.TriggerType), (src.WithAppend))  ))
      | :? ScriptDom.TruncateTableStatement as src ->
        TSqlStatement.TruncateTableStatement((src.PartitionRanges |> Seq.map (fun src -> CompressionPartitionRange.CompressionPartitionRange((src.From |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.To |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.TableName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.TryCatchStatement as src ->
        TSqlStatement.TryCatchStatement((src.CatchStatements |> Option.ofObj |> Option.map (fun x -> StatementList.FromCs(x, fragmentMapping))),(src.TryStatements |> Option.ofObj |> Option.map (fun x -> StatementList.FromCs(x, fragmentMapping))))
      | :? ScriptDom.UpdateStatisticsStatement as src ->
        TSqlStatement.UpdateStatisticsStatement((src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.StatisticsOptions |> Seq.map (fun x -> StatisticsOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.SubElements |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.UseFederationStatement as src ->
        TSqlStatement.UseFederationStatement((src.DistributionName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.FederationName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Filtering),(src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.UseStatement as src ->
        TSqlStatement.UseStatement((src.DatabaseName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.UserStatement as src ->
        match src with
        | :? ScriptDom.AlterUserStatement as src->
          TSqlStatement.UserStatement((UserStatement.AlterUserStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.UserOptions |> Seq.map (fun x -> PrincipalOption.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.CreateUserStatement as src->
          TSqlStatement.UserStatement((UserStatement.CreateUserStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.UserLoginOption |> Option.ofObj |> Option.map (fun x -> UserLoginOption.FromCs(x, fragmentMapping))), (src.UserOptions |> Seq.map (fun x -> PrincipalOption.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
      | :? ScriptDom.ViewStatementBody as src ->
        match src with
        | :? ScriptDom.AlterViewStatement as src->
          TSqlStatement.ViewStatementBody((ViewStatementBody.AlterViewStatement((src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.IsDisable), (src.IsMaterialized), (src.IsRebuild), (src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.SelectStatement |> Option.ofObj |> Option.map (fun x -> SelectStatement.FromCs(x, fragmentMapping))), (src.ViewOptions |> Seq.map (fun x -> ViewOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.WithCheckOption))  ))
        | :? ScriptDom.CreateOrAlterViewStatement as src->
          TSqlStatement.ViewStatementBody((ViewStatementBody.CreateOrAlterViewStatement((src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.IsMaterialized), (src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.SelectStatement |> Option.ofObj |> Option.map (fun x -> SelectStatement.FromCs(x, fragmentMapping))), (src.ViewOptions |> Seq.map (fun x -> ViewOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.WithCheckOption))  ))
        | :? ScriptDom.CreateViewStatement as src->
          TSqlStatement.ViewStatementBody((ViewStatementBody.CreateViewStatement((src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.IsMaterialized), (src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.SelectStatement |> Option.ofObj |> Option.map (fun x -> SelectStatement.FromCs(x, fragmentMapping))), (src.ViewOptions |> Seq.map (fun x -> ViewOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.WithCheckOption))  ))
      | :? ScriptDom.WaitForStatement as src ->
        TSqlStatement.WaitForStatement((src.Parameter |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))),(src.Statement |> Option.ofObj |> Option.map (fun x -> WaitForSupportedStatement.FromCs(x, fragmentMapping))),(src.Timeout |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.WaitForOption))
      | :? ScriptDom.WaitForSupportedStatement as src ->
        match src with
        | :? ScriptDom.GetConversationGroupStatement as src->
          TSqlStatement.WaitForSupportedStatement((WaitForSupportedStatement.GetConversationGroupStatement((src.GroupId |> Option.ofObj |> Option.map (fun x -> VariableReference.FromCs(x, fragmentMapping))), (src.Queue |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.ReceiveStatement as src->
          TSqlStatement.WaitForSupportedStatement((WaitForSupportedStatement.ReceiveStatement((src.Into |> Option.ofObj |> Option.map (fun x -> VariableTableReference.FromCs(x, fragmentMapping))), (src.IsConversationGroupIdWhere), (src.Queue |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.SelectElements |> Seq.map (fun x -> SelectElement.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Top |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.Where |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.WhileStatement as src ->
        TSqlStatement.WhileStatement((src.Predicate |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))),(src.Statement |> Option.ofObj |> Option.map (fun x -> TSqlStatement.FromCs(x, fragmentMapping))))
      | :? ScriptDom.WorkloadClassifierStatement as src ->
        match src with
        | :? ScriptDom.CreateWorkloadClassifierStatement as src->
          TSqlStatement.WorkloadClassifierStatement((WorkloadClassifierStatement.CreateWorkloadClassifierStatement((src.ClassifierName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Options |> Seq.map (fun x -> WorkloadClassifierOption.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
      | :? ScriptDom.WorkloadGroupStatement as src ->
        match src with
        | :? ScriptDom.AlterWorkloadGroupStatement as src->
          TSqlStatement.WorkloadGroupStatement((WorkloadGroupStatement.AlterWorkloadGroupStatement((src.ExternalPoolName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.PoolName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.WorkloadGroupParameters |> Seq.map (fun x -> WorkloadGroupParameter.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.CreateWorkloadGroupStatement as src->
          TSqlStatement.WorkloadGroupStatement((WorkloadGroupStatement.CreateWorkloadGroupStatement((src.ExternalPoolName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.PoolName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.WorkloadGroupParameters |> Seq.map (fun x -> WorkloadGroupParameter.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] TableDistributionPolicy = (* IsAbstract = true *)
  | TableHashDistributionPolicy of DistributionColumn:Identifier option
  | TableReplicateDistributionPolicy 
  | TableRoundRobinDistributionPolicy 
  member this.ToCs() : ScriptDom.TableDistributionPolicy =
    match this with
    | TableHashDistributionPolicy(DistributionColumn=aDistributionColumn) ->
      let ret = ScriptDom.TableHashDistributionPolicy()
      ret.DistributionColumn <- aDistributionColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableDistributionPolicy (* 335 *)
    | TableReplicateDistributionPolicy -> ScriptDom.TableReplicateDistributionPolicy() :> ScriptDom.TableDistributionPolicy (* 327 *)
    | TableRoundRobinDistributionPolicy -> ScriptDom.TableRoundRobinDistributionPolicy() :> ScriptDom.TableDistributionPolicy (* 327 *)
  static member FromCs(src:ScriptDom.TableDistributionPolicy, fragmentMapping:FragmentMapping) : TableDistributionPolicy =
    let ret =
      match src with
      | :? ScriptDom.TableHashDistributionPolicy as src ->
        TableDistributionPolicy.TableHashDistributionPolicy((src.DistributionColumn |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.TableReplicateDistributionPolicy as src ->
        TableDistributionPolicy.TableReplicateDistributionPolicy
      | :? ScriptDom.TableRoundRobinDistributionPolicy as src ->
        TableDistributionPolicy.TableRoundRobinDistributionPolicy
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] TableHint = (* IsAbstract = false *)
  | Base of HintKind:ScriptDom.TableHintKind
  | ForceSeekTableHint of ColumnValues:(ColumnReferenceExpression) list * HintKind:ScriptDom.TableHintKind * IndexValue:IdentifierOrValueExpression option
  | IndexTableHint of HintKind:ScriptDom.TableHintKind * IndexValues:(IdentifierOrValueExpression) list
  | LiteralTableHint of HintKind:ScriptDom.TableHintKind * Value:Literal option
  member this.ToCs() : ScriptDom.TableHint =
    match this with
    | ForceSeekTableHint(ColumnValues=aColumnValues; HintKind=aHintKind; IndexValue=aIndexValue) ->
      let ret = ScriptDom.ForceSeekTableHint()
      for e in aColumnValues do ret.ColumnValues.Add (e.ToCs())
      ret.HintKind <- aHintKind
      ret.IndexValue <- aIndexValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableHint (* 335 *)
    | IndexTableHint(HintKind=aHintKind; IndexValues=aIndexValues) ->
      let ret = ScriptDom.IndexTableHint()
      ret.HintKind <- aHintKind
      for e in aIndexValues do ret.IndexValues.Add (e.ToCs())
      ret :> ScriptDom.TableHint (* 335 *)
    | LiteralTableHint(HintKind=aHintKind; Value=aValue) ->
      let ret = ScriptDom.LiteralTableHint()
      ret.HintKind <- aHintKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableHint (* 335 *)
    | Base(HintKind=aHintKind) ->

      let ret = ScriptDom.TableHint()
      ret.HintKind <- aHintKind
      ret
  static member FromCs(src:ScriptDom.TableHint, fragmentMapping:FragmentMapping) : TableHint =
    let ret =
      match src with
      | :? ScriptDom.ForceSeekTableHint as src ->
        TableHint.ForceSeekTableHint((src.ColumnValues |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.HintKind),(src.IndexValue |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.IndexTableHint as src ->
        TableHint.IndexTableHint((src.HintKind),(src.IndexValues |> Seq.map (fun src -> IdentifierOrValueExpression.IdentifierOrValueExpression((src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (Option.ofObj (src.Value)), (src.ValueExpression |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq))
      | :? ScriptDom.LiteralTableHint as src ->
        TableHint.LiteralTableHint((src.HintKind),(src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | _ -> (* :? ScriptDom.TableHint as src *)
        TableHint.Base(((src.HintKind))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] TableIndexType = (* IsAbstract = true *)
  | TableClusteredIndexType of ColumnStore:bool * Columns:(ColumnWithSortOrder) list * OrderedColumns:(ColumnReferenceExpression) list
  | TableNonClusteredIndexType 
  member this.ToCs() : ScriptDom.TableIndexType =
    match this with
    | TableClusteredIndexType(ColumnStore=aColumnStore; Columns=aColumns; OrderedColumns=aOrderedColumns) ->
      let ret = ScriptDom.TableClusteredIndexType()
      ret.ColumnStore <- aColumnStore
      for e in aColumns do ret.Columns.Add (e.ToCs())
      for e in aOrderedColumns do ret.OrderedColumns.Add (e.ToCs())
      ret :> ScriptDom.TableIndexType (* 335 *)
    | TableNonClusteredIndexType -> ScriptDom.TableNonClusteredIndexType() :> ScriptDom.TableIndexType (* 327 *)
  static member FromCs(src:ScriptDom.TableIndexType, fragmentMapping:FragmentMapping) : TableIndexType =
    let ret =
      match src with
      | :? ScriptDom.TableClusteredIndexType as src ->
        TableIndexType.TableClusteredIndexType((src.ColumnStore),(src.Columns |> Seq.map (fun src -> ColumnWithSortOrder.ColumnWithSortOrder((src.Column |> Option.ofObj |> Option.map (fun x -> ColumnReferenceExpression.FromCs(x, fragmentMapping))), (src.SortOrder))) |> List.ofSeq),(src.OrderedColumns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq))
      | :? ScriptDom.TableNonClusteredIndexType as src ->
        TableIndexType.TableNonClusteredIndexType
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] TableOption = (* IsAbstract = true *)
  | DurabilityTableOption of DurabilityTableOptionKind:ScriptDom.DurabilityTableOptionKind * OptionKind:ScriptDom.TableOptionKind
  | FileStreamOnTableOption of OptionKind:ScriptDom.TableOptionKind * Value:IdentifierOrValueExpression option
  | FileTableCollateFileNameTableOption of OptionKind:ScriptDom.TableOptionKind * Value:Identifier option
  | FileTableConstraintNameTableOption of OptionKind:ScriptDom.TableOptionKind * Value:Identifier option
  | FileTableDirectoryTableOption of OptionKind:ScriptDom.TableOptionKind * Value:Literal option
  | LocationOption of LocationValue:Identifier option * OptionKind:ScriptDom.TableOptionKind
  | LockEscalationTableOption of OptionKind:ScriptDom.TableOptionKind * Value:ScriptDom.LockEscalationMethod
  | MemoryOptimizedTableOption of OptionKind:ScriptDom.TableOptionKind * OptionState:ScriptDom.OptionState
  | RemoteDataArchiveAlterTableOption of FilterPredicate:FunctionCall option * IsFilterPredicateSpecified:bool * IsMigrationStateSpecified:bool * MigrationState:ScriptDom.MigrationState * OptionKind:ScriptDom.TableOptionKind * RdaTableOption:ScriptDom.RdaTableOption
  | RemoteDataArchiveTableOption of MigrationState:ScriptDom.MigrationState * OptionKind:ScriptDom.TableOptionKind * RdaTableOption:ScriptDom.RdaTableOption
  | SystemVersioningTableOption of ConsistencyCheckEnabled:ScriptDom.OptionState * HistoryTable:SchemaObjectName option * OptionKind:ScriptDom.TableOptionKind * OptionState:ScriptDom.OptionState * RetentionPeriod:RetentionPeriodDefinition option
  | TableDataCompressionOption of DataCompressionOption:DataCompressionOption option * OptionKind:ScriptDom.TableOptionKind
  | TableDistributionOption of OptionKind:ScriptDom.TableOptionKind * Value:TableDistributionPolicy option
  | TableIndexOption of OptionKind:ScriptDom.TableOptionKind * Value:TableIndexType option
  | TablePartitionOption of OptionKind:ScriptDom.TableOptionKind * PartitionColumn:Identifier option * PartitionOptionSpecs:TablePartitionOptionSpecifications option
  member this.ToCs() : ScriptDom.TableOption =
    match this with
    | DurabilityTableOption(DurabilityTableOptionKind=aDurabilityTableOptionKind; OptionKind=aOptionKind) ->
      let ret = ScriptDom.DurabilityTableOption()
      ret.DurabilityTableOptionKind <- aDurabilityTableOptionKind
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.TableOption (* 335 *)
    | FileStreamOnTableOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.FileStreamOnTableOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableOption (* 335 *)
    | FileTableCollateFileNameTableOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.FileTableCollateFileNameTableOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableOption (* 335 *)
    | FileTableConstraintNameTableOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.FileTableConstraintNameTableOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableOption (* 335 *)
    | FileTableDirectoryTableOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.FileTableDirectoryTableOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableOption (* 335 *)
    | LocationOption(LocationValue=aLocationValue; OptionKind=aOptionKind) ->
      let ret = ScriptDom.LocationOption()
      ret.LocationValue <- aLocationValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.TableOption (* 335 *)
    | LockEscalationTableOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.LockEscalationTableOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.TableOption (* 335 *)
    | MemoryOptimizedTableOption(OptionKind=aOptionKind; OptionState=aOptionState) ->
      let ret = ScriptDom.MemoryOptimizedTableOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret :> ScriptDom.TableOption (* 335 *)
    | RemoteDataArchiveAlterTableOption(FilterPredicate=aFilterPredicate; IsFilterPredicateSpecified=aIsFilterPredicateSpecified; IsMigrationStateSpecified=aIsMigrationStateSpecified; MigrationState=aMigrationState; OptionKind=aOptionKind; RdaTableOption=aRdaTableOption) ->
      let ret = ScriptDom.RemoteDataArchiveAlterTableOption()
      ret.FilterPredicate <- aFilterPredicate |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsFilterPredicateSpecified <- aIsFilterPredicateSpecified
      ret.IsMigrationStateSpecified <- aIsMigrationStateSpecified
      ret.MigrationState <- aMigrationState
      ret.OptionKind <- aOptionKind
      ret.RdaTableOption <- aRdaTableOption
      ret :> ScriptDom.TableOption (* 335 *)
    | RemoteDataArchiveTableOption(MigrationState=aMigrationState; OptionKind=aOptionKind; RdaTableOption=aRdaTableOption) ->
      let ret = ScriptDom.RemoteDataArchiveTableOption()
      ret.MigrationState <- aMigrationState
      ret.OptionKind <- aOptionKind
      ret.RdaTableOption <- aRdaTableOption
      ret :> ScriptDom.TableOption (* 335 *)
    | SystemVersioningTableOption(ConsistencyCheckEnabled=aConsistencyCheckEnabled; HistoryTable=aHistoryTable; OptionKind=aOptionKind; OptionState=aOptionState; RetentionPeriod=aRetentionPeriod) ->
      let ret = ScriptDom.SystemVersioningTableOption()
      ret.ConsistencyCheckEnabled <- aConsistencyCheckEnabled
      ret.HistoryTable <- aHistoryTable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret.RetentionPeriod <- aRetentionPeriod |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableOption (* 335 *)
    | TableDataCompressionOption(DataCompressionOption=aDataCompressionOption; OptionKind=aOptionKind) ->
      let ret = ScriptDom.TableDataCompressionOption()
      ret.DataCompressionOption <- aDataCompressionOption |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.TableOption (* 335 *)
    | TableDistributionOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.TableDistributionOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableOption (* 335 *)
    | TableIndexOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.TableIndexOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableOption (* 335 *)
    | TablePartitionOption(OptionKind=aOptionKind; PartitionColumn=aPartitionColumn; PartitionOptionSpecs=aPartitionOptionSpecs) ->
      let ret = ScriptDom.TablePartitionOption()
      ret.OptionKind <- aOptionKind
      ret.PartitionColumn <- aPartitionColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PartitionOptionSpecs <- aPartitionOptionSpecs |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableOption (* 335 *)
  static member FromCs(src:ScriptDom.TableOption, fragmentMapping:FragmentMapping) : TableOption =
    let ret =
      match src with
      | :? ScriptDom.DurabilityTableOption as src ->
        TableOption.DurabilityTableOption((src.DurabilityTableOptionKind),(src.OptionKind))
      | :? ScriptDom.FileStreamOnTableOption as src ->
        TableOption.FileStreamOnTableOption((src.OptionKind),(src.Value |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.FileTableCollateFileNameTableOption as src ->
        TableOption.FileTableCollateFileNameTableOption((src.OptionKind),(src.Value |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.FileTableConstraintNameTableOption as src ->
        TableOption.FileTableConstraintNameTableOption((src.OptionKind),(src.Value |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.FileTableDirectoryTableOption as src ->
        TableOption.FileTableDirectoryTableOption((src.OptionKind),(src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.LocationOption as src ->
        TableOption.LocationOption((src.LocationValue |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.OptionKind))
      | :? ScriptDom.LockEscalationTableOption as src ->
        TableOption.LockEscalationTableOption((src.OptionKind),(src.Value))
      | :? ScriptDom.MemoryOptimizedTableOption as src ->
        TableOption.MemoryOptimizedTableOption((src.OptionKind),(src.OptionState))
      | :? ScriptDom.RemoteDataArchiveAlterTableOption as src ->
        TableOption.RemoteDataArchiveAlterTableOption((src.FilterPredicate |> Option.ofObj |> Option.map (fun x -> FunctionCall.FromCs(x, fragmentMapping))),(src.IsFilterPredicateSpecified),(src.IsMigrationStateSpecified),(src.MigrationState),(src.OptionKind),(src.RdaTableOption))
      | :? ScriptDom.RemoteDataArchiveTableOption as src ->
        TableOption.RemoteDataArchiveTableOption((src.MigrationState),(src.OptionKind),(src.RdaTableOption))
      | :? ScriptDom.SystemVersioningTableOption as src ->
        TableOption.SystemVersioningTableOption((src.ConsistencyCheckEnabled),(src.HistoryTable |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.OptionKind),(src.OptionState),(src.RetentionPeriod |> Option.ofObj |> Option.map (fun x -> RetentionPeriodDefinition.FromCs(x, fragmentMapping))))
      | :? ScriptDom.TableDataCompressionOption as src ->
        TableOption.TableDataCompressionOption((src.DataCompressionOption |> Option.ofObj |> Option.map (fun x -> DataCompressionOption.FromCs(x, fragmentMapping))),(src.OptionKind))
      | :? ScriptDom.TableDistributionOption as src ->
        TableOption.TableDistributionOption((src.OptionKind),(src.Value |> Option.ofObj |> Option.map (fun x -> TableDistributionPolicy.FromCs(x, fragmentMapping))))
      | :? ScriptDom.TableIndexOption as src ->
        TableOption.TableIndexOption((src.OptionKind),(src.Value |> Option.ofObj |> Option.map (fun x -> TableIndexType.FromCs(x, fragmentMapping))))
      | :? ScriptDom.TablePartitionOption as src ->
        TableOption.TablePartitionOption((src.OptionKind),(src.PartitionColumn |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.PartitionOptionSpecs |> Option.ofObj |> Option.map (fun x -> TablePartitionOptionSpecifications.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] TableReference = (* IsAbstract = true *)
  | JoinParenthesisTableReference of Join:TableReference option
  | JoinTableReference of JoinTableReference
  | OdbcQualifiedJoinTableReference of TableReference:TableReference option
  | TableReferenceWithAlias of TableReferenceWithAlias
  member this.ToCs() : ScriptDom.TableReference =
    match this with
    | JoinParenthesisTableReference(Join=aJoin) ->
      let ret = ScriptDom.JoinParenthesisTableReference()
      ret.Join <- aJoin |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableReference (* 335 *)
    | JoinTableReference(x) -> x.ToCs() :> ScriptDom.TableReference (* 345 *)
    | OdbcQualifiedJoinTableReference(TableReference=aTableReference) ->
      let ret = ScriptDom.OdbcQualifiedJoinTableReference()
      ret.TableReference <- aTableReference |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableReference (* 335 *)
    | TableReferenceWithAlias(x) -> x.ToCs() :> ScriptDom.TableReference (* 345 *)
  static member FromCs(src:ScriptDom.TableReference, fragmentMapping:FragmentMapping) : TableReference =
    let ret =
      match src with
      | :? ScriptDom.JoinParenthesisTableReference as src ->
        TableReference.JoinParenthesisTableReference((src.Join |> Option.ofObj |> Option.map (fun x -> TableReference.FromCs(x, fragmentMapping))))
      | :? ScriptDom.JoinTableReference as src ->
        match src with
        | :? ScriptDom.QualifiedJoin as src->
          TableReference.JoinTableReference((JoinTableReference.QualifiedJoin((src.FirstTableReference |> Option.ofObj |> Option.map (fun x -> TableReference.FromCs(x, fragmentMapping))), (src.JoinHint), (src.QualifiedJoinType), (src.SearchCondition |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))), (src.SecondTableReference |> Option.ofObj |> Option.map (fun x -> TableReference.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.UnqualifiedJoin as src->
          TableReference.JoinTableReference((JoinTableReference.UnqualifiedJoin((src.FirstTableReference |> Option.ofObj |> Option.map (fun x -> TableReference.FromCs(x, fragmentMapping))), (src.SecondTableReference |> Option.ofObj |> Option.map (fun x -> TableReference.FromCs(x, fragmentMapping))), (src.UnqualifiedJoinType))  ))
      | :? ScriptDom.OdbcQualifiedJoinTableReference as src ->
        TableReference.OdbcQualifiedJoinTableReference((src.TableReference |> Option.ofObj |> Option.map (fun x -> TableReference.FromCs(x, fragmentMapping))))
      | :? ScriptDom.TableReferenceWithAlias as src ->
        match src with
        | :? ScriptDom.AdHocTableReference as src->
          TableReference.TableReferenceWithAlias((TableReferenceWithAlias.AdHocTableReference((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.DataSource |> Option.ofObj |> Option.map (fun x -> AdHocDataSource.FromCs(x, fragmentMapping))), (src.Object |> Option.ofObj |> Option.map (fun x -> SchemaObjectNameOrValueExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.BuiltInFunctionTableReference as src->
          TableReference.TableReferenceWithAlias((TableReferenceWithAlias.BuiltInFunctionTableReference((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Parameters |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.FullTextTableReference as src->
          TableReference.TableReferenceWithAlias((TableReferenceWithAlias.FullTextTableReference((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.FullTextFunctionType), (src.Language |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))), (src.PropertyName |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))), (src.SearchCondition |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))), (src.TableName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.TopN |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.GlobalFunctionTableReference as src->
          TableReference.TableReferenceWithAlias((TableReferenceWithAlias.GlobalFunctionTableReference((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Parameters |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.InternalOpenRowset as src->
          TableReference.TableReferenceWithAlias((TableReferenceWithAlias.InternalOpenRowset((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.VarArgs |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.NamedTableReference as src->
          TableReference.TableReferenceWithAlias((TableReferenceWithAlias.NamedTableReference((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ForPath), (src.SchemaObject |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.TableHints |> Seq.map (fun x -> TableHint.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.TableSampleClause |> Option.ofObj |> Option.map (fun x -> TableSampleClause.FromCs(x, fragmentMapping))), (src.TemporalClause |> Option.ofObj |> Option.map (fun x -> TemporalClause.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.OpenJsonTableReference as src->
          TableReference.TableReferenceWithAlias((TableReferenceWithAlias.OpenJsonTableReference((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.RowPattern |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.SchemaDeclarationItems |> Seq.map (fun src -> SchemaDeclarationItemOpenjson.SchemaDeclarationItemOpenjson((src.AsJson), (src.ColumnDefinition |> Option.ofObj |> Option.map (fun x -> ColumnDefinitionBase.FromCs(x, fragmentMapping))), (src.Mapping |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.Variable |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.OpenQueryTableReference as src->
          TableReference.TableReferenceWithAlias((TableReferenceWithAlias.OpenQueryTableReference((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.LinkedServer |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Query |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.OpenRowsetTableReference as src->
          TableReference.TableReferenceWithAlias((TableReferenceWithAlias.OpenRowsetTableReference((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.DataSource |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))), (src.Object |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.Password |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))), (src.ProviderName |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))), (src.ProviderString |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))), (src.Query |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))), (src.UserId |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.OpenXmlTableReference as src->
          TableReference.TableReferenceWithAlias((TableReferenceWithAlias.OpenXmlTableReference((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Flags |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))), (src.RowPattern |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))), (src.SchemaDeclarationItems |> Seq.map (fun x -> SchemaDeclarationItem.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.TableName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.Variable |> Option.ofObj |> Option.map (fun x -> VariableReference.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.PivotedTableReference as src->
          TableReference.TableReferenceWithAlias((TableReferenceWithAlias.PivotedTableReference((src.AggregateFunctionIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))), (src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.InColumns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.PivotColumn |> Option.ofObj |> Option.map (fun x -> ColumnReferenceExpression.FromCs(x, fragmentMapping))), (src.TableReference |> Option.ofObj |> Option.map (fun x -> TableReference.FromCs(x, fragmentMapping))), (src.ValueColumns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq))  ))
        | :? ScriptDom.SemanticTableReference as src->
          TableReference.TableReferenceWithAlias((TableReferenceWithAlias.SemanticTableReference((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.MatchedColumn |> Option.ofObj |> Option.map (fun x -> ColumnReferenceExpression.FromCs(x, fragmentMapping))), (src.MatchedKey |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.SemanticFunctionType), (src.SourceKey |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.TableName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.TableReferenceWithAliasAndColumns as src->
          TableReference.TableReferenceWithAlias((TableReferenceWithAlias.TableReferenceWithAliasAndColumns((TableReferenceWithAliasAndColumns.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.UnpivotedTableReference as src->
          TableReference.TableReferenceWithAlias((TableReferenceWithAlias.UnpivotedTableReference((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.InColumns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.PivotColumn |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.TableReference |> Option.ofObj |> Option.map (fun x -> TableReference.FromCs(x, fragmentMapping))), (src.ValueColumn |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.VariableTableReference as src->
          TableReference.TableReferenceWithAlias((TableReferenceWithAlias.VariableTableReference((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Variable |> Option.ofObj |> Option.map (fun x -> VariableReference.FromCs(x, fragmentMapping))))  ))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] TableSwitchOption = (* IsAbstract = true *)
  | LowPriorityLockWaitTableSwitchOption of OptionKind:ScriptDom.TableSwitchOptionKind * Options:(LowPriorityLockWaitOption) list
  | TruncateTargetTableSwitchOption of OptionKind:ScriptDom.TableSwitchOptionKind * TruncateTarget:bool
  member this.ToCs() : ScriptDom.TableSwitchOption =
    match this with
    | LowPriorityLockWaitTableSwitchOption(OptionKind=aOptionKind; Options=aOptions) ->
      let ret = ScriptDom.LowPriorityLockWaitTableSwitchOption()
      ret.OptionKind <- aOptionKind
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.TableSwitchOption (* 335 *)
    | TruncateTargetTableSwitchOption(OptionKind=aOptionKind; TruncateTarget=aTruncateTarget) ->
      let ret = ScriptDom.TruncateTargetTableSwitchOption()
      ret.OptionKind <- aOptionKind
      ret.TruncateTarget <- aTruncateTarget
      ret :> ScriptDom.TableSwitchOption (* 335 *)
  static member FromCs(src:ScriptDom.TableSwitchOption, fragmentMapping:FragmentMapping) : TableSwitchOption =
    let ret =
      match src with
      | :? ScriptDom.LowPriorityLockWaitTableSwitchOption as src ->
        TableSwitchOption.LowPriorityLockWaitTableSwitchOption((src.OptionKind),(src.Options |> Seq.map (fun x -> LowPriorityLockWaitOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.TruncateTargetTableSwitchOption as src ->
        TableSwitchOption.TruncateTargetTableSwitchOption((src.OptionKind),(src.TruncateTarget))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] TriggerOption = (* IsAbstract = false *)
  | Base of OptionKind:ScriptDom.TriggerOptionKind
  | ExecuteAsTriggerOption of ExecuteAsClause:ExecuteAsClause option * OptionKind:ScriptDom.TriggerOptionKind
  member this.ToCs() : ScriptDom.TriggerOption =
    match this with
    | ExecuteAsTriggerOption(ExecuteAsClause=aExecuteAsClause; OptionKind=aOptionKind) ->
      let ret = ScriptDom.ExecuteAsTriggerOption()
      ret.ExecuteAsClause <- aExecuteAsClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.TriggerOption (* 335 *)
    | Base(OptionKind=aOptionKind) ->

      let ret = ScriptDom.TriggerOption()
      ret.OptionKind <- aOptionKind
      ret
  static member FromCs(src:ScriptDom.TriggerOption, fragmentMapping:FragmentMapping) : TriggerOption =
    let ret =
      match src with
      | :? ScriptDom.ExecuteAsTriggerOption as src ->
        TriggerOption.ExecuteAsTriggerOption((src.ExecuteAsClause |> Option.ofObj |> Option.map (fun x -> ExecuteAsClause.FromCs(x, fragmentMapping))),(src.OptionKind))
      | _ -> (* :? ScriptDom.TriggerOption as src *)
        TriggerOption.Base(((src.OptionKind))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ViewDistributionPolicy = (* IsAbstract = true *)
  | ViewHashDistributionPolicy of DistributionColumn:Identifier option
  | ViewRoundRobinDistributionPolicy 
  member this.ToCs() : ScriptDom.ViewDistributionPolicy =
    match this with
    | ViewHashDistributionPolicy(DistributionColumn=aDistributionColumn) ->
      let ret = ScriptDom.ViewHashDistributionPolicy()
      ret.DistributionColumn <- aDistributionColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ViewDistributionPolicy (* 335 *)
    | ViewRoundRobinDistributionPolicy -> ScriptDom.ViewRoundRobinDistributionPolicy() :> ScriptDom.ViewDistributionPolicy (* 327 *)
  static member FromCs(src:ScriptDom.ViewDistributionPolicy, fragmentMapping:FragmentMapping) : ViewDistributionPolicy =
    let ret =
      match src with
      | :? ScriptDom.ViewHashDistributionPolicy as src ->
        ViewDistributionPolicy.ViewHashDistributionPolicy((src.DistributionColumn |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ViewRoundRobinDistributionPolicy as src ->
        ViewDistributionPolicy.ViewRoundRobinDistributionPolicy
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ViewOption = (* IsAbstract = false *)
  | Base of OptionKind:ScriptDom.ViewOptionKind
  | ViewDistributionOption of OptionKind:ScriptDom.ViewOptionKind * Value:ViewDistributionPolicy option
  | ViewForAppendOption of OptionKind:ScriptDom.ViewOptionKind
  member this.ToCs() : ScriptDom.ViewOption =
    match this with
    | ViewDistributionOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.ViewDistributionOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ViewOption (* 335 *)
    | ViewForAppendOption(OptionKind=aOptionKind) ->
      let ret = ScriptDom.ViewForAppendOption()
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.ViewOption (* 335 *)
    | Base(OptionKind=aOptionKind) ->

      let ret = ScriptDom.ViewOption()
      ret.OptionKind <- aOptionKind
      ret
  static member FromCs(src:ScriptDom.ViewOption, fragmentMapping:FragmentMapping) : ViewOption =
    let ret =
      match src with
      | :? ScriptDom.ViewDistributionOption as src ->
        ViewOption.ViewDistributionOption((src.OptionKind),(src.Value |> Option.ofObj |> Option.map (fun x -> ViewDistributionPolicy.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ViewForAppendOption as src ->
        ViewOption.ViewForAppendOption((src.OptionKind))
      | _ -> (* :? ScriptDom.ViewOption as src *)
        ViewOption.Base(((src.OptionKind))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] WhenClause = (* IsAbstract = true *)
  | SearchedWhenClause of ThenExpression:ScalarExpression option * WhenExpression:BooleanExpression option
  | SimpleWhenClause of ThenExpression:ScalarExpression option * WhenExpression:ScalarExpression option
  member this.ToCs() : ScriptDom.WhenClause =
    match this with
    | SearchedWhenClause(ThenExpression=aThenExpression; WhenExpression=aWhenExpression) ->
      let ret = ScriptDom.SearchedWhenClause()
      ret.ThenExpression <- aThenExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WhenExpression <- aWhenExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.WhenClause (* 335 *)
    | SimpleWhenClause(ThenExpression=aThenExpression; WhenExpression=aWhenExpression) ->
      let ret = ScriptDom.SimpleWhenClause()
      ret.ThenExpression <- aThenExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WhenExpression <- aWhenExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.WhenClause (* 335 *)
  static member FromCs(src:ScriptDom.WhenClause, fragmentMapping:FragmentMapping) : WhenClause =
    let ret =
      match src with
      | :? ScriptDom.SearchedWhenClause as src ->
        WhenClause.SearchedWhenClause((src.ThenExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.WhenExpression |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.SimpleWhenClause as src ->
        WhenClause.SimpleWhenClause((src.ThenExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.WhenExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] WorkloadClassifierOption = (* IsAbstract = true *)
  | ClassifierEndTimeOption of OptionType:ScriptDom.WorkloadClassifierOptionType * Time:WlmTimeLiteral option
  | ClassifierImportanceOption of Importance:ScriptDom.ImportanceParameterType * OptionType:ScriptDom.WorkloadClassifierOptionType
  | ClassifierMemberNameOption of MemberName:StringLiteral option * OptionType:ScriptDom.WorkloadClassifierOptionType
  | ClassifierStartTimeOption of OptionType:ScriptDom.WorkloadClassifierOptionType * Time:WlmTimeLiteral option
  | ClassifierWlmContextOption of OptionType:ScriptDom.WorkloadClassifierOptionType * WlmContext:StringLiteral option
  | ClassifierWlmLabelOption of OptionType:ScriptDom.WorkloadClassifierOptionType * WlmLabel:StringLiteral option
  | ClassifierWorkloadGroupOption of OptionType:ScriptDom.WorkloadClassifierOptionType * WorkloadGroupName:StringLiteral option
  member this.ToCs() : ScriptDom.WorkloadClassifierOption =
    match this with
    | ClassifierEndTimeOption(OptionType=aOptionType; Time=aTime) ->
      let ret = ScriptDom.ClassifierEndTimeOption()
      ret.OptionType <- aOptionType
      ret.Time <- aTime |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.WorkloadClassifierOption (* 335 *)
    | ClassifierImportanceOption(Importance=aImportance; OptionType=aOptionType) ->
      let ret = ScriptDom.ClassifierImportanceOption()
      ret.Importance <- aImportance
      ret.OptionType <- aOptionType
      ret :> ScriptDom.WorkloadClassifierOption (* 335 *)
    | ClassifierMemberNameOption(MemberName=aMemberName; OptionType=aOptionType) ->
      let ret = ScriptDom.ClassifierMemberNameOption()
      ret.MemberName <- aMemberName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionType <- aOptionType
      ret :> ScriptDom.WorkloadClassifierOption (* 335 *)
    | ClassifierStartTimeOption(OptionType=aOptionType; Time=aTime) ->
      let ret = ScriptDom.ClassifierStartTimeOption()
      ret.OptionType <- aOptionType
      ret.Time <- aTime |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.WorkloadClassifierOption (* 335 *)
    | ClassifierWlmContextOption(OptionType=aOptionType; WlmContext=aWlmContext) ->
      let ret = ScriptDom.ClassifierWlmContextOption()
      ret.OptionType <- aOptionType
      ret.WlmContext <- aWlmContext |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.WorkloadClassifierOption (* 335 *)
    | ClassifierWlmLabelOption(OptionType=aOptionType; WlmLabel=aWlmLabel) ->
      let ret = ScriptDom.ClassifierWlmLabelOption()
      ret.OptionType <- aOptionType
      ret.WlmLabel <- aWlmLabel |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.WorkloadClassifierOption (* 335 *)
    | ClassifierWorkloadGroupOption(OptionType=aOptionType; WorkloadGroupName=aWorkloadGroupName) ->
      let ret = ScriptDom.ClassifierWorkloadGroupOption()
      ret.OptionType <- aOptionType
      ret.WorkloadGroupName <- aWorkloadGroupName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.WorkloadClassifierOption (* 335 *)
  static member FromCs(src:ScriptDom.WorkloadClassifierOption, fragmentMapping:FragmentMapping) : WorkloadClassifierOption =
    let ret =
      match src with
      | :? ScriptDom.ClassifierEndTimeOption as src ->
        WorkloadClassifierOption.ClassifierEndTimeOption((src.OptionType),(src.Time |> Option.ofObj |> Option.map (fun x -> WlmTimeLiteral.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ClassifierImportanceOption as src ->
        WorkloadClassifierOption.ClassifierImportanceOption((src.Importance),(src.OptionType))
      | :? ScriptDom.ClassifierMemberNameOption as src ->
        WorkloadClassifierOption.ClassifierMemberNameOption((src.MemberName |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))),(src.OptionType))
      | :? ScriptDom.ClassifierStartTimeOption as src ->
        WorkloadClassifierOption.ClassifierStartTimeOption((src.OptionType),(src.Time |> Option.ofObj |> Option.map (fun x -> WlmTimeLiteral.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ClassifierWlmContextOption as src ->
        WorkloadClassifierOption.ClassifierWlmContextOption((src.OptionType),(src.WlmContext |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ClassifierWlmLabelOption as src ->
        WorkloadClassifierOption.ClassifierWlmLabelOption((src.OptionType),(src.WlmLabel |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ClassifierWorkloadGroupOption as src ->
        WorkloadClassifierOption.ClassifierWorkloadGroupOption((src.OptionType),(src.WorkloadGroupName |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] WorkloadGroupParameter = (* IsAbstract = true *)
  | WorkloadGroupImportanceParameter of ParameterType:ScriptDom.WorkloadGroupParameterType * ParameterValue:ScriptDom.ImportanceParameterType
  | WorkloadGroupResourceParameter of ParameterType:ScriptDom.WorkloadGroupParameterType * ParameterValue:Literal option
  member this.ToCs() : ScriptDom.WorkloadGroupParameter =
    match this with
    | WorkloadGroupImportanceParameter(ParameterType=aParameterType; ParameterValue=aParameterValue) ->
      let ret = ScriptDom.WorkloadGroupImportanceParameter()
      ret.ParameterType <- aParameterType
      ret.ParameterValue <- aParameterValue
      ret :> ScriptDom.WorkloadGroupParameter (* 335 *)
    | WorkloadGroupResourceParameter(ParameterType=aParameterType; ParameterValue=aParameterValue) ->
      let ret = ScriptDom.WorkloadGroupResourceParameter()
      ret.ParameterType <- aParameterType
      ret.ParameterValue <- aParameterValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.WorkloadGroupParameter (* 335 *)
  static member FromCs(src:ScriptDom.WorkloadGroupParameter, fragmentMapping:FragmentMapping) : WorkloadGroupParameter =
    let ret =
      match src with
      | :? ScriptDom.WorkloadGroupImportanceParameter as src ->
        WorkloadGroupParameter.WorkloadGroupImportanceParameter((src.ParameterType),(src.ParameterValue))
      | :? ScriptDom.WorkloadGroupResourceParameter as src ->
        WorkloadGroupParameter.WorkloadGroupResourceParameter((src.ParameterType),(src.ParameterValue |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] XmlNamespacesElement = (* IsAbstract = true *)
  | XmlNamespacesAliasElement of Identifier:Identifier option * String:StringLiteral option
  | XmlNamespacesDefaultElement of String:StringLiteral option
  member this.ToCs() : ScriptDom.XmlNamespacesElement =
    match this with
    | XmlNamespacesAliasElement(Identifier=aIdentifier; String=aString) ->
      let ret = ScriptDom.XmlNamespacesAliasElement()
      ret.Identifier <- aIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.String <- aString |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.XmlNamespacesElement (* 335 *)
    | XmlNamespacesDefaultElement(String=aString) ->
      let ret = ScriptDom.XmlNamespacesDefaultElement()
      ret.String <- aString |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.XmlNamespacesElement (* 335 *)
  static member FromCs(src:ScriptDom.XmlNamespacesElement, fragmentMapping:FragmentMapping) : XmlNamespacesElement =
    let ret =
      match src with
      | :? ScriptDom.XmlNamespacesAliasElement as src ->
        XmlNamespacesElement.XmlNamespacesAliasElement((src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.String |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))))
      | :? ScriptDom.XmlNamespacesDefaultElement as src ->
        XmlNamespacesElement.XmlNamespacesDefaultElement((src.String |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] UpdateDeleteSpecificationBase = (* IsAbstract = true *)
  | DeleteSpecification of FromClause:FromClause option * OutputClause:OutputClause option * OutputIntoClause:OutputIntoClause option * Target:TableReference option * TopRowFilter:TopRowFilter option * WhereClause:WhereClause option
  | UpdateSpecification of FromClause:FromClause option * OutputClause:OutputClause option * OutputIntoClause:OutputIntoClause option * SetClauses:(SetClause) list * Target:TableReference option * TopRowFilter:TopRowFilter option * WhereClause:WhereClause option
  member this.ToCs() : ScriptDom.UpdateDeleteSpecificationBase =
    match this with
    | DeleteSpecification(FromClause=aFromClause; OutputClause=aOutputClause; OutputIntoClause=aOutputIntoClause; Target=aTarget; TopRowFilter=aTopRowFilter; WhereClause=aWhereClause) ->
      let ret = ScriptDom.DeleteSpecification()
      ret.FromClause <- aFromClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OutputClause <- aOutputClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OutputIntoClause <- aOutputIntoClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Target <- aTarget |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TopRowFilter <- aTopRowFilter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WhereClause <- aWhereClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.UpdateDeleteSpecificationBase (* 335 *)
    | UpdateSpecification(FromClause=aFromClause; OutputClause=aOutputClause; OutputIntoClause=aOutputIntoClause; SetClauses=aSetClauses; Target=aTarget; TopRowFilter=aTopRowFilter; WhereClause=aWhereClause) ->
      let ret = ScriptDom.UpdateSpecification()
      ret.FromClause <- aFromClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OutputClause <- aOutputClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OutputIntoClause <- aOutputIntoClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aSetClauses do ret.SetClauses.Add (e.ToCs())
      ret.Target <- aTarget |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TopRowFilter <- aTopRowFilter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WhereClause <- aWhereClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.UpdateDeleteSpecificationBase (* 335 *)
  static member FromCs(src:ScriptDom.UpdateDeleteSpecificationBase, fragmentMapping:FragmentMapping) : UpdateDeleteSpecificationBase =
    let ret =
      match src with
      | :? ScriptDom.DeleteSpecification as src ->
        UpdateDeleteSpecificationBase.DeleteSpecification((src.FromClause |> Option.ofObj |> Option.map (fun x -> FromClause.FromCs(x, fragmentMapping))),(src.OutputClause |> Option.ofObj |> Option.map (fun x -> OutputClause.FromCs(x, fragmentMapping))),(src.OutputIntoClause |> Option.ofObj |> Option.map (fun x -> OutputIntoClause.FromCs(x, fragmentMapping))),(src.Target |> Option.ofObj |> Option.map (fun x -> TableReference.FromCs(x, fragmentMapping))),(src.TopRowFilter |> Option.ofObj |> Option.map (fun x -> TopRowFilter.FromCs(x, fragmentMapping))),(src.WhereClause |> Option.ofObj |> Option.map (fun x -> WhereClause.FromCs(x, fragmentMapping))))
      | :? ScriptDom.UpdateSpecification as src ->
        UpdateDeleteSpecificationBase.UpdateSpecification((src.FromClause |> Option.ofObj |> Option.map (fun x -> FromClause.FromCs(x, fragmentMapping))),(src.OutputClause |> Option.ofObj |> Option.map (fun x -> OutputClause.FromCs(x, fragmentMapping))),(src.OutputIntoClause |> Option.ofObj |> Option.map (fun x -> OutputIntoClause.FromCs(x, fragmentMapping))),(src.SetClauses |> Seq.map (fun x -> SetClause.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Target |> Option.ofObj |> Option.map (fun x -> TableReference.FromCs(x, fragmentMapping))),(src.TopRowFilter |> Option.ofObj |> Option.map (fun x -> TopRowFilter.FromCs(x, fragmentMapping))),(src.WhereClause |> Option.ofObj |> Option.map (fun x -> WhereClause.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ParameterizedDataTypeReference = (* IsAbstract = true *)
  | SqlDataTypeReference of Name:SchemaObjectName option * Parameters:(Literal) list * SqlDataTypeOption:ScriptDom.SqlDataTypeOption
  | UserDataTypeReference of Name:SchemaObjectName option * Parameters:(Literal) list
  member this.ToCs() : ScriptDom.ParameterizedDataTypeReference =
    match this with
    | SqlDataTypeReference(Name=aName; Parameters=aParameters; SqlDataTypeOption=aSqlDataTypeOption) ->
      let ret = ScriptDom.SqlDataTypeReference()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret.SqlDataTypeOption <- aSqlDataTypeOption
      ret :> ScriptDom.ParameterizedDataTypeReference (* 335 *)
    | UserDataTypeReference(Name=aName; Parameters=aParameters) ->
      let ret = ScriptDom.UserDataTypeReference()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret :> ScriptDom.ParameterizedDataTypeReference (* 335 *)
  static member FromCs(src:ScriptDom.ParameterizedDataTypeReference, fragmentMapping:FragmentMapping) : ParameterizedDataTypeReference =
    let ret =
      match src with
      | :? ScriptDom.SqlDataTypeReference as src ->
        ParameterizedDataTypeReference.SqlDataTypeReference((src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.Parameters |> Seq.map (fun x -> Literal.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.SqlDataTypeOption))
      | :? ScriptDom.UserDataTypeReference as src ->
        ParameterizedDataTypeReference.UserDataTypeReference((src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.Parameters |> Seq.map (fun x -> Literal.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] HadrDatabaseOption = (* IsAbstract = false *)
  | Base of HadrOption:ScriptDom.HadrDatabaseOptionKind * OptionKind:ScriptDom.DatabaseOptionKind
  | HadrAvailabilityGroupDatabaseOption of GroupName:Identifier option * HadrOption:ScriptDom.HadrDatabaseOptionKind * OptionKind:ScriptDom.DatabaseOptionKind
  member this.ToCs() : ScriptDom.HadrDatabaseOption =
    match this with
    | HadrAvailabilityGroupDatabaseOption(GroupName=aGroupName; HadrOption=aHadrOption; OptionKind=aOptionKind) ->
      let ret = ScriptDom.HadrAvailabilityGroupDatabaseOption()
      ret.GroupName <- aGroupName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.HadrOption <- aHadrOption
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.HadrDatabaseOption (* 335 *)
    | Base(HadrOption=aHadrOption; OptionKind=aOptionKind) ->

      let ret = ScriptDom.HadrDatabaseOption()
      ret.HadrOption <- aHadrOption
      ret.OptionKind <- aOptionKind
      ret
  static member FromCs(src:ScriptDom.HadrDatabaseOption, fragmentMapping:FragmentMapping) : HadrDatabaseOption =
    let ret =
      match src with
      | :? ScriptDom.HadrAvailabilityGroupDatabaseOption as src ->
        HadrDatabaseOption.HadrAvailabilityGroupDatabaseOption((src.GroupName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.HadrOption),(src.OptionKind))
      | _ -> (* :? ScriptDom.HadrDatabaseOption as src *)
        HadrDatabaseOption.Base(((src.HadrOption), (src.OptionKind))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] OnOffDatabaseOption = (* IsAbstract = false *)
  | Base of OptionKind:ScriptDom.DatabaseOptionKind * OptionState:ScriptDom.OptionState
  | AutoCreateStatisticsDatabaseOption of HasIncremental:bool * IncrementalState:ScriptDom.OptionState * OptionKind:ScriptDom.DatabaseOptionKind * OptionState:ScriptDom.OptionState
  member this.ToCs() : ScriptDom.OnOffDatabaseOption =
    match this with
    | AutoCreateStatisticsDatabaseOption(HasIncremental=aHasIncremental; IncrementalState=aIncrementalState; OptionKind=aOptionKind; OptionState=aOptionState) ->
      let ret = ScriptDom.AutoCreateStatisticsDatabaseOption()
      ret.HasIncremental <- aHasIncremental
      ret.IncrementalState <- aIncrementalState
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret :> ScriptDom.OnOffDatabaseOption (* 335 *)
    | Base(OptionKind=aOptionKind; OptionState=aOptionState) ->

      let ret = ScriptDom.OnOffDatabaseOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret
  static member FromCs(src:ScriptDom.OnOffDatabaseOption, fragmentMapping:FragmentMapping) : OnOffDatabaseOption =
    let ret =
      match src with
      | :? ScriptDom.AutoCreateStatisticsDatabaseOption as src ->
        OnOffDatabaseOption.AutoCreateStatisticsDatabaseOption((src.HasIncremental),(src.IncrementalState),(src.OptionKind),(src.OptionState))
      | _ -> (* :? ScriptDom.OnOffDatabaseOption as src *)
        OnOffDatabaseOption.Base(((src.OptionKind), (src.OptionState))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] IndexStateOption = (* IsAbstract = false *)
  | Base of OptionKind:ScriptDom.IndexOptionKind * OptionState:ScriptDom.OptionState
  | IgnoreDupKeyIndexOption of OptionKind:ScriptDom.IndexOptionKind * OptionState:ScriptDom.OptionState * SuppressMessagesOption:(bool) option
  | OnlineIndexOption of LowPriorityLockWaitOption:OnlineIndexLowPriorityLockWaitOption option * OptionKind:ScriptDom.IndexOptionKind * OptionState:ScriptDom.OptionState
  member this.ToCs() : ScriptDom.IndexStateOption =
    match this with
    | IgnoreDupKeyIndexOption(OptionKind=aOptionKind; OptionState=aOptionState; SuppressMessagesOption=aSuppressMessagesOption) ->
      let ret = ScriptDom.IgnoreDupKeyIndexOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret.SuppressMessagesOption <- Option.toNullable aSuppressMessagesOption
      ret :> ScriptDom.IndexStateOption (* 335 *)
    | OnlineIndexOption(LowPriorityLockWaitOption=aLowPriorityLockWaitOption; OptionKind=aOptionKind; OptionState=aOptionState) ->
      let ret = ScriptDom.OnlineIndexOption()
      ret.LowPriorityLockWaitOption <- aLowPriorityLockWaitOption |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret :> ScriptDom.IndexStateOption (* 335 *)
    | Base(OptionKind=aOptionKind; OptionState=aOptionState) ->

      let ret = ScriptDom.IndexStateOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret
  static member FromCs(src:ScriptDom.IndexStateOption, fragmentMapping:FragmentMapping) : IndexStateOption =
    let ret =
      match src with
      | :? ScriptDom.IgnoreDupKeyIndexOption as src ->
        IndexStateOption.IgnoreDupKeyIndexOption((src.OptionKind),(src.OptionState),(Option.ofNullable (src.SuppressMessagesOption)))
      | :? ScriptDom.OnlineIndexOption as src ->
        IndexStateOption.OnlineIndexOption((src.LowPriorityLockWaitOption |> Option.ofObj |> Option.map (fun x -> OnlineIndexLowPriorityLockWaitOption.FromCs(x, fragmentMapping))),(src.OptionKind),(src.OptionState))
      | _ -> (* :? ScriptDom.IndexStateOption as src *)
        IndexStateOption.Base(((src.OptionKind), (src.OptionState))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] SchemaObjectName = (* IsAbstract = false *)
  | Base of BaseIdentifier:Identifier option * Count:Int32 * DatabaseIdentifier:Identifier option * Identifiers:(Identifier) list * SchemaIdentifier:Identifier option * ServerIdentifier:Identifier option
  | ChildObjectName of BaseIdentifier:Identifier option * ChildIdentifier:Identifier option * Count:Int32 * DatabaseIdentifier:Identifier option * Identifiers:(Identifier) list * SchemaIdentifier:Identifier option * ServerIdentifier:Identifier option
  | SchemaObjectNameSnippet of BaseIdentifier:Identifier option * Count:Int32 * DatabaseIdentifier:Identifier option * Identifiers:(Identifier) list * SchemaIdentifier:Identifier option * Script:String option * ServerIdentifier:Identifier option
  member this.ToCs() : ScriptDom.SchemaObjectName =
    match this with
    | ChildObjectName(BaseIdentifier=aBaseIdentifier; ChildIdentifier=aChildIdentifier; Count=aCount; DatabaseIdentifier=aDatabaseIdentifier; Identifiers=aIdentifiers; SchemaIdentifier=aSchemaIdentifier; ServerIdentifier=aServerIdentifier) ->
      let ret = ScriptDom.ChildObjectName()
       // Skipping prop BaseIdentifier - it is Readonly
       // Skipping prop ChildIdentifier - it is Readonly
       // Skipping prop Count - it is Readonly
       // Skipping prop DatabaseIdentifier - it is Readonly
      for e in aIdentifiers do ret.Identifiers.Add (e.ToCs())
       // Skipping prop SchemaIdentifier - it is Readonly
       // Skipping prop ServerIdentifier - it is Readonly
      ret :> ScriptDom.SchemaObjectName (* 335 *)
    | SchemaObjectNameSnippet(BaseIdentifier=aBaseIdentifier; Count=aCount; DatabaseIdentifier=aDatabaseIdentifier; Identifiers=aIdentifiers; SchemaIdentifier=aSchemaIdentifier; Script=aScript; ServerIdentifier=aServerIdentifier) ->
      let ret = ScriptDom.SchemaObjectNameSnippet()
       // Skipping prop BaseIdentifier - it is Readonly
       // Skipping prop Count - it is Readonly
       // Skipping prop DatabaseIdentifier - it is Readonly
      for e in aIdentifiers do ret.Identifiers.Add (e.ToCs())
       // Skipping prop SchemaIdentifier - it is Readonly
      ret.Script <- aScript |> Option.toObj
       // Skipping prop ServerIdentifier - it is Readonly
      ret :> ScriptDom.SchemaObjectName (* 335 *)
    | Base(BaseIdentifier=aBaseIdentifier; Count=aCount; DatabaseIdentifier=aDatabaseIdentifier; Identifiers=aIdentifiers; SchemaIdentifier=aSchemaIdentifier; ServerIdentifier=aServerIdentifier) ->

      let ret = ScriptDom.SchemaObjectName()
       // Skipping prop BaseIdentifier - it is Readonly
       // Skipping prop Count - it is Readonly
       // Skipping prop DatabaseIdentifier - it is Readonly
      for e in aIdentifiers do ret.Identifiers.Add (e.ToCs())
       // Skipping prop SchemaIdentifier - it is Readonly
       // Skipping prop ServerIdentifier - it is Readonly
      ret
  static member FromCs(src:ScriptDom.SchemaObjectName, fragmentMapping:FragmentMapping) : SchemaObjectName =
    let ret =
      match src with
      | :? ScriptDom.ChildObjectName as src ->
        SchemaObjectName.ChildObjectName((src.BaseIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.ChildIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Count),(src.DatabaseIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Identifiers |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.SchemaIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.ServerIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.SchemaObjectNameSnippet as src ->
        SchemaObjectName.SchemaObjectNameSnippet((src.BaseIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Count),(src.DatabaseIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Identifiers |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.SchemaIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(Option.ofObj (src.Script)),(src.ServerIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | _ -> (* :? ScriptDom.SchemaObjectName as src *)
        SchemaObjectName.Base(((src.BaseIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Count), (src.DatabaseIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Identifiers |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.SchemaIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ServerIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] PrimaryExpression = (* IsAbstract = true *)
  | AtTimeZoneCall of Collation:Identifier option * DateValue:ScalarExpression option * TimeZone:ScalarExpression option
  | CaseExpression of CaseExpression
  | CastCall of Collation:Identifier option * DataType:DataTypeReference option * Parameter:ScalarExpression option
  | CoalesceExpression of Collation:Identifier option * Expressions:(ScalarExpression) list
  | ColumnReferenceExpression of Collation:Identifier option * ColumnType:ScriptDom.ColumnType * MultiPartIdentifier:MultiPartIdentifier option
  | ConvertCall of Collation:Identifier option * DataType:DataTypeReference option * Parameter:ScalarExpression option * Style:ScalarExpression option
  | FunctionCall of CallTarget:CallTarget option * Collation:Identifier option * FunctionName:Identifier option * OverClause:OverClause option * Parameters:(ScalarExpression) list * UniqueRowFilter:ScriptDom.UniqueRowFilter * WithinGroupClause:WithinGroupClause option
  | IIfCall of Collation:Identifier option * ElseExpression:ScalarExpression option * Predicate:BooleanExpression option * ThenExpression:ScalarExpression option
  | LeftFunctionCall of Collation:Identifier option * Parameters:(ScalarExpression) list
  | NextValueForExpression of Collation:Identifier option * OverClause:OverClause option * SequenceName:SchemaObjectName option
  | NullIfExpression of Collation:Identifier option * FirstExpression:ScalarExpression option * SecondExpression:ScalarExpression option
  | OdbcFunctionCall of Collation:Identifier option * Name:Identifier option * Parameters:(ScalarExpression) list * ParametersUsed:bool
  | ParameterlessCall of Collation:Identifier option * ParameterlessCallType:ScriptDom.ParameterlessCallType
  | ParenthesisExpression of Collation:Identifier option * Expression:ScalarExpression option
  | ParseCall of Collation:Identifier option * Culture:ScalarExpression option * DataType:DataTypeReference option * StringValue:ScalarExpression option
  | PartitionFunctionCall of Collation:Identifier option * DatabaseName:Identifier option * FunctionName:Identifier option * Parameters:(ScalarExpression) list
  | RightFunctionCall of Collation:Identifier option * Parameters:(ScalarExpression) list
  | ScalarSubquery of Collation:Identifier option * QueryExpression:QueryExpression option
  | TryCastCall of Collation:Identifier option * DataType:DataTypeReference option * Parameter:ScalarExpression option
  | TryConvertCall of Collation:Identifier option * DataType:DataTypeReference option * Parameter:ScalarExpression option * Style:ScalarExpression option
  | TryParseCall of Collation:Identifier option * Culture:ScalarExpression option * DataType:DataTypeReference option * StringValue:ScalarExpression option
  | UserDefinedTypePropertyAccess of CallTarget:CallTarget option * Collation:Identifier option * PropertyName:Identifier option
  | ValueExpression of ValueExpression
  member this.ToCs() : ScriptDom.PrimaryExpression =
    match this with
    | AtTimeZoneCall(Collation=aCollation; DateValue=aDateValue; TimeZone=aTimeZone) ->
      let ret = ScriptDom.AtTimeZoneCall()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DateValue <- aDateValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TimeZone <- aTimeZone |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PrimaryExpression (* 335 *)
    | CaseExpression(x) -> x.ToCs() :> ScriptDom.PrimaryExpression (* 345 *)
    | CastCall(Collation=aCollation; DataType=aDataType; Parameter=aParameter) ->
      let ret = ScriptDom.CastCall()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Parameter <- aParameter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PrimaryExpression (* 335 *)
    | CoalesceExpression(Collation=aCollation; Expressions=aExpressions) ->
      let ret = ScriptDom.CoalesceExpression()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aExpressions do ret.Expressions.Add (e.ToCs())
      ret :> ScriptDom.PrimaryExpression (* 335 *)
    | ColumnReferenceExpression(Collation=aCollation; ColumnType=aColumnType; MultiPartIdentifier=aMultiPartIdentifier) ->
      let ret = ScriptDom.ColumnReferenceExpression()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ColumnType <- aColumnType
      ret.MultiPartIdentifier <- aMultiPartIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PrimaryExpression (* 335 *)
    | ConvertCall(Collation=aCollation; DataType=aDataType; Parameter=aParameter; Style=aStyle) ->
      let ret = ScriptDom.ConvertCall()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Parameter <- aParameter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Style <- aStyle |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PrimaryExpression (* 335 *)
    | FunctionCall(CallTarget=aCallTarget; Collation=aCollation; FunctionName=aFunctionName; OverClause=aOverClause; Parameters=aParameters; UniqueRowFilter=aUniqueRowFilter; WithinGroupClause=aWithinGroupClause) ->
      let ret = ScriptDom.FunctionCall()
      ret.CallTarget <- aCallTarget |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FunctionName <- aFunctionName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OverClause <- aOverClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret.UniqueRowFilter <- aUniqueRowFilter
      ret.WithinGroupClause <- aWithinGroupClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PrimaryExpression (* 335 *)
    | IIfCall(Collation=aCollation; ElseExpression=aElseExpression; Predicate=aPredicate; ThenExpression=aThenExpression) ->
      let ret = ScriptDom.IIfCall()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ElseExpression <- aElseExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Predicate <- aPredicate |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ThenExpression <- aThenExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PrimaryExpression (* 335 *)
    | LeftFunctionCall(Collation=aCollation; Parameters=aParameters) ->
      let ret = ScriptDom.LeftFunctionCall()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret :> ScriptDom.PrimaryExpression (* 335 *)
    | NextValueForExpression(Collation=aCollation; OverClause=aOverClause; SequenceName=aSequenceName) ->
      let ret = ScriptDom.NextValueForExpression()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OverClause <- aOverClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SequenceName <- aSequenceName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PrimaryExpression (* 335 *)
    | NullIfExpression(Collation=aCollation; FirstExpression=aFirstExpression; SecondExpression=aSecondExpression) ->
      let ret = ScriptDom.NullIfExpression()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FirstExpression <- aFirstExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SecondExpression <- aSecondExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PrimaryExpression (* 335 *)
    | OdbcFunctionCall(Collation=aCollation; Name=aName; Parameters=aParameters; ParametersUsed=aParametersUsed) ->
      let ret = ScriptDom.OdbcFunctionCall()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret.ParametersUsed <- aParametersUsed
      ret :> ScriptDom.PrimaryExpression (* 335 *)
    | ParameterlessCall(Collation=aCollation; ParameterlessCallType=aParameterlessCallType) ->
      let ret = ScriptDom.ParameterlessCall()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ParameterlessCallType <- aParameterlessCallType
      ret :> ScriptDom.PrimaryExpression (* 335 *)
    | ParenthesisExpression(Collation=aCollation; Expression=aExpression) ->
      let ret = ScriptDom.ParenthesisExpression()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PrimaryExpression (* 335 *)
    | ParseCall(Collation=aCollation; Culture=aCulture; DataType=aDataType; StringValue=aStringValue) ->
      let ret = ScriptDom.ParseCall()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Culture <- aCulture |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StringValue <- aStringValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PrimaryExpression (* 335 *)
    | PartitionFunctionCall(Collation=aCollation; DatabaseName=aDatabaseName; FunctionName=aFunctionName; Parameters=aParameters) ->
      let ret = ScriptDom.PartitionFunctionCall()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DatabaseName <- aDatabaseName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FunctionName <- aFunctionName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret :> ScriptDom.PrimaryExpression (* 335 *)
    | RightFunctionCall(Collation=aCollation; Parameters=aParameters) ->
      let ret = ScriptDom.RightFunctionCall()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret :> ScriptDom.PrimaryExpression (* 335 *)
    | ScalarSubquery(Collation=aCollation; QueryExpression=aQueryExpression) ->
      let ret = ScriptDom.ScalarSubquery()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.QueryExpression <- aQueryExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PrimaryExpression (* 335 *)
    | TryCastCall(Collation=aCollation; DataType=aDataType; Parameter=aParameter) ->
      let ret = ScriptDom.TryCastCall()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Parameter <- aParameter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PrimaryExpression (* 335 *)
    | TryConvertCall(Collation=aCollation; DataType=aDataType; Parameter=aParameter; Style=aStyle) ->
      let ret = ScriptDom.TryConvertCall()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Parameter <- aParameter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Style <- aStyle |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PrimaryExpression (* 335 *)
    | TryParseCall(Collation=aCollation; Culture=aCulture; DataType=aDataType; StringValue=aStringValue) ->
      let ret = ScriptDom.TryParseCall()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Culture <- aCulture |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StringValue <- aStringValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PrimaryExpression (* 335 *)
    | UserDefinedTypePropertyAccess(CallTarget=aCallTarget; Collation=aCollation; PropertyName=aPropertyName) ->
      let ret = ScriptDom.UserDefinedTypePropertyAccess()
      ret.CallTarget <- aCallTarget |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PropertyName <- aPropertyName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PrimaryExpression (* 335 *)
    | ValueExpression(x) -> x.ToCs() :> ScriptDom.PrimaryExpression (* 345 *)
  static member FromCs(src:ScriptDom.PrimaryExpression, fragmentMapping:FragmentMapping) : PrimaryExpression =
    let ret =
      match src with
      | :? ScriptDom.AtTimeZoneCall as src ->
        PrimaryExpression.AtTimeZoneCall((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.DateValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.TimeZone |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CaseExpression as src ->
        match src with
        | :? ScriptDom.SearchedCaseExpression as src->
          PrimaryExpression.CaseExpression((CaseExpression.SearchedCaseExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ElseExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.WhenClauses |> Seq.map (fun src -> SearchedWhenClause.SearchedWhenClause((src.ThenExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.WhenExpression |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq))  ))
        | :? ScriptDom.SimpleCaseExpression as src->
          PrimaryExpression.CaseExpression((CaseExpression.SimpleCaseExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ElseExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.InputExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.WhenClauses |> Seq.map (fun src -> SimpleWhenClause.SimpleWhenClause((src.ThenExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.WhenExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq))  ))
      | :? ScriptDom.CastCall as src ->
        PrimaryExpression.CastCall((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))),(src.Parameter |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CoalesceExpression as src ->
        PrimaryExpression.CoalesceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Expressions |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.ColumnReferenceExpression as src ->
        PrimaryExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.ColumnType),(src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ConvertCall as src ->
        PrimaryExpression.ConvertCall((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))),(src.Parameter |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.Style |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.FunctionCall as src ->
        PrimaryExpression.FunctionCall((src.CallTarget |> Option.ofObj |> Option.map (fun x -> CallTarget.FromCs(x, fragmentMapping))),(src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.FunctionName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.OverClause |> Option.ofObj |> Option.map (fun x -> OverClause.FromCs(x, fragmentMapping))),(src.Parameters |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.UniqueRowFilter),(src.WithinGroupClause |> Option.ofObj |> Option.map (fun x -> WithinGroupClause.FromCs(x, fragmentMapping))))
      | :? ScriptDom.IIfCall as src ->
        PrimaryExpression.IIfCall((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.ElseExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.Predicate |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))),(src.ThenExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.LeftFunctionCall as src ->
        PrimaryExpression.LeftFunctionCall((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Parameters |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.NextValueForExpression as src ->
        PrimaryExpression.NextValueForExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.OverClause |> Option.ofObj |> Option.map (fun x -> OverClause.FromCs(x, fragmentMapping))),(src.SequenceName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.NullIfExpression as src ->
        PrimaryExpression.NullIfExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.FirstExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.SecondExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.OdbcFunctionCall as src ->
        PrimaryExpression.OdbcFunctionCall((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Parameters |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.ParametersUsed))
      | :? ScriptDom.ParameterlessCall as src ->
        PrimaryExpression.ParameterlessCall((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.ParameterlessCallType))
      | :? ScriptDom.ParenthesisExpression as src ->
        PrimaryExpression.ParenthesisExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ParseCall as src ->
        PrimaryExpression.ParseCall((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Culture |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))),(src.StringValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.PartitionFunctionCall as src ->
        PrimaryExpression.PartitionFunctionCall((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.DatabaseName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.FunctionName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Parameters |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.RightFunctionCall as src ->
        PrimaryExpression.RightFunctionCall((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Parameters |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.ScalarSubquery as src ->
        PrimaryExpression.ScalarSubquery((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.QueryExpression |> Option.ofObj |> Option.map (fun x -> QueryExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.TryCastCall as src ->
        PrimaryExpression.TryCastCall((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))),(src.Parameter |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.TryConvertCall as src ->
        PrimaryExpression.TryConvertCall((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))),(src.Parameter |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.Style |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.TryParseCall as src ->
        PrimaryExpression.TryParseCall((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Culture |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))),(src.StringValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.UserDefinedTypePropertyAccess as src ->
        PrimaryExpression.UserDefinedTypePropertyAccess((src.CallTarget |> Option.ofObj |> Option.map (fun x -> CallTarget.FromCs(x, fragmentMapping))),(src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.PropertyName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ValueExpression as src ->
        match src with
        | :? ScriptDom.GlobalVariableExpression as src->
          PrimaryExpression.ValueExpression((ValueExpression.GlobalVariableExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (Option.ofObj (src.Name)))  ))
        | :? ScriptDom.Literal as src->
          PrimaryExpression.ValueExpression((ValueExpression.Literal((Literal.FromCs(src, fragmentMapping)))  ))
        | :? ScriptDom.VariableReference as src->
          PrimaryExpression.ValueExpression((ValueExpression.VariableReference((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (Option.ofObj (src.Name)))  ))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] AlterCreateEndpointStatementBase = (* IsAbstract = true *)
  | AlterEndpointStatement of Affinity:EndpointAffinity option * EndpointType:ScriptDom.EndpointType * Name:Identifier option * PayloadOptions:(PayloadOption) list * Protocol:ScriptDom.EndpointProtocol * ProtocolOptions:(EndpointProtocolOption) list * State:ScriptDom.EndpointState
  | CreateEndpointStatement of Affinity:EndpointAffinity option * EndpointType:ScriptDom.EndpointType * Name:Identifier option * Owner:Identifier option * PayloadOptions:(PayloadOption) list * Protocol:ScriptDom.EndpointProtocol * ProtocolOptions:(EndpointProtocolOption) list * State:ScriptDom.EndpointState
  member this.ToCs() : ScriptDom.AlterCreateEndpointStatementBase =
    match this with
    | AlterEndpointStatement(Affinity=aAffinity; EndpointType=aEndpointType; Name=aName; PayloadOptions=aPayloadOptions; Protocol=aProtocol; ProtocolOptions=aProtocolOptions; State=aState) ->
      let ret = ScriptDom.AlterEndpointStatement()
      ret.Affinity <- aAffinity |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.EndpointType <- aEndpointType
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aPayloadOptions do ret.PayloadOptions.Add (e.ToCs())
      ret.Protocol <- aProtocol
      for e in aProtocolOptions do ret.ProtocolOptions.Add (e.ToCs())
      ret.State <- aState
      ret :> ScriptDom.AlterCreateEndpointStatementBase (* 335 *)
    | CreateEndpointStatement(Affinity=aAffinity; EndpointType=aEndpointType; Name=aName; Owner=aOwner; PayloadOptions=aPayloadOptions; Protocol=aProtocol; ProtocolOptions=aProtocolOptions; State=aState) ->
      let ret = ScriptDom.CreateEndpointStatement()
      ret.Affinity <- aAffinity |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.EndpointType <- aEndpointType
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Owner <- aOwner |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aPayloadOptions do ret.PayloadOptions.Add (e.ToCs())
      ret.Protocol <- aProtocol
      for e in aProtocolOptions do ret.ProtocolOptions.Add (e.ToCs())
      ret.State <- aState
      ret :> ScriptDom.AlterCreateEndpointStatementBase (* 335 *)
  static member FromCs(src:ScriptDom.AlterCreateEndpointStatementBase, fragmentMapping:FragmentMapping) : AlterCreateEndpointStatementBase =
    let ret =
      match src with
      | :? ScriptDom.AlterEndpointStatement as src ->
        AlterCreateEndpointStatementBase.AlterEndpointStatement((src.Affinity |> Option.ofObj |> Option.map (fun x -> EndpointAffinity.FromCs(x, fragmentMapping))),(src.EndpointType),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.PayloadOptions |> Seq.map (fun x -> PayloadOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Protocol),(src.ProtocolOptions |> Seq.map (fun x -> EndpointProtocolOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.State))
      | :? ScriptDom.CreateEndpointStatement as src ->
        AlterCreateEndpointStatementBase.CreateEndpointStatement((src.Affinity |> Option.ofObj |> Option.map (fun x -> EndpointAffinity.FromCs(x, fragmentMapping))),(src.EndpointType),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Owner |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.PayloadOptions |> Seq.map (fun x -> PayloadOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Protocol),(src.ProtocolOptions |> Seq.map (fun x -> EndpointProtocolOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.State))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] AlterCreateServiceStatementBase = (* IsAbstract = true *)
  | AlterServiceStatement of Name:Identifier option * QueueName:SchemaObjectName option * ServiceContracts:(ServiceContract) list
  | CreateServiceStatement of Name:Identifier option * Owner:Identifier option * QueueName:SchemaObjectName option * ServiceContracts:(ServiceContract) list
  member this.ToCs() : ScriptDom.AlterCreateServiceStatementBase =
    match this with
    | AlterServiceStatement(Name=aName; QueueName=aQueueName; ServiceContracts=aServiceContracts) ->
      let ret = ScriptDom.AlterServiceStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.QueueName <- aQueueName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aServiceContracts do ret.ServiceContracts.Add (e.ToCs())
      ret :> ScriptDom.AlterCreateServiceStatementBase (* 335 *)
    | CreateServiceStatement(Name=aName; Owner=aOwner; QueueName=aQueueName; ServiceContracts=aServiceContracts) ->
      let ret = ScriptDom.CreateServiceStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Owner <- aOwner |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.QueueName <- aQueueName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aServiceContracts do ret.ServiceContracts.Add (e.ToCs())
      ret :> ScriptDom.AlterCreateServiceStatementBase (* 335 *)
  static member FromCs(src:ScriptDom.AlterCreateServiceStatementBase, fragmentMapping:FragmentMapping) : AlterCreateServiceStatementBase =
    let ret =
      match src with
      | :? ScriptDom.AlterServiceStatement as src ->
        AlterCreateServiceStatementBase.AlterServiceStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.QueueName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.ServiceContracts |> Seq.map (fun src -> ServiceContract.ServiceContract((src.Action), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))) |> List.ofSeq))
      | :? ScriptDom.CreateServiceStatement as src ->
        AlterCreateServiceStatementBase.CreateServiceStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Owner |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.QueueName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.ServiceContracts |> Seq.map (fun src -> ServiceContract.ServiceContract((src.Action), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] AlterDatabaseScopedConfigurationStatement = (* IsAbstract = true *)
  | AlterDatabaseScopedConfigurationClearStatement of Option:DatabaseConfigurationClearOption option * Secondary:bool
  | AlterDatabaseScopedConfigurationSetStatement of Option:DatabaseConfigurationSetOption option * Secondary:bool
  member this.ToCs() : ScriptDom.AlterDatabaseScopedConfigurationStatement =
    match this with
    | AlterDatabaseScopedConfigurationClearStatement(Option=aOption; Secondary=aSecondary) ->
      let ret = ScriptDom.AlterDatabaseScopedConfigurationClearStatement()
      ret.Option <- aOption |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Secondary <- aSecondary
      ret :> ScriptDom.AlterDatabaseScopedConfigurationStatement (* 335 *)
    | AlterDatabaseScopedConfigurationSetStatement(Option=aOption; Secondary=aSecondary) ->
      let ret = ScriptDom.AlterDatabaseScopedConfigurationSetStatement()
      ret.Option <- aOption |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Secondary <- aSecondary
      ret :> ScriptDom.AlterDatabaseScopedConfigurationStatement (* 335 *)
  static member FromCs(src:ScriptDom.AlterDatabaseScopedConfigurationStatement, fragmentMapping:FragmentMapping) : AlterDatabaseScopedConfigurationStatement =
    let ret =
      match src with
      | :? ScriptDom.AlterDatabaseScopedConfigurationClearStatement as src ->
        AlterDatabaseScopedConfigurationStatement.AlterDatabaseScopedConfigurationClearStatement((src.Option |> Option.ofObj |> Option.map (fun x -> DatabaseConfigurationClearOption.FromCs(x, fragmentMapping))),(src.Secondary))
      | :? ScriptDom.AlterDatabaseScopedConfigurationSetStatement as src ->
        AlterDatabaseScopedConfigurationStatement.AlterDatabaseScopedConfigurationSetStatement((src.Option |> Option.ofObj |> Option.map (fun x -> DatabaseConfigurationSetOption.FromCs(x, fragmentMapping))),(src.Secondary))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] AlterDatabaseStatement = (* IsAbstract = true *)
  | AlterDatabaseAddFileGroupStatement of ContainsFileStream:bool * ContainsMemoryOptimizedData:bool * DatabaseName:Identifier option * FileGroup:Identifier option * UseCurrent:bool
  | AlterDatabaseAddFileStatement of DatabaseName:Identifier option * FileDeclarations:(FileDeclaration) list * FileGroup:Identifier option * IsLog:bool * UseCurrent:bool
  | AlterDatabaseCollateStatement of Collation:Identifier option * DatabaseName:Identifier option * UseCurrent:bool
  | AlterDatabaseModifyFileGroupStatement of DatabaseName:Identifier option * FileGroup:Identifier option * MakeDefault:bool * NewFileGroupName:Identifier option * Termination:AlterDatabaseTermination option * UpdatabilityOption:ScriptDom.ModifyFileGroupOption * UseCurrent:bool
  | AlterDatabaseModifyFileStatement of DatabaseName:Identifier option * FileDeclaration:FileDeclaration option * UseCurrent:bool
  | AlterDatabaseModifyNameStatement of DatabaseName:Identifier option * NewDatabaseName:Identifier option * UseCurrent:bool
  | AlterDatabaseRebuildLogStatement of DatabaseName:Identifier option * FileDeclaration:FileDeclaration option * UseCurrent:bool
  | AlterDatabaseRemoveFileGroupStatement of DatabaseName:Identifier option * FileGroup:Identifier option * UseCurrent:bool
  | AlterDatabaseRemoveFileStatement of DatabaseName:Identifier option * File:Identifier option * UseCurrent:bool
  | AlterDatabaseSetStatement of DatabaseName:Identifier option * Options:(DatabaseOption) list * Termination:AlterDatabaseTermination option * UseCurrent:bool
  member this.ToCs() : ScriptDom.AlterDatabaseStatement =
    match this with
    | AlterDatabaseAddFileGroupStatement(ContainsFileStream=aContainsFileStream; ContainsMemoryOptimizedData=aContainsMemoryOptimizedData; DatabaseName=aDatabaseName; FileGroup=aFileGroup; UseCurrent=aUseCurrent) ->
      let ret = ScriptDom.AlterDatabaseAddFileGroupStatement()
      ret.ContainsFileStream <- aContainsFileStream
      ret.ContainsMemoryOptimizedData <- aContainsMemoryOptimizedData
      ret.DatabaseName <- aDatabaseName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FileGroup <- aFileGroup |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UseCurrent <- aUseCurrent
      ret :> ScriptDom.AlterDatabaseStatement (* 335 *)
    | AlterDatabaseAddFileStatement(DatabaseName=aDatabaseName; FileDeclarations=aFileDeclarations; FileGroup=aFileGroup; IsLog=aIsLog; UseCurrent=aUseCurrent) ->
      let ret = ScriptDom.AlterDatabaseAddFileStatement()
      ret.DatabaseName <- aDatabaseName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aFileDeclarations do ret.FileDeclarations.Add (e.ToCs())
      ret.FileGroup <- aFileGroup |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsLog <- aIsLog
      ret.UseCurrent <- aUseCurrent
      ret :> ScriptDom.AlterDatabaseStatement (* 335 *)
    | AlterDatabaseCollateStatement(Collation=aCollation; DatabaseName=aDatabaseName; UseCurrent=aUseCurrent) ->
      let ret = ScriptDom.AlterDatabaseCollateStatement()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DatabaseName <- aDatabaseName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UseCurrent <- aUseCurrent
      ret :> ScriptDom.AlterDatabaseStatement (* 335 *)
    | AlterDatabaseModifyFileGroupStatement(DatabaseName=aDatabaseName; FileGroup=aFileGroup; MakeDefault=aMakeDefault; NewFileGroupName=aNewFileGroupName; Termination=aTermination; UpdatabilityOption=aUpdatabilityOption; UseCurrent=aUseCurrent) ->
      let ret = ScriptDom.AlterDatabaseModifyFileGroupStatement()
      ret.DatabaseName <- aDatabaseName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FileGroup <- aFileGroup |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.MakeDefault <- aMakeDefault
      ret.NewFileGroupName <- aNewFileGroupName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Termination <- aTermination |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UpdatabilityOption <- aUpdatabilityOption
      ret.UseCurrent <- aUseCurrent
      ret :> ScriptDom.AlterDatabaseStatement (* 335 *)
    | AlterDatabaseModifyFileStatement(DatabaseName=aDatabaseName; FileDeclaration=aFileDeclaration; UseCurrent=aUseCurrent) ->
      let ret = ScriptDom.AlterDatabaseModifyFileStatement()
      ret.DatabaseName <- aDatabaseName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FileDeclaration <- aFileDeclaration |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UseCurrent <- aUseCurrent
      ret :> ScriptDom.AlterDatabaseStatement (* 335 *)
    | AlterDatabaseModifyNameStatement(DatabaseName=aDatabaseName; NewDatabaseName=aNewDatabaseName; UseCurrent=aUseCurrent) ->
      let ret = ScriptDom.AlterDatabaseModifyNameStatement()
      ret.DatabaseName <- aDatabaseName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.NewDatabaseName <- aNewDatabaseName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UseCurrent <- aUseCurrent
      ret :> ScriptDom.AlterDatabaseStatement (* 335 *)
    | AlterDatabaseRebuildLogStatement(DatabaseName=aDatabaseName; FileDeclaration=aFileDeclaration; UseCurrent=aUseCurrent) ->
      let ret = ScriptDom.AlterDatabaseRebuildLogStatement()
      ret.DatabaseName <- aDatabaseName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FileDeclaration <- aFileDeclaration |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UseCurrent <- aUseCurrent
      ret :> ScriptDom.AlterDatabaseStatement (* 335 *)
    | AlterDatabaseRemoveFileGroupStatement(DatabaseName=aDatabaseName; FileGroup=aFileGroup; UseCurrent=aUseCurrent) ->
      let ret = ScriptDom.AlterDatabaseRemoveFileGroupStatement()
      ret.DatabaseName <- aDatabaseName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FileGroup <- aFileGroup |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UseCurrent <- aUseCurrent
      ret :> ScriptDom.AlterDatabaseStatement (* 335 *)
    | AlterDatabaseRemoveFileStatement(DatabaseName=aDatabaseName; File=aFile; UseCurrent=aUseCurrent) ->
      let ret = ScriptDom.AlterDatabaseRemoveFileStatement()
      ret.DatabaseName <- aDatabaseName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.File <- aFile |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UseCurrent <- aUseCurrent
      ret :> ScriptDom.AlterDatabaseStatement (* 335 *)
    | AlterDatabaseSetStatement(DatabaseName=aDatabaseName; Options=aOptions; Termination=aTermination; UseCurrent=aUseCurrent) ->
      let ret = ScriptDom.AlterDatabaseSetStatement()
      ret.DatabaseName <- aDatabaseName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.Termination <- aTermination |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UseCurrent <- aUseCurrent
      ret :> ScriptDom.AlterDatabaseStatement (* 335 *)
  static member FromCs(src:ScriptDom.AlterDatabaseStatement, fragmentMapping:FragmentMapping) : AlterDatabaseStatement =
    let ret =
      match src with
      | :? ScriptDom.AlterDatabaseAddFileGroupStatement as src ->
        AlterDatabaseStatement.AlterDatabaseAddFileGroupStatement((src.ContainsFileStream),(src.ContainsMemoryOptimizedData),(src.DatabaseName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.FileGroup |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.UseCurrent))
      | :? ScriptDom.AlterDatabaseAddFileStatement as src ->
        AlterDatabaseStatement.AlterDatabaseAddFileStatement((src.DatabaseName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.FileDeclarations |> Seq.map (fun src -> FileDeclaration.FileDeclaration((src.IsPrimary), (src.Options |> Seq.map (fun x -> FileDeclarationOption.FromCs(x, fragmentMapping)) |> List.ofSeq))) |> List.ofSeq),(src.FileGroup |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.IsLog),(src.UseCurrent))
      | :? ScriptDom.AlterDatabaseCollateStatement as src ->
        AlterDatabaseStatement.AlterDatabaseCollateStatement((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.DatabaseName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.UseCurrent))
      | :? ScriptDom.AlterDatabaseModifyFileGroupStatement as src ->
        AlterDatabaseStatement.AlterDatabaseModifyFileGroupStatement((src.DatabaseName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.FileGroup |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.MakeDefault),(src.NewFileGroupName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Termination |> Option.ofObj |> Option.map (fun x -> AlterDatabaseTermination.FromCs(x, fragmentMapping))),(src.UpdatabilityOption),(src.UseCurrent))
      | :? ScriptDom.AlterDatabaseModifyFileStatement as src ->
        AlterDatabaseStatement.AlterDatabaseModifyFileStatement((src.DatabaseName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.FileDeclaration |> Option.ofObj |> Option.map (fun x -> FileDeclaration.FromCs(x, fragmentMapping))),(src.UseCurrent))
      | :? ScriptDom.AlterDatabaseModifyNameStatement as src ->
        AlterDatabaseStatement.AlterDatabaseModifyNameStatement((src.DatabaseName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.NewDatabaseName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.UseCurrent))
      | :? ScriptDom.AlterDatabaseRebuildLogStatement as src ->
        AlterDatabaseStatement.AlterDatabaseRebuildLogStatement((src.DatabaseName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.FileDeclaration |> Option.ofObj |> Option.map (fun x -> FileDeclaration.FromCs(x, fragmentMapping))),(src.UseCurrent))
      | :? ScriptDom.AlterDatabaseRemoveFileGroupStatement as src ->
        AlterDatabaseStatement.AlterDatabaseRemoveFileGroupStatement((src.DatabaseName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.FileGroup |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.UseCurrent))
      | :? ScriptDom.AlterDatabaseRemoveFileStatement as src ->
        AlterDatabaseStatement.AlterDatabaseRemoveFileStatement((src.DatabaseName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.File |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.UseCurrent))
      | :? ScriptDom.AlterDatabaseSetStatement as src ->
        AlterDatabaseStatement.AlterDatabaseSetStatement((src.DatabaseName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Options |> Seq.map (fun x -> DatabaseOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Termination |> Option.ofObj |> Option.map (fun x -> AlterDatabaseTermination.FromCs(x, fragmentMapping))),(src.UseCurrent))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] AlterLoginStatement = (* IsAbstract = true *)
  | AlterLoginAddDropCredentialStatement of CredentialName:Identifier option * IsAdd:bool * Name:Identifier option
  | AlterLoginEnableDisableStatement of IsEnable:bool * Name:Identifier option
  | AlterLoginOptionsStatement of Name:Identifier option * Options:(PrincipalOption) list
  member this.ToCs() : ScriptDom.AlterLoginStatement =
    match this with
    | AlterLoginAddDropCredentialStatement(CredentialName=aCredentialName; IsAdd=aIsAdd; Name=aName) ->
      let ret = ScriptDom.AlterLoginAddDropCredentialStatement()
      ret.CredentialName <- aCredentialName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsAdd <- aIsAdd
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AlterLoginStatement (* 335 *)
    | AlterLoginEnableDisableStatement(IsEnable=aIsEnable; Name=aName) ->
      let ret = ScriptDom.AlterLoginEnableDisableStatement()
      ret.IsEnable <- aIsEnable
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AlterLoginStatement (* 335 *)
    | AlterLoginOptionsStatement(Name=aName; Options=aOptions) ->
      let ret = ScriptDom.AlterLoginOptionsStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.AlterLoginStatement (* 335 *)
  static member FromCs(src:ScriptDom.AlterLoginStatement, fragmentMapping:FragmentMapping) : AlterLoginStatement =
    let ret =
      match src with
      | :? ScriptDom.AlterLoginAddDropCredentialStatement as src ->
        AlterLoginStatement.AlterLoginAddDropCredentialStatement((src.CredentialName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.IsAdd),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.AlterLoginEnableDisableStatement as src ->
        AlterLoginStatement.AlterLoginEnableDisableStatement((src.IsEnable),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.AlterLoginOptionsStatement as src ->
        AlterLoginStatement.AlterLoginOptionsStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Options |> Seq.map (fun x -> PrincipalOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] AlterTableStatement = (* IsAbstract = true *)
  | AlterTableAddTableElementStatement of Definition:TableDefinition option * ExistingRowsCheckEnforcement:ScriptDom.ConstraintEnforcement * SchemaObjectName:SchemaObjectName option
  | AlterTableAlterColumnStatement of AlterTableAlterColumnOption:ScriptDom.AlterTableAlterColumnOption * Collation:Identifier option * ColumnIdentifier:Identifier option * DataType:DataTypeReference option * Encryption:ColumnEncryptionDefinition option * GeneratedAlways:(ScriptDom.GeneratedAlwaysType) option * IsHidden:bool * IsMasked:bool * MaskingFunction:StringLiteral option * Options:(IndexOption) list * SchemaObjectName:SchemaObjectName option * StorageOptions:ColumnStorageOptions option
  | AlterTableAlterIndexStatement of AlterIndexType:ScriptDom.AlterIndexType * IndexIdentifier:Identifier option * IndexOptions:(IndexOption) list * SchemaObjectName:SchemaObjectName option
  | AlterTableAlterPartitionStatement of BoundaryValue:ScalarExpression option * IsSplit:bool * SchemaObjectName:SchemaObjectName option
  | AlterTableChangeTrackingModificationStatement of IsEnable:bool * SchemaObjectName:SchemaObjectName option * TrackColumnsUpdated:ScriptDom.OptionState
  | AlterTableConstraintModificationStatement of All:bool * ConstraintEnforcement:ScriptDom.ConstraintEnforcement * ConstraintNames:(Identifier) list * ExistingRowsCheckEnforcement:ScriptDom.ConstraintEnforcement * SchemaObjectName:SchemaObjectName option
  | AlterTableDropTableElementStatement of AlterTableDropTableElements:(AlterTableDropTableElement) list * SchemaObjectName:SchemaObjectName option
  | AlterTableFileTableNamespaceStatement of IsEnable:bool * SchemaObjectName:SchemaObjectName option
  | AlterTableRebuildStatement of IndexOptions:(IndexOption) list * Partition:PartitionSpecifier option * SchemaObjectName:SchemaObjectName option
  | AlterTableSetStatement of Options:(TableOption) list * SchemaObjectName:SchemaObjectName option
  | AlterTableSwitchStatement of Options:(TableSwitchOption) list * SchemaObjectName:SchemaObjectName option * SourcePartitionNumber:ScalarExpression option * TargetPartitionNumber:ScalarExpression option * TargetTable:SchemaObjectName option
  | AlterTableTriggerModificationStatement of All:bool * SchemaObjectName:SchemaObjectName option * TriggerEnforcement:ScriptDom.TriggerEnforcement * TriggerNames:(Identifier) list
  member this.ToCs() : ScriptDom.AlterTableStatement =
    match this with
    | AlterTableAddTableElementStatement(Definition=aDefinition; ExistingRowsCheckEnforcement=aExistingRowsCheckEnforcement; SchemaObjectName=aSchemaObjectName) ->
      let ret = ScriptDom.AlterTableAddTableElementStatement()
      ret.Definition <- aDefinition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ExistingRowsCheckEnforcement <- aExistingRowsCheckEnforcement
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AlterTableStatement (* 335 *)
    | AlterTableAlterColumnStatement(AlterTableAlterColumnOption=aAlterTableAlterColumnOption; Collation=aCollation; ColumnIdentifier=aColumnIdentifier; DataType=aDataType; Encryption=aEncryption; GeneratedAlways=aGeneratedAlways; IsHidden=aIsHidden; IsMasked=aIsMasked; MaskingFunction=aMaskingFunction; Options=aOptions; SchemaObjectName=aSchemaObjectName; StorageOptions=aStorageOptions) ->
      let ret = ScriptDom.AlterTableAlterColumnStatement()
      ret.AlterTableAlterColumnOption <- aAlterTableAlterColumnOption
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ColumnIdentifier <- aColumnIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Encryption <- aEncryption |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.GeneratedAlways <- Option.toNullable aGeneratedAlways
      ret.IsHidden <- aIsHidden
      ret.IsMasked <- aIsMasked
      ret.MaskingFunction <- aMaskingFunction |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StorageOptions <- aStorageOptions |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AlterTableStatement (* 335 *)
    | AlterTableAlterIndexStatement(AlterIndexType=aAlterIndexType; IndexIdentifier=aIndexIdentifier; IndexOptions=aIndexOptions; SchemaObjectName=aSchemaObjectName) ->
      let ret = ScriptDom.AlterTableAlterIndexStatement()
      ret.AlterIndexType <- aAlterIndexType
      ret.IndexIdentifier <- aIndexIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aIndexOptions do ret.IndexOptions.Add (e.ToCs())
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AlterTableStatement (* 335 *)
    | AlterTableAlterPartitionStatement(BoundaryValue=aBoundaryValue; IsSplit=aIsSplit; SchemaObjectName=aSchemaObjectName) ->
      let ret = ScriptDom.AlterTableAlterPartitionStatement()
      ret.BoundaryValue <- aBoundaryValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsSplit <- aIsSplit
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AlterTableStatement (* 335 *)
    | AlterTableChangeTrackingModificationStatement(IsEnable=aIsEnable; SchemaObjectName=aSchemaObjectName; TrackColumnsUpdated=aTrackColumnsUpdated) ->
      let ret = ScriptDom.AlterTableChangeTrackingModificationStatement()
      ret.IsEnable <- aIsEnable
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TrackColumnsUpdated <- aTrackColumnsUpdated
      ret :> ScriptDom.AlterTableStatement (* 335 *)
    | AlterTableConstraintModificationStatement(All=aAll; ConstraintEnforcement=aConstraintEnforcement; ConstraintNames=aConstraintNames; ExistingRowsCheckEnforcement=aExistingRowsCheckEnforcement; SchemaObjectName=aSchemaObjectName) ->
      let ret = ScriptDom.AlterTableConstraintModificationStatement()
      ret.All <- aAll
      ret.ConstraintEnforcement <- aConstraintEnforcement
      for e in aConstraintNames do ret.ConstraintNames.Add (e.ToCs())
      ret.ExistingRowsCheckEnforcement <- aExistingRowsCheckEnforcement
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AlterTableStatement (* 335 *)
    | AlterTableDropTableElementStatement(AlterTableDropTableElements=aAlterTableDropTableElements; SchemaObjectName=aSchemaObjectName) ->
      let ret = ScriptDom.AlterTableDropTableElementStatement()
      for e in aAlterTableDropTableElements do ret.AlterTableDropTableElements.Add (e.ToCs())
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AlterTableStatement (* 335 *)
    | AlterTableFileTableNamespaceStatement(IsEnable=aIsEnable; SchemaObjectName=aSchemaObjectName) ->
      let ret = ScriptDom.AlterTableFileTableNamespaceStatement()
      ret.IsEnable <- aIsEnable
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AlterTableStatement (* 335 *)
    | AlterTableRebuildStatement(IndexOptions=aIndexOptions; Partition=aPartition; SchemaObjectName=aSchemaObjectName) ->
      let ret = ScriptDom.AlterTableRebuildStatement()
      for e in aIndexOptions do ret.IndexOptions.Add (e.ToCs())
      ret.Partition <- aPartition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AlterTableStatement (* 335 *)
    | AlterTableSetStatement(Options=aOptions; SchemaObjectName=aSchemaObjectName) ->
      let ret = ScriptDom.AlterTableSetStatement()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AlterTableStatement (* 335 *)
    | AlterTableSwitchStatement(Options=aOptions; SchemaObjectName=aSchemaObjectName; SourcePartitionNumber=aSourcePartitionNumber; TargetPartitionNumber=aTargetPartitionNumber; TargetTable=aTargetTable) ->
      let ret = ScriptDom.AlterTableSwitchStatement()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SourcePartitionNumber <- aSourcePartitionNumber |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TargetPartitionNumber <- aTargetPartitionNumber |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TargetTable <- aTargetTable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AlterTableStatement (* 335 *)
    | AlterTableTriggerModificationStatement(All=aAll; SchemaObjectName=aSchemaObjectName; TriggerEnforcement=aTriggerEnforcement; TriggerNames=aTriggerNames) ->
      let ret = ScriptDom.AlterTableTriggerModificationStatement()
      ret.All <- aAll
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TriggerEnforcement <- aTriggerEnforcement
      for e in aTriggerNames do ret.TriggerNames.Add (e.ToCs())
      ret :> ScriptDom.AlterTableStatement (* 335 *)
  static member FromCs(src:ScriptDom.AlterTableStatement, fragmentMapping:FragmentMapping) : AlterTableStatement =
    let ret =
      match src with
      | :? ScriptDom.AlterTableAddTableElementStatement as src ->
        AlterTableStatement.AlterTableAddTableElementStatement((src.Definition |> Option.ofObj |> Option.map (fun x -> TableDefinition.FromCs(x, fragmentMapping))),(src.ExistingRowsCheckEnforcement),(src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.AlterTableAlterColumnStatement as src ->
        AlterTableStatement.AlterTableAlterColumnStatement((src.AlterTableAlterColumnOption),(src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.ColumnIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))),(src.Encryption |> Option.ofObj |> Option.map (fun x -> ColumnEncryptionDefinition.FromCs(x, fragmentMapping))),(Option.ofNullable (src.GeneratedAlways)),(src.IsHidden),(src.IsMasked),(src.MaskingFunction |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))),(src.Options |> Seq.map (fun x -> IndexOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.StorageOptions |> Option.ofObj |> Option.map (fun x -> ColumnStorageOptions.FromCs(x, fragmentMapping))))
      | :? ScriptDom.AlterTableAlterIndexStatement as src ->
        AlterTableStatement.AlterTableAlterIndexStatement((src.AlterIndexType),(src.IndexIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.IndexOptions |> Seq.map (fun x -> IndexOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.AlterTableAlterPartitionStatement as src ->
        AlterTableStatement.AlterTableAlterPartitionStatement((src.BoundaryValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.IsSplit),(src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.AlterTableChangeTrackingModificationStatement as src ->
        AlterTableStatement.AlterTableChangeTrackingModificationStatement((src.IsEnable),(src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.TrackColumnsUpdated))
      | :? ScriptDom.AlterTableConstraintModificationStatement as src ->
        AlterTableStatement.AlterTableConstraintModificationStatement((src.All),(src.ConstraintEnforcement),(src.ConstraintNames |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.ExistingRowsCheckEnforcement),(src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.AlterTableDropTableElementStatement as src ->
        AlterTableStatement.AlterTableDropTableElementStatement((src.AlterTableDropTableElements |> Seq.map (fun src -> AlterTableDropTableElement.AlterTableDropTableElement((src.DropClusteredConstraintOptions |> Seq.map (fun x -> DropClusteredConstraintOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.TableElementType))) |> List.ofSeq),(src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.AlterTableFileTableNamespaceStatement as src ->
        AlterTableStatement.AlterTableFileTableNamespaceStatement((src.IsEnable),(src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.AlterTableRebuildStatement as src ->
        AlterTableStatement.AlterTableRebuildStatement((src.IndexOptions |> Seq.map (fun x -> IndexOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Partition |> Option.ofObj |> Option.map (fun x -> PartitionSpecifier.FromCs(x, fragmentMapping))),(src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.AlterTableSetStatement as src ->
        AlterTableStatement.AlterTableSetStatement((src.Options |> Seq.map (fun x -> TableOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.AlterTableSwitchStatement as src ->
        AlterTableStatement.AlterTableSwitchStatement((src.Options |> Seq.map (fun x -> TableSwitchOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.SourcePartitionNumber |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.TargetPartitionNumber |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.TargetTable |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.AlterTableTriggerModificationStatement as src ->
        AlterTableStatement.AlterTableTriggerModificationStatement((src.All),(src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.TriggerEnforcement),(src.TriggerNames |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ApplicationRoleStatement = (* IsAbstract = true *)
  | AlterApplicationRoleStatement of ApplicationRoleOptions:(ApplicationRoleOption) list * Name:Identifier option
  | CreateApplicationRoleStatement of ApplicationRoleOptions:(ApplicationRoleOption) list * Name:Identifier option
  member this.ToCs() : ScriptDom.ApplicationRoleStatement =
    match this with
    | AlterApplicationRoleStatement(ApplicationRoleOptions=aApplicationRoleOptions; Name=aName) ->
      let ret = ScriptDom.AlterApplicationRoleStatement()
      for e in aApplicationRoleOptions do ret.ApplicationRoleOptions.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ApplicationRoleStatement (* 335 *)
    | CreateApplicationRoleStatement(ApplicationRoleOptions=aApplicationRoleOptions; Name=aName) ->
      let ret = ScriptDom.CreateApplicationRoleStatement()
      for e in aApplicationRoleOptions do ret.ApplicationRoleOptions.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ApplicationRoleStatement (* 335 *)
  static member FromCs(src:ScriptDom.ApplicationRoleStatement, fragmentMapping:FragmentMapping) : ApplicationRoleStatement =
    let ret =
      match src with
      | :? ScriptDom.AlterApplicationRoleStatement as src ->
        ApplicationRoleStatement.AlterApplicationRoleStatement((src.ApplicationRoleOptions |> Seq.map (fun src -> ApplicationRoleOption.ApplicationRoleOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CreateApplicationRoleStatement as src ->
        ApplicationRoleStatement.CreateApplicationRoleStatement((src.ApplicationRoleOptions |> Seq.map (fun src -> ApplicationRoleOption.ApplicationRoleOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] AssemblyStatement = (* IsAbstract = true *)
  | AlterAssemblyStatement of AddFiles:(AddFileSpec) list * DropFiles:(Literal) list * IsDropAll:bool * Name:Identifier option * Options:(AssemblyOption) list * Parameters:(ScalarExpression) list
  | CreateAssemblyStatement of Name:Identifier option * Options:(AssemblyOption) list * Owner:Identifier option * Parameters:(ScalarExpression) list
  member this.ToCs() : ScriptDom.AssemblyStatement =
    match this with
    | AlterAssemblyStatement(AddFiles=aAddFiles; DropFiles=aDropFiles; IsDropAll=aIsDropAll; Name=aName; Options=aOptions; Parameters=aParameters) ->
      let ret = ScriptDom.AlterAssemblyStatement()
      for e in aAddFiles do ret.AddFiles.Add (e.ToCs())
      for e in aDropFiles do ret.DropFiles.Add (e.ToCs())
      ret.IsDropAll <- aIsDropAll
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret :> ScriptDom.AssemblyStatement (* 335 *)
    | CreateAssemblyStatement(Name=aName; Options=aOptions; Owner=aOwner; Parameters=aParameters) ->
      let ret = ScriptDom.CreateAssemblyStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.Owner <- aOwner |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret :> ScriptDom.AssemblyStatement (* 335 *)
  static member FromCs(src:ScriptDom.AssemblyStatement, fragmentMapping:FragmentMapping) : AssemblyStatement =
    let ret =
      match src with
      | :? ScriptDom.AlterAssemblyStatement as src ->
        AssemblyStatement.AlterAssemblyStatement((src.AddFiles |> Seq.map (fun src -> AddFileSpec.AddFileSpec((src.File |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.FileName |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.DropFiles |> Seq.map (fun x -> Literal.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.IsDropAll),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Options |> Seq.map (fun x -> AssemblyOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Parameters |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.CreateAssemblyStatement as src ->
        AssemblyStatement.CreateAssemblyStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Options |> Seq.map (fun x -> AssemblyOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Owner |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Parameters |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] AuditSpecificationStatement = (* IsAbstract = true *)
  | AlterDatabaseAuditSpecificationStatement of AuditName:Identifier option * AuditState:ScriptDom.OptionState * Parts:(AuditSpecificationPart) list * SpecificationName:Identifier option
  | AlterServerAuditSpecificationStatement of AuditName:Identifier option * AuditState:ScriptDom.OptionState * Parts:(AuditSpecificationPart) list * SpecificationName:Identifier option
  | CreateDatabaseAuditSpecificationStatement of AuditName:Identifier option * AuditState:ScriptDom.OptionState * Parts:(AuditSpecificationPart) list * SpecificationName:Identifier option
  | CreateServerAuditSpecificationStatement of AuditName:Identifier option * AuditState:ScriptDom.OptionState * Parts:(AuditSpecificationPart) list * SpecificationName:Identifier option
  member this.ToCs() : ScriptDom.AuditSpecificationStatement =
    match this with
    | AlterDatabaseAuditSpecificationStatement(AuditName=aAuditName; AuditState=aAuditState; Parts=aParts; SpecificationName=aSpecificationName) ->
      let ret = ScriptDom.AlterDatabaseAuditSpecificationStatement()
      ret.AuditName <- aAuditName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.AuditState <- aAuditState
      for e in aParts do ret.Parts.Add (e.ToCs())
      ret.SpecificationName <- aSpecificationName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AuditSpecificationStatement (* 335 *)
    | AlterServerAuditSpecificationStatement(AuditName=aAuditName; AuditState=aAuditState; Parts=aParts; SpecificationName=aSpecificationName) ->
      let ret = ScriptDom.AlterServerAuditSpecificationStatement()
      ret.AuditName <- aAuditName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.AuditState <- aAuditState
      for e in aParts do ret.Parts.Add (e.ToCs())
      ret.SpecificationName <- aSpecificationName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AuditSpecificationStatement (* 335 *)
    | CreateDatabaseAuditSpecificationStatement(AuditName=aAuditName; AuditState=aAuditState; Parts=aParts; SpecificationName=aSpecificationName) ->
      let ret = ScriptDom.CreateDatabaseAuditSpecificationStatement()
      ret.AuditName <- aAuditName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.AuditState <- aAuditState
      for e in aParts do ret.Parts.Add (e.ToCs())
      ret.SpecificationName <- aSpecificationName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AuditSpecificationStatement (* 335 *)
    | CreateServerAuditSpecificationStatement(AuditName=aAuditName; AuditState=aAuditState; Parts=aParts; SpecificationName=aSpecificationName) ->
      let ret = ScriptDom.CreateServerAuditSpecificationStatement()
      ret.AuditName <- aAuditName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.AuditState <- aAuditState
      for e in aParts do ret.Parts.Add (e.ToCs())
      ret.SpecificationName <- aSpecificationName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AuditSpecificationStatement (* 335 *)
  static member FromCs(src:ScriptDom.AuditSpecificationStatement, fragmentMapping:FragmentMapping) : AuditSpecificationStatement =
    let ret =
      match src with
      | :? ScriptDom.AlterDatabaseAuditSpecificationStatement as src ->
        AuditSpecificationStatement.AlterDatabaseAuditSpecificationStatement((src.AuditName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.AuditState),(src.Parts |> Seq.map (fun src -> AuditSpecificationPart.AuditSpecificationPart((src.Details |> Option.ofObj |> Option.map (fun x -> AuditSpecificationDetail.FromCs(x, fragmentMapping))), (src.IsDrop))) |> List.ofSeq),(src.SpecificationName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.AlterServerAuditSpecificationStatement as src ->
        AuditSpecificationStatement.AlterServerAuditSpecificationStatement((src.AuditName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.AuditState),(src.Parts |> Seq.map (fun src -> AuditSpecificationPart.AuditSpecificationPart((src.Details |> Option.ofObj |> Option.map (fun x -> AuditSpecificationDetail.FromCs(x, fragmentMapping))), (src.IsDrop))) |> List.ofSeq),(src.SpecificationName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CreateDatabaseAuditSpecificationStatement as src ->
        AuditSpecificationStatement.CreateDatabaseAuditSpecificationStatement((src.AuditName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.AuditState),(src.Parts |> Seq.map (fun src -> AuditSpecificationPart.AuditSpecificationPart((src.Details |> Option.ofObj |> Option.map (fun x -> AuditSpecificationDetail.FromCs(x, fragmentMapping))), (src.IsDrop))) |> List.ofSeq),(src.SpecificationName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CreateServerAuditSpecificationStatement as src ->
        AuditSpecificationStatement.CreateServerAuditSpecificationStatement((src.AuditName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.AuditState),(src.Parts |> Seq.map (fun src -> AuditSpecificationPart.AuditSpecificationPart((src.Details |> Option.ofObj |> Option.map (fun x -> AuditSpecificationDetail.FromCs(x, fragmentMapping))), (src.IsDrop))) |> List.ofSeq),(src.SpecificationName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] AvailabilityGroupStatement = (* IsAbstract = true *)
  | AlterAvailabilityGroupStatement of Action:AlterAvailabilityGroupAction option * AlterAvailabilityGroupStatementType:ScriptDom.AlterAvailabilityGroupStatementType * Databases:(Identifier) list * Name:Identifier option * Options:(AvailabilityGroupOption) list * Replicas:(AvailabilityReplica) list
  | CreateAvailabilityGroupStatement of Databases:(Identifier) list * Name:Identifier option * Options:(AvailabilityGroupOption) list * Replicas:(AvailabilityReplica) list
  member this.ToCs() : ScriptDom.AvailabilityGroupStatement =
    match this with
    | AlterAvailabilityGroupStatement(Action=aAction; AlterAvailabilityGroupStatementType=aAlterAvailabilityGroupStatementType; Databases=aDatabases; Name=aName; Options=aOptions; Replicas=aReplicas) ->
      let ret = ScriptDom.AlterAvailabilityGroupStatement()
      ret.Action <- aAction |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.AlterAvailabilityGroupStatementType <- aAlterAvailabilityGroupStatementType
      for e in aDatabases do ret.Databases.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      for e in aReplicas do ret.Replicas.Add (e.ToCs())
      ret :> ScriptDom.AvailabilityGroupStatement (* 335 *)
    | CreateAvailabilityGroupStatement(Databases=aDatabases; Name=aName; Options=aOptions; Replicas=aReplicas) ->
      let ret = ScriptDom.CreateAvailabilityGroupStatement()
      for e in aDatabases do ret.Databases.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      for e in aReplicas do ret.Replicas.Add (e.ToCs())
      ret :> ScriptDom.AvailabilityGroupStatement (* 335 *)
  static member FromCs(src:ScriptDom.AvailabilityGroupStatement, fragmentMapping:FragmentMapping) : AvailabilityGroupStatement =
    let ret =
      match src with
      | :? ScriptDom.AlterAvailabilityGroupStatement as src ->
        AvailabilityGroupStatement.AlterAvailabilityGroupStatement((src.Action |> Option.ofObj |> Option.map (fun x -> AlterAvailabilityGroupAction.FromCs(x, fragmentMapping))),(src.AlterAvailabilityGroupStatementType),(src.Databases |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Options |> Seq.map (fun x -> AvailabilityGroupOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Replicas |> Seq.map (fun src -> AvailabilityReplica.AvailabilityReplica((src.Options |> Seq.map (fun x -> AvailabilityReplicaOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.ServerName |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))))) |> List.ofSeq))
      | :? ScriptDom.CreateAvailabilityGroupStatement as src ->
        AvailabilityGroupStatement.CreateAvailabilityGroupStatement((src.Databases |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Options |> Seq.map (fun x -> AvailabilityGroupOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Replicas |> Seq.map (fun src -> AvailabilityReplica.AvailabilityReplica((src.Options |> Seq.map (fun x -> AvailabilityReplicaOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.ServerName |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))))) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] BackupRestoreMasterKeyStatementBase = (* IsAbstract = true *)
  | BackupMasterKeyStatement of File:Literal option * Password:Literal option
  | BackupServiceMasterKeyStatement of File:Literal option * Password:Literal option
  | RestoreMasterKeyStatement of EncryptionPassword:Literal option * File:Literal option * IsForce:bool * Password:Literal option
  | RestoreServiceMasterKeyStatement of File:Literal option * IsForce:bool * Password:Literal option
  member this.ToCs() : ScriptDom.BackupRestoreMasterKeyStatementBase =
    match this with
    | BackupMasterKeyStatement(File=aFile; Password=aPassword) ->
      let ret = ScriptDom.BackupMasterKeyStatement()
      ret.File <- aFile |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Password <- aPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BackupRestoreMasterKeyStatementBase (* 335 *)
    | BackupServiceMasterKeyStatement(File=aFile; Password=aPassword) ->
      let ret = ScriptDom.BackupServiceMasterKeyStatement()
      ret.File <- aFile |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Password <- aPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BackupRestoreMasterKeyStatementBase (* 335 *)
    | RestoreMasterKeyStatement(EncryptionPassword=aEncryptionPassword; File=aFile; IsForce=aIsForce; Password=aPassword) ->
      let ret = ScriptDom.RestoreMasterKeyStatement()
      ret.EncryptionPassword <- aEncryptionPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.File <- aFile |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsForce <- aIsForce
      ret.Password <- aPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BackupRestoreMasterKeyStatementBase (* 335 *)
    | RestoreServiceMasterKeyStatement(File=aFile; IsForce=aIsForce; Password=aPassword) ->
      let ret = ScriptDom.RestoreServiceMasterKeyStatement()
      ret.File <- aFile |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsForce <- aIsForce
      ret.Password <- aPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BackupRestoreMasterKeyStatementBase (* 335 *)
  static member FromCs(src:ScriptDom.BackupRestoreMasterKeyStatementBase, fragmentMapping:FragmentMapping) : BackupRestoreMasterKeyStatementBase =
    let ret =
      match src with
      | :? ScriptDom.BackupMasterKeyStatement as src ->
        BackupRestoreMasterKeyStatementBase.BackupMasterKeyStatement((src.File |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.Password |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.BackupServiceMasterKeyStatement as src ->
        BackupRestoreMasterKeyStatementBase.BackupServiceMasterKeyStatement((src.File |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.Password |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.RestoreMasterKeyStatement as src ->
        BackupRestoreMasterKeyStatementBase.RestoreMasterKeyStatement((src.EncryptionPassword |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.File |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.IsForce),(src.Password |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.RestoreServiceMasterKeyStatement as src ->
        BackupRestoreMasterKeyStatementBase.RestoreServiceMasterKeyStatement((src.File |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.IsForce),(src.Password |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] BackupStatement = (* IsAbstract = true *)
  | BackupDatabaseStatement of DatabaseName:IdentifierOrValueExpression option * Devices:(DeviceInfo) list * Files:(BackupRestoreFileInfo) list * MirrorToClauses:(MirrorToClause) list * Options:(BackupOption) list
  | BackupTransactionLogStatement of DatabaseName:IdentifierOrValueExpression option * Devices:(DeviceInfo) list * MirrorToClauses:(MirrorToClause) list * Options:(BackupOption) list
  member this.ToCs() : ScriptDom.BackupStatement =
    match this with
    | BackupDatabaseStatement(DatabaseName=aDatabaseName; Devices=aDevices; Files=aFiles; MirrorToClauses=aMirrorToClauses; Options=aOptions) ->
      let ret = ScriptDom.BackupDatabaseStatement()
      ret.DatabaseName <- aDatabaseName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aDevices do ret.Devices.Add (e.ToCs())
      for e in aFiles do ret.Files.Add (e.ToCs())
      for e in aMirrorToClauses do ret.MirrorToClauses.Add (e.ToCs())
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.BackupStatement (* 335 *)
    | BackupTransactionLogStatement(DatabaseName=aDatabaseName; Devices=aDevices; MirrorToClauses=aMirrorToClauses; Options=aOptions) ->
      let ret = ScriptDom.BackupTransactionLogStatement()
      ret.DatabaseName <- aDatabaseName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aDevices do ret.Devices.Add (e.ToCs())
      for e in aMirrorToClauses do ret.MirrorToClauses.Add (e.ToCs())
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.BackupStatement (* 335 *)
  static member FromCs(src:ScriptDom.BackupStatement, fragmentMapping:FragmentMapping) : BackupStatement =
    let ret =
      match src with
      | :? ScriptDom.BackupDatabaseStatement as src ->
        BackupStatement.BackupDatabaseStatement((src.DatabaseName |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))),(src.Devices |> Seq.map (fun src -> DeviceInfo.DeviceInfo((src.DeviceType), (src.LogicalDevice |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.PhysicalDevice |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.Files |> Seq.map (fun src -> BackupRestoreFileInfo.BackupRestoreFileInfo((src.ItemKind), (src.Items |> Seq.map (fun x -> ValueExpression.FromCs(x, fragmentMapping)) |> List.ofSeq))) |> List.ofSeq),(src.MirrorToClauses |> Seq.map (fun src -> MirrorToClause.MirrorToClause((src.Devices |> Seq.map (fun src -> DeviceInfo.DeviceInfo((src.DeviceType), (src.LogicalDevice |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.PhysicalDevice |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq))) |> List.ofSeq),(src.Options |> Seq.map (fun x -> BackupOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.BackupTransactionLogStatement as src ->
        BackupStatement.BackupTransactionLogStatement((src.DatabaseName |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))),(src.Devices |> Seq.map (fun src -> DeviceInfo.DeviceInfo((src.DeviceType), (src.LogicalDevice |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.PhysicalDevice |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.MirrorToClauses |> Seq.map (fun src -> MirrorToClause.MirrorToClause((src.Devices |> Seq.map (fun src -> DeviceInfo.DeviceInfo((src.DeviceType), (src.LogicalDevice |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.PhysicalDevice |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq))) |> List.ofSeq),(src.Options |> Seq.map (fun x -> BackupOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] BeginEndBlockStatement = (* IsAbstract = false *)
  | Base of StatementList:StatementList option
  | BeginEndAtomicBlockStatement of Options:(AtomicBlockOption) list * StatementList:StatementList option
  member this.ToCs() : ScriptDom.BeginEndBlockStatement =
    match this with
    | BeginEndAtomicBlockStatement(Options=aOptions; StatementList=aStatementList) ->
      let ret = ScriptDom.BeginEndAtomicBlockStatement()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.StatementList <- aStatementList |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BeginEndBlockStatement (* 335 *)
    | Base(StatementList=aStatementList) ->

      let ret = ScriptDom.BeginEndBlockStatement()
      ret.StatementList <- aStatementList |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret
  static member FromCs(src:ScriptDom.BeginEndBlockStatement, fragmentMapping:FragmentMapping) : BeginEndBlockStatement =
    let ret =
      match src with
      | :? ScriptDom.BeginEndAtomicBlockStatement as src ->
        BeginEndBlockStatement.BeginEndAtomicBlockStatement((src.Options |> Seq.map (fun x -> AtomicBlockOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.StatementList |> Option.ofObj |> Option.map (fun x -> StatementList.FromCs(x, fragmentMapping))))
      | _ -> (* :? ScriptDom.BeginEndBlockStatement as src *)
        BeginEndBlockStatement.Base(((src.StatementList |> Option.ofObj |> Option.map (fun x -> StatementList.FromCs(x, fragmentMapping))))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] BrokerPriorityStatement = (* IsAbstract = true *)
  | AlterBrokerPriorityStatement of BrokerPriorityParameters:(BrokerPriorityParameter) list * Name:Identifier option
  | CreateBrokerPriorityStatement of BrokerPriorityParameters:(BrokerPriorityParameter) list * Name:Identifier option
  member this.ToCs() : ScriptDom.BrokerPriorityStatement =
    match this with
    | AlterBrokerPriorityStatement(BrokerPriorityParameters=aBrokerPriorityParameters; Name=aName) ->
      let ret = ScriptDom.AlterBrokerPriorityStatement()
      for e in aBrokerPriorityParameters do ret.BrokerPriorityParameters.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BrokerPriorityStatement (* 335 *)
    | CreateBrokerPriorityStatement(BrokerPriorityParameters=aBrokerPriorityParameters; Name=aName) ->
      let ret = ScriptDom.CreateBrokerPriorityStatement()
      for e in aBrokerPriorityParameters do ret.BrokerPriorityParameters.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BrokerPriorityStatement (* 335 *)
  static member FromCs(src:ScriptDom.BrokerPriorityStatement, fragmentMapping:FragmentMapping) : BrokerPriorityStatement =
    let ret =
      match src with
      | :? ScriptDom.AlterBrokerPriorityStatement as src ->
        BrokerPriorityStatement.AlterBrokerPriorityStatement((src.BrokerPriorityParameters |> Seq.map (fun src -> BrokerPriorityParameter.BrokerPriorityParameter((src.IsDefaultOrAny), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CreateBrokerPriorityStatement as src ->
        BrokerPriorityStatement.CreateBrokerPriorityStatement((src.BrokerPriorityParameters |> Seq.map (fun src -> BrokerPriorityParameter.BrokerPriorityParameter((src.IsDefaultOrAny), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] BulkInsertBase = (* IsAbstract = true *)
  | BulkInsertStatement of From:IdentifierOrValueExpression option * Options:(BulkInsertOption) list * To:SchemaObjectName option
  | InsertBulkStatement of ColumnDefinitions:(InsertBulkColumnDefinition) list * Options:(BulkInsertOption) list * To:SchemaObjectName option
  member this.ToCs() : ScriptDom.BulkInsertBase =
    match this with
    | BulkInsertStatement(From=aFrom; Options=aOptions; To=aTo) ->
      let ret = ScriptDom.BulkInsertStatement()
      ret.From <- aFrom |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.To <- aTo |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BulkInsertBase (* 335 *)
    | InsertBulkStatement(ColumnDefinitions=aColumnDefinitions; Options=aOptions; To=aTo) ->
      let ret = ScriptDom.InsertBulkStatement()
      for e in aColumnDefinitions do ret.ColumnDefinitions.Add (e.ToCs())
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.To <- aTo |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BulkInsertBase (* 335 *)
  static member FromCs(src:ScriptDom.BulkInsertBase, fragmentMapping:FragmentMapping) : BulkInsertBase =
    let ret =
      match src with
      | :? ScriptDom.BulkInsertStatement as src ->
        BulkInsertBase.BulkInsertStatement((src.From |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))),(src.Options |> Seq.map (fun x -> BulkInsertOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.To |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.InsertBulkStatement as src ->
        BulkInsertBase.InsertBulkStatement((src.ColumnDefinitions |> Seq.map (fun src -> InsertBulkColumnDefinition.InsertBulkColumnDefinition((src.Column |> Option.ofObj |> Option.map (fun x -> ColumnDefinitionBase.FromCs(x, fragmentMapping))), (src.NullNotNull))) |> List.ofSeq),(src.Options |> Seq.map (fun x -> BulkInsertOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.To |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] CertificateStatementBase = (* IsAbstract = true *)
  | AlterCertificateStatement of ActiveForBeginDialog:ScriptDom.OptionState * AttestedBy:Literal option * DecryptionPassword:Literal option * EncryptionPassword:Literal option * Kind:ScriptDom.AlterCertificateStatementKind * Name:Identifier option * PrivateKeyPath:Literal option
  | BackupCertificateStatement of ActiveForBeginDialog:ScriptDom.OptionState * DecryptionPassword:Literal option * EncryptionPassword:Literal option * File:Literal option * Name:Identifier option * PrivateKeyPath:Literal option
  | CreateCertificateStatement of ActiveForBeginDialog:ScriptDom.OptionState * CertificateOptions:(CertificateOption) list * CertificateSource:EncryptionSource option * DecryptionPassword:Literal option * EncryptionPassword:Literal option * Name:Identifier option * Owner:Identifier option * PrivateKeyPath:Literal option
  member this.ToCs() : ScriptDom.CertificateStatementBase =
    match this with
    | AlterCertificateStatement(ActiveForBeginDialog=aActiveForBeginDialog; AttestedBy=aAttestedBy; DecryptionPassword=aDecryptionPassword; EncryptionPassword=aEncryptionPassword; Kind=aKind; Name=aName; PrivateKeyPath=aPrivateKeyPath) ->
      let ret = ScriptDom.AlterCertificateStatement()
      ret.ActiveForBeginDialog <- aActiveForBeginDialog
      ret.AttestedBy <- aAttestedBy |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DecryptionPassword <- aDecryptionPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.EncryptionPassword <- aEncryptionPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Kind <- aKind
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PrivateKeyPath <- aPrivateKeyPath |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CertificateStatementBase (* 335 *)
    | BackupCertificateStatement(ActiveForBeginDialog=aActiveForBeginDialog; DecryptionPassword=aDecryptionPassword; EncryptionPassword=aEncryptionPassword; File=aFile; Name=aName; PrivateKeyPath=aPrivateKeyPath) ->
      let ret = ScriptDom.BackupCertificateStatement()
      ret.ActiveForBeginDialog <- aActiveForBeginDialog
      ret.DecryptionPassword <- aDecryptionPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.EncryptionPassword <- aEncryptionPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.File <- aFile |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PrivateKeyPath <- aPrivateKeyPath |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CertificateStatementBase (* 335 *)
    | CreateCertificateStatement(ActiveForBeginDialog=aActiveForBeginDialog; CertificateOptions=aCertificateOptions; CertificateSource=aCertificateSource; DecryptionPassword=aDecryptionPassword; EncryptionPassword=aEncryptionPassword; Name=aName; Owner=aOwner; PrivateKeyPath=aPrivateKeyPath) ->
      let ret = ScriptDom.CreateCertificateStatement()
      ret.ActiveForBeginDialog <- aActiveForBeginDialog
      for e in aCertificateOptions do ret.CertificateOptions.Add (e.ToCs())
      ret.CertificateSource <- aCertificateSource |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DecryptionPassword <- aDecryptionPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.EncryptionPassword <- aEncryptionPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Owner <- aOwner |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PrivateKeyPath <- aPrivateKeyPath |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CertificateStatementBase (* 335 *)
  static member FromCs(src:ScriptDom.CertificateStatementBase, fragmentMapping:FragmentMapping) : CertificateStatementBase =
    let ret =
      match src with
      | :? ScriptDom.AlterCertificateStatement as src ->
        CertificateStatementBase.AlterCertificateStatement((src.ActiveForBeginDialog),(src.AttestedBy |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.DecryptionPassword |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.EncryptionPassword |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.Kind),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.PrivateKeyPath |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.BackupCertificateStatement as src ->
        CertificateStatementBase.BackupCertificateStatement((src.ActiveForBeginDialog),(src.DecryptionPassword |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.EncryptionPassword |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.File |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.PrivateKeyPath |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CreateCertificateStatement as src ->
        CertificateStatementBase.CreateCertificateStatement((src.ActiveForBeginDialog),(src.CertificateOptions |> Seq.map (fun src -> CertificateOption.CertificateOption((src.Kind), (src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.CertificateSource |> Option.ofObj |> Option.map (fun x -> EncryptionSource.FromCs(x, fragmentMapping))),(src.DecryptionPassword |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.EncryptionPassword |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Owner |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.PrivateKeyPath |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ColumnEncryptionKeyStatement = (* IsAbstract = true *)
  | AlterColumnEncryptionKeyStatement of AlterType:ScriptDom.ColumnEncryptionKeyAlterType * ColumnEncryptionKeyValues:(ColumnEncryptionKeyValue) list * Name:Identifier option
  | CreateColumnEncryptionKeyStatement of ColumnEncryptionKeyValues:(ColumnEncryptionKeyValue) list * Name:Identifier option
  member this.ToCs() : ScriptDom.ColumnEncryptionKeyStatement =
    match this with
    | AlterColumnEncryptionKeyStatement(AlterType=aAlterType; ColumnEncryptionKeyValues=aColumnEncryptionKeyValues; Name=aName) ->
      let ret = ScriptDom.AlterColumnEncryptionKeyStatement()
      ret.AlterType <- aAlterType
      for e in aColumnEncryptionKeyValues do ret.ColumnEncryptionKeyValues.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ColumnEncryptionKeyStatement (* 335 *)
    | CreateColumnEncryptionKeyStatement(ColumnEncryptionKeyValues=aColumnEncryptionKeyValues; Name=aName) ->
      let ret = ScriptDom.CreateColumnEncryptionKeyStatement()
      for e in aColumnEncryptionKeyValues do ret.ColumnEncryptionKeyValues.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ColumnEncryptionKeyStatement (* 335 *)
  static member FromCs(src:ScriptDom.ColumnEncryptionKeyStatement, fragmentMapping:FragmentMapping) : ColumnEncryptionKeyStatement =
    let ret =
      match src with
      | :? ScriptDom.AlterColumnEncryptionKeyStatement as src ->
        ColumnEncryptionKeyStatement.AlterColumnEncryptionKeyStatement((src.AlterType),(src.ColumnEncryptionKeyValues |> Seq.map (fun src -> ColumnEncryptionKeyValue.ColumnEncryptionKeyValue((src.Parameters |> Seq.map (fun x -> ColumnEncryptionKeyValueParameter.FromCs(x, fragmentMapping)) |> List.ofSeq))) |> List.ofSeq),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CreateColumnEncryptionKeyStatement as src ->
        ColumnEncryptionKeyStatement.CreateColumnEncryptionKeyStatement((src.ColumnEncryptionKeyValues |> Seq.map (fun src -> ColumnEncryptionKeyValue.ColumnEncryptionKeyValue((src.Parameters |> Seq.map (fun x -> ColumnEncryptionKeyValueParameter.FromCs(x, fragmentMapping)) |> List.ofSeq))) |> List.ofSeq),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] CreateTypeStatement = (* IsAbstract = true *)
  | CreateTypeTableStatement of Definition:TableDefinition option * Name:SchemaObjectName option * Options:(TableOption) list
  | CreateTypeUddtStatement of DataType:DataTypeReference option * Name:SchemaObjectName option * NullableConstraint:NullableConstraintDefinition option
  | CreateTypeUdtStatement of AssemblyName:AssemblyName option * Name:SchemaObjectName option
  member this.ToCs() : ScriptDom.CreateTypeStatement =
    match this with
    | CreateTypeTableStatement(Definition=aDefinition; Name=aName; Options=aOptions) ->
      let ret = ScriptDom.CreateTypeTableStatement()
      ret.Definition <- aDefinition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.CreateTypeStatement (* 335 *)
    | CreateTypeUddtStatement(DataType=aDataType; Name=aName; NullableConstraint=aNullableConstraint) ->
      let ret = ScriptDom.CreateTypeUddtStatement()
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.NullableConstraint <- aNullableConstraint |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CreateTypeStatement (* 335 *)
    | CreateTypeUdtStatement(AssemblyName=aAssemblyName; Name=aName) ->
      let ret = ScriptDom.CreateTypeUdtStatement()
      ret.AssemblyName <- aAssemblyName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CreateTypeStatement (* 335 *)
  static member FromCs(src:ScriptDom.CreateTypeStatement, fragmentMapping:FragmentMapping) : CreateTypeStatement =
    let ret =
      match src with
      | :? ScriptDom.CreateTypeTableStatement as src ->
        CreateTypeStatement.CreateTypeTableStatement((src.Definition |> Option.ofObj |> Option.map (fun x -> TableDefinition.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.Options |> Seq.map (fun x -> TableOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.CreateTypeUddtStatement as src ->
        CreateTypeStatement.CreateTypeUddtStatement((src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.NullableConstraint |> Option.ofObj |> Option.map (fun x -> NullableConstraintDefinition.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CreateTypeUdtStatement as src ->
        CreateTypeStatement.CreateTypeUdtStatement((src.AssemblyName |> Option.ofObj |> Option.map (fun x -> AssemblyName.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] CredentialStatement = (* IsAbstract = true *)
  | AlterCredentialStatement of Identity:Literal option * IsDatabaseScoped:bool * Name:Identifier option * Secret:Literal option
  | CreateCredentialStatement of CryptographicProviderName:Identifier option * Identity:Literal option * IsDatabaseScoped:bool * Name:Identifier option * Secret:Literal option
  member this.ToCs() : ScriptDom.CredentialStatement =
    match this with
    | AlterCredentialStatement(Identity=aIdentity; IsDatabaseScoped=aIsDatabaseScoped; Name=aName; Secret=aSecret) ->
      let ret = ScriptDom.AlterCredentialStatement()
      ret.Identity <- aIdentity |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsDatabaseScoped <- aIsDatabaseScoped
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Secret <- aSecret |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CredentialStatement (* 335 *)
    | CreateCredentialStatement(CryptographicProviderName=aCryptographicProviderName; Identity=aIdentity; IsDatabaseScoped=aIsDatabaseScoped; Name=aName; Secret=aSecret) ->
      let ret = ScriptDom.CreateCredentialStatement()
      ret.CryptographicProviderName <- aCryptographicProviderName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Identity <- aIdentity |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsDatabaseScoped <- aIsDatabaseScoped
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Secret <- aSecret |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CredentialStatement (* 335 *)
  static member FromCs(src:ScriptDom.CredentialStatement, fragmentMapping:FragmentMapping) : CredentialStatement =
    let ret =
      match src with
      | :? ScriptDom.AlterCredentialStatement as src ->
        CredentialStatement.AlterCredentialStatement((src.Identity |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.IsDatabaseScoped),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Secret |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CreateCredentialStatement as src ->
        CredentialStatement.CreateCredentialStatement((src.CryptographicProviderName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Identity |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.IsDatabaseScoped),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Secret |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] CursorStatement = (* IsAbstract = true *)
  | CloseCursorStatement of Cursor:CursorId option
  | DeallocateCursorStatement of Cursor:CursorId option
  | FetchCursorStatement of Cursor:CursorId option * FetchType:FetchType option * IntoVariables:(VariableReference) list
  | OpenCursorStatement of Cursor:CursorId option
  member this.ToCs() : ScriptDom.CursorStatement =
    match this with
    | CloseCursorStatement(Cursor=aCursor) ->
      let ret = ScriptDom.CloseCursorStatement()
      ret.Cursor <- aCursor |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CursorStatement (* 335 *)
    | DeallocateCursorStatement(Cursor=aCursor) ->
      let ret = ScriptDom.DeallocateCursorStatement()
      ret.Cursor <- aCursor |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CursorStatement (* 335 *)
    | FetchCursorStatement(Cursor=aCursor; FetchType=aFetchType; IntoVariables=aIntoVariables) ->
      let ret = ScriptDom.FetchCursorStatement()
      ret.Cursor <- aCursor |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FetchType <- aFetchType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aIntoVariables do ret.IntoVariables.Add (e.ToCs())
      ret :> ScriptDom.CursorStatement (* 335 *)
    | OpenCursorStatement(Cursor=aCursor) ->
      let ret = ScriptDom.OpenCursorStatement()
      ret.Cursor <- aCursor |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CursorStatement (* 335 *)
  static member FromCs(src:ScriptDom.CursorStatement, fragmentMapping:FragmentMapping) : CursorStatement =
    let ret =
      match src with
      | :? ScriptDom.CloseCursorStatement as src ->
        CursorStatement.CloseCursorStatement((src.Cursor |> Option.ofObj |> Option.map (fun x -> CursorId.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DeallocateCursorStatement as src ->
        CursorStatement.DeallocateCursorStatement((src.Cursor |> Option.ofObj |> Option.map (fun x -> CursorId.FromCs(x, fragmentMapping))))
      | :? ScriptDom.FetchCursorStatement as src ->
        CursorStatement.FetchCursorStatement((src.Cursor |> Option.ofObj |> Option.map (fun x -> CursorId.FromCs(x, fragmentMapping))),(src.FetchType |> Option.ofObj |> Option.map (fun x -> FetchType.FromCs(x, fragmentMapping))),(src.IntoVariables |> Seq.map (fun src -> VariableReference.VariableReference((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (Option.ofObj (src.Name)))) |> List.ofSeq))
      | :? ScriptDom.OpenCursorStatement as src ->
        CursorStatement.OpenCursorStatement((src.Cursor |> Option.ofObj |> Option.map (fun x -> CursorId.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] DatabaseEncryptionKeyStatement = (* IsAbstract = true *)
  | AlterDatabaseEncryptionKeyStatement of Algorithm:ScriptDom.DatabaseEncryptionKeyAlgorithm * Encryptor:CryptoMechanism option * Regenerate:bool
  | CreateDatabaseEncryptionKeyStatement of Algorithm:ScriptDom.DatabaseEncryptionKeyAlgorithm * Encryptor:CryptoMechanism option
  member this.ToCs() : ScriptDom.DatabaseEncryptionKeyStatement =
    match this with
    | AlterDatabaseEncryptionKeyStatement(Algorithm=aAlgorithm; Encryptor=aEncryptor; Regenerate=aRegenerate) ->
      let ret = ScriptDom.AlterDatabaseEncryptionKeyStatement()
      ret.Algorithm <- aAlgorithm
      ret.Encryptor <- aEncryptor |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Regenerate <- aRegenerate
      ret :> ScriptDom.DatabaseEncryptionKeyStatement (* 335 *)
    | CreateDatabaseEncryptionKeyStatement(Algorithm=aAlgorithm; Encryptor=aEncryptor) ->
      let ret = ScriptDom.CreateDatabaseEncryptionKeyStatement()
      ret.Algorithm <- aAlgorithm
      ret.Encryptor <- aEncryptor |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DatabaseEncryptionKeyStatement (* 335 *)
  static member FromCs(src:ScriptDom.DatabaseEncryptionKeyStatement, fragmentMapping:FragmentMapping) : DatabaseEncryptionKeyStatement =
    let ret =
      match src with
      | :? ScriptDom.AlterDatabaseEncryptionKeyStatement as src ->
        DatabaseEncryptionKeyStatement.AlterDatabaseEncryptionKeyStatement((src.Algorithm),(src.Encryptor |> Option.ofObj |> Option.map (fun x -> CryptoMechanism.FromCs(x, fragmentMapping))),(src.Regenerate))
      | :? ScriptDom.CreateDatabaseEncryptionKeyStatement as src ->
        DatabaseEncryptionKeyStatement.CreateDatabaseEncryptionKeyStatement((src.Algorithm),(src.Encryptor |> Option.ofObj |> Option.map (fun x -> CryptoMechanism.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] DropChildObjectsStatement = (* IsAbstract = true *)
  | DropStatisticsStatement of Objects:(ChildObjectName) list
  member this.ToCs() : ScriptDom.DropChildObjectsStatement =
    match this with
    | DropStatisticsStatement(Objects=aObjects) ->
      let ret = ScriptDom.DropStatisticsStatement()
      for e in aObjects do ret.Objects.Add (e.ToCs())
      ret :> ScriptDom.DropChildObjectsStatement (* 335 *)
  static member FromCs(src:ScriptDom.DropChildObjectsStatement, fragmentMapping:FragmentMapping) : DropChildObjectsStatement =
    let ret =
      match src with
      | :? ScriptDom.DropStatisticsStatement as src ->
        DropChildObjectsStatement.DropStatisticsStatement((src.Objects |> Seq.map (fun src -> ChildObjectName.ChildObjectName((src.BaseIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ChildIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Count), (src.DatabaseIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Identifiers |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.SchemaIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ServerIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] DropObjectsStatement = (* IsAbstract = true *)
  | DropAggregateStatement of IsIfExists:bool * Objects:(SchemaObjectName) list
  | DropAssemblyStatement of IsIfExists:bool * Objects:(SchemaObjectName) list * WithNoDependents:bool
  | DropDefaultStatement of IsIfExists:bool * Objects:(SchemaObjectName) list
  | DropExternalTableStatement of IsIfExists:bool * Objects:(SchemaObjectName) list
  | DropFunctionStatement of IsIfExists:bool * Objects:(SchemaObjectName) list
  | DropProcedureStatement of IsIfExists:bool * Objects:(SchemaObjectName) list
  | DropRuleStatement of IsIfExists:bool * Objects:(SchemaObjectName) list
  | DropSecurityPolicyStatement of IsIfExists:bool * Objects:(SchemaObjectName) list
  | DropSequenceStatement of IsIfExists:bool * Objects:(SchemaObjectName) list
  | DropSynonymStatement of IsIfExists:bool * Objects:(SchemaObjectName) list
  | DropTableStatement of IsIfExists:bool * Objects:(SchemaObjectName) list
  | DropTriggerStatement of IsIfExists:bool * Objects:(SchemaObjectName) list * TriggerScope:ScriptDom.TriggerScope
  | DropViewStatement of IsIfExists:bool * Objects:(SchemaObjectName) list
  member this.ToCs() : ScriptDom.DropObjectsStatement =
    match this with
    | DropAggregateStatement(IsIfExists=aIsIfExists; Objects=aObjects) ->
      let ret = ScriptDom.DropAggregateStatement()
      ret.IsIfExists <- aIsIfExists
      for e in aObjects do ret.Objects.Add (e.ToCs())
      ret :> ScriptDom.DropObjectsStatement (* 335 *)
    | DropAssemblyStatement(IsIfExists=aIsIfExists; Objects=aObjects; WithNoDependents=aWithNoDependents) ->
      let ret = ScriptDom.DropAssemblyStatement()
      ret.IsIfExists <- aIsIfExists
      for e in aObjects do ret.Objects.Add (e.ToCs())
      ret.WithNoDependents <- aWithNoDependents
      ret :> ScriptDom.DropObjectsStatement (* 335 *)
    | DropDefaultStatement(IsIfExists=aIsIfExists; Objects=aObjects) ->
      let ret = ScriptDom.DropDefaultStatement()
      ret.IsIfExists <- aIsIfExists
      for e in aObjects do ret.Objects.Add (e.ToCs())
      ret :> ScriptDom.DropObjectsStatement (* 335 *)
    | DropExternalTableStatement(IsIfExists=aIsIfExists; Objects=aObjects) ->
      let ret = ScriptDom.DropExternalTableStatement()
      ret.IsIfExists <- aIsIfExists
      for e in aObjects do ret.Objects.Add (e.ToCs())
      ret :> ScriptDom.DropObjectsStatement (* 335 *)
    | DropFunctionStatement(IsIfExists=aIsIfExists; Objects=aObjects) ->
      let ret = ScriptDom.DropFunctionStatement()
      ret.IsIfExists <- aIsIfExists
      for e in aObjects do ret.Objects.Add (e.ToCs())
      ret :> ScriptDom.DropObjectsStatement (* 335 *)
    | DropProcedureStatement(IsIfExists=aIsIfExists; Objects=aObjects) ->
      let ret = ScriptDom.DropProcedureStatement()
      ret.IsIfExists <- aIsIfExists
      for e in aObjects do ret.Objects.Add (e.ToCs())
      ret :> ScriptDom.DropObjectsStatement (* 335 *)
    | DropRuleStatement(IsIfExists=aIsIfExists; Objects=aObjects) ->
      let ret = ScriptDom.DropRuleStatement()
      ret.IsIfExists <- aIsIfExists
      for e in aObjects do ret.Objects.Add (e.ToCs())
      ret :> ScriptDom.DropObjectsStatement (* 335 *)
    | DropSecurityPolicyStatement(IsIfExists=aIsIfExists; Objects=aObjects) ->
      let ret = ScriptDom.DropSecurityPolicyStatement()
      ret.IsIfExists <- aIsIfExists
      for e in aObjects do ret.Objects.Add (e.ToCs())
      ret :> ScriptDom.DropObjectsStatement (* 335 *)
    | DropSequenceStatement(IsIfExists=aIsIfExists; Objects=aObjects) ->
      let ret = ScriptDom.DropSequenceStatement()
      ret.IsIfExists <- aIsIfExists
      for e in aObjects do ret.Objects.Add (e.ToCs())
      ret :> ScriptDom.DropObjectsStatement (* 335 *)
    | DropSynonymStatement(IsIfExists=aIsIfExists; Objects=aObjects) ->
      let ret = ScriptDom.DropSynonymStatement()
      ret.IsIfExists <- aIsIfExists
      for e in aObjects do ret.Objects.Add (e.ToCs())
      ret :> ScriptDom.DropObjectsStatement (* 335 *)
    | DropTableStatement(IsIfExists=aIsIfExists; Objects=aObjects) ->
      let ret = ScriptDom.DropTableStatement()
      ret.IsIfExists <- aIsIfExists
      for e in aObjects do ret.Objects.Add (e.ToCs())
      ret :> ScriptDom.DropObjectsStatement (* 335 *)
    | DropTriggerStatement(IsIfExists=aIsIfExists; Objects=aObjects; TriggerScope=aTriggerScope) ->
      let ret = ScriptDom.DropTriggerStatement()
      ret.IsIfExists <- aIsIfExists
      for e in aObjects do ret.Objects.Add (e.ToCs())
      ret.TriggerScope <- aTriggerScope
      ret :> ScriptDom.DropObjectsStatement (* 335 *)
    | DropViewStatement(IsIfExists=aIsIfExists; Objects=aObjects) ->
      let ret = ScriptDom.DropViewStatement()
      ret.IsIfExists <- aIsIfExists
      for e in aObjects do ret.Objects.Add (e.ToCs())
      ret :> ScriptDom.DropObjectsStatement (* 335 *)
  static member FromCs(src:ScriptDom.DropObjectsStatement, fragmentMapping:FragmentMapping) : DropObjectsStatement =
    let ret =
      match src with
      | :? ScriptDom.DropAggregateStatement as src ->
        DropObjectsStatement.DropAggregateStatement((src.IsIfExists),(src.Objects |> Seq.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.DropAssemblyStatement as src ->
        DropObjectsStatement.DropAssemblyStatement((src.IsIfExists),(src.Objects |> Seq.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.WithNoDependents))
      | :? ScriptDom.DropDefaultStatement as src ->
        DropObjectsStatement.DropDefaultStatement((src.IsIfExists),(src.Objects |> Seq.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.DropExternalTableStatement as src ->
        DropObjectsStatement.DropExternalTableStatement((src.IsIfExists),(src.Objects |> Seq.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.DropFunctionStatement as src ->
        DropObjectsStatement.DropFunctionStatement((src.IsIfExists),(src.Objects |> Seq.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.DropProcedureStatement as src ->
        DropObjectsStatement.DropProcedureStatement((src.IsIfExists),(src.Objects |> Seq.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.DropRuleStatement as src ->
        DropObjectsStatement.DropRuleStatement((src.IsIfExists),(src.Objects |> Seq.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.DropSecurityPolicyStatement as src ->
        DropObjectsStatement.DropSecurityPolicyStatement((src.IsIfExists),(src.Objects |> Seq.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.DropSequenceStatement as src ->
        DropObjectsStatement.DropSequenceStatement((src.IsIfExists),(src.Objects |> Seq.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.DropSynonymStatement as src ->
        DropObjectsStatement.DropSynonymStatement((src.IsIfExists),(src.Objects |> Seq.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.DropTableStatement as src ->
        DropObjectsStatement.DropTableStatement((src.IsIfExists),(src.Objects |> Seq.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.DropTriggerStatement as src ->
        DropObjectsStatement.DropTriggerStatement((src.IsIfExists),(src.Objects |> Seq.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.TriggerScope))
      | :? ScriptDom.DropViewStatement as src ->
        DropObjectsStatement.DropViewStatement((src.IsIfExists),(src.Objects |> Seq.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] DropUnownedObjectStatement = (* IsAbstract = true *)
  | DropApplicationRoleStatement of IsIfExists:bool * Name:Identifier option
  | DropAsymmetricKeyStatement of IsIfExists:bool * Name:Identifier option * RemoveProviderKey:bool
  | DropAvailabilityGroupStatement of IsIfExists:bool * Name:Identifier option
  | DropBrokerPriorityStatement of IsIfExists:bool * Name:Identifier option
  | DropCertificateStatement of IsIfExists:bool * Name:Identifier option
  | DropColumnEncryptionKeyStatement of IsIfExists:bool * Name:Identifier option
  | DropColumnMasterKeyStatement of IsIfExists:bool * Name:Identifier option
  | DropContractStatement of IsIfExists:bool * Name:Identifier option
  | DropCredentialStatement of IsDatabaseScoped:bool * IsIfExists:bool * Name:Identifier option
  | DropCryptographicProviderStatement of IsIfExists:bool * Name:Identifier option
  | DropDatabaseAuditSpecificationStatement of IsIfExists:bool * Name:Identifier option
  | DropEndpointStatement of IsIfExists:bool * Name:Identifier option
  | DropEventSessionStatement of IsIfExists:bool * Name:Identifier option * SessionScope:ScriptDom.EventSessionScope
  | DropExternalDataSourceStatement of IsIfExists:bool * Name:Identifier option
  | DropExternalFileFormatStatement of IsIfExists:bool * Name:Identifier option
  | DropExternalResourcePoolStatement of IsIfExists:bool * Name:Identifier option
  | DropFederationStatement of IsIfExists:bool * Name:Identifier option
  | DropFullTextCatalogStatement of IsIfExists:bool * Name:Identifier option
  | DropFullTextStopListStatement of IsIfExists:bool * Name:Identifier option
  | DropLoginStatement of IsIfExists:bool * Name:Identifier option
  | DropMessageTypeStatement of IsIfExists:bool * Name:Identifier option
  | DropPartitionFunctionStatement of IsIfExists:bool * Name:Identifier option
  | DropPartitionSchemeStatement of IsIfExists:bool * Name:Identifier option
  | DropRemoteServiceBindingStatement of IsIfExists:bool * Name:Identifier option
  | DropResourcePoolStatement of IsIfExists:bool * Name:Identifier option
  | DropRoleStatement of IsIfExists:bool * Name:Identifier option
  | DropRouteStatement of IsIfExists:bool * Name:Identifier option
  | DropSearchPropertyListStatement of IsIfExists:bool * Name:Identifier option
  | DropServerAuditSpecificationStatement of IsIfExists:bool * Name:Identifier option
  | DropServerAuditStatement of IsIfExists:bool * Name:Identifier option
  | DropServerRoleStatement of IsIfExists:bool * Name:Identifier option
  | DropServiceStatement of IsIfExists:bool * Name:Identifier option
  | DropSymmetricKeyStatement of IsIfExists:bool * Name:Identifier option * RemoveProviderKey:bool
  | DropUserStatement of IsIfExists:bool * Name:Identifier option
  | DropWorkloadClassifierStatement of IsIfExists:bool * Name:Identifier option
  | DropWorkloadGroupStatement of IsIfExists:bool * Name:Identifier option
  member this.ToCs() : ScriptDom.DropUnownedObjectStatement =
    match this with
    | DropApplicationRoleStatement(IsIfExists=aIsIfExists; Name=aName) ->
      let ret = ScriptDom.DropApplicationRoleStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 335 *)
    | DropAsymmetricKeyStatement(IsIfExists=aIsIfExists; Name=aName; RemoveProviderKey=aRemoveProviderKey) ->
      let ret = ScriptDom.DropAsymmetricKeyStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.RemoveProviderKey <- aRemoveProviderKey
      ret :> ScriptDom.DropUnownedObjectStatement (* 335 *)
    | DropAvailabilityGroupStatement(IsIfExists=aIsIfExists; Name=aName) ->
      let ret = ScriptDom.DropAvailabilityGroupStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 335 *)
    | DropBrokerPriorityStatement(IsIfExists=aIsIfExists; Name=aName) ->
      let ret = ScriptDom.DropBrokerPriorityStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 335 *)
    | DropCertificateStatement(IsIfExists=aIsIfExists; Name=aName) ->
      let ret = ScriptDom.DropCertificateStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 335 *)
    | DropColumnEncryptionKeyStatement(IsIfExists=aIsIfExists; Name=aName) ->
      let ret = ScriptDom.DropColumnEncryptionKeyStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 335 *)
    | DropColumnMasterKeyStatement(IsIfExists=aIsIfExists; Name=aName) ->
      let ret = ScriptDom.DropColumnMasterKeyStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 335 *)
    | DropContractStatement(IsIfExists=aIsIfExists; Name=aName) ->
      let ret = ScriptDom.DropContractStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 335 *)
    | DropCredentialStatement(IsDatabaseScoped=aIsDatabaseScoped; IsIfExists=aIsIfExists; Name=aName) ->
      let ret = ScriptDom.DropCredentialStatement()
      ret.IsDatabaseScoped <- aIsDatabaseScoped
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 335 *)
    | DropCryptographicProviderStatement(IsIfExists=aIsIfExists; Name=aName) ->
      let ret = ScriptDom.DropCryptographicProviderStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 335 *)
    | DropDatabaseAuditSpecificationStatement(IsIfExists=aIsIfExists; Name=aName) ->
      let ret = ScriptDom.DropDatabaseAuditSpecificationStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 335 *)
    | DropEndpointStatement(IsIfExists=aIsIfExists; Name=aName) ->
      let ret = ScriptDom.DropEndpointStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 335 *)
    | DropEventSessionStatement(IsIfExists=aIsIfExists; Name=aName; SessionScope=aSessionScope) ->
      let ret = ScriptDom.DropEventSessionStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SessionScope <- aSessionScope
      ret :> ScriptDom.DropUnownedObjectStatement (* 335 *)
    | DropExternalDataSourceStatement(IsIfExists=aIsIfExists; Name=aName) ->
      let ret = ScriptDom.DropExternalDataSourceStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 335 *)
    | DropExternalFileFormatStatement(IsIfExists=aIsIfExists; Name=aName) ->
      let ret = ScriptDom.DropExternalFileFormatStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 335 *)
    | DropExternalResourcePoolStatement(IsIfExists=aIsIfExists; Name=aName) ->
      let ret = ScriptDom.DropExternalResourcePoolStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 335 *)
    | DropFederationStatement(IsIfExists=aIsIfExists; Name=aName) ->
      let ret = ScriptDom.DropFederationStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 335 *)
    | DropFullTextCatalogStatement(IsIfExists=aIsIfExists; Name=aName) ->
      let ret = ScriptDom.DropFullTextCatalogStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 335 *)
    | DropFullTextStopListStatement(IsIfExists=aIsIfExists; Name=aName) ->
      let ret = ScriptDom.DropFullTextStopListStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 335 *)
    | DropLoginStatement(IsIfExists=aIsIfExists; Name=aName) ->
      let ret = ScriptDom.DropLoginStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 335 *)
    | DropMessageTypeStatement(IsIfExists=aIsIfExists; Name=aName) ->
      let ret = ScriptDom.DropMessageTypeStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 335 *)
    | DropPartitionFunctionStatement(IsIfExists=aIsIfExists; Name=aName) ->
      let ret = ScriptDom.DropPartitionFunctionStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 335 *)
    | DropPartitionSchemeStatement(IsIfExists=aIsIfExists; Name=aName) ->
      let ret = ScriptDom.DropPartitionSchemeStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 335 *)
    | DropRemoteServiceBindingStatement(IsIfExists=aIsIfExists; Name=aName) ->
      let ret = ScriptDom.DropRemoteServiceBindingStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 335 *)
    | DropResourcePoolStatement(IsIfExists=aIsIfExists; Name=aName) ->
      let ret = ScriptDom.DropResourcePoolStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 335 *)
    | DropRoleStatement(IsIfExists=aIsIfExists; Name=aName) ->
      let ret = ScriptDom.DropRoleStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 335 *)
    | DropRouteStatement(IsIfExists=aIsIfExists; Name=aName) ->
      let ret = ScriptDom.DropRouteStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 335 *)
    | DropSearchPropertyListStatement(IsIfExists=aIsIfExists; Name=aName) ->
      let ret = ScriptDom.DropSearchPropertyListStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 335 *)
    | DropServerAuditSpecificationStatement(IsIfExists=aIsIfExists; Name=aName) ->
      let ret = ScriptDom.DropServerAuditSpecificationStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 335 *)
    | DropServerAuditStatement(IsIfExists=aIsIfExists; Name=aName) ->
      let ret = ScriptDom.DropServerAuditStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 335 *)
    | DropServerRoleStatement(IsIfExists=aIsIfExists; Name=aName) ->
      let ret = ScriptDom.DropServerRoleStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 335 *)
    | DropServiceStatement(IsIfExists=aIsIfExists; Name=aName) ->
      let ret = ScriptDom.DropServiceStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 335 *)
    | DropSymmetricKeyStatement(IsIfExists=aIsIfExists; Name=aName; RemoveProviderKey=aRemoveProviderKey) ->
      let ret = ScriptDom.DropSymmetricKeyStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.RemoveProviderKey <- aRemoveProviderKey
      ret :> ScriptDom.DropUnownedObjectStatement (* 335 *)
    | DropUserStatement(IsIfExists=aIsIfExists; Name=aName) ->
      let ret = ScriptDom.DropUserStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 335 *)
    | DropWorkloadClassifierStatement(IsIfExists=aIsIfExists; Name=aName) ->
      let ret = ScriptDom.DropWorkloadClassifierStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 335 *)
    | DropWorkloadGroupStatement(IsIfExists=aIsIfExists; Name=aName) ->
      let ret = ScriptDom.DropWorkloadGroupStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 335 *)
  static member FromCs(src:ScriptDom.DropUnownedObjectStatement, fragmentMapping:FragmentMapping) : DropUnownedObjectStatement =
    let ret =
      match src with
      | :? ScriptDom.DropApplicationRoleStatement as src ->
        DropUnownedObjectStatement.DropApplicationRoleStatement((src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropAsymmetricKeyStatement as src ->
        DropUnownedObjectStatement.DropAsymmetricKeyStatement((src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.RemoveProviderKey))
      | :? ScriptDom.DropAvailabilityGroupStatement as src ->
        DropUnownedObjectStatement.DropAvailabilityGroupStatement((src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropBrokerPriorityStatement as src ->
        DropUnownedObjectStatement.DropBrokerPriorityStatement((src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropCertificateStatement as src ->
        DropUnownedObjectStatement.DropCertificateStatement((src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropColumnEncryptionKeyStatement as src ->
        DropUnownedObjectStatement.DropColumnEncryptionKeyStatement((src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropColumnMasterKeyStatement as src ->
        DropUnownedObjectStatement.DropColumnMasterKeyStatement((src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropContractStatement as src ->
        DropUnownedObjectStatement.DropContractStatement((src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropCredentialStatement as src ->
        DropUnownedObjectStatement.DropCredentialStatement((src.IsDatabaseScoped),(src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropCryptographicProviderStatement as src ->
        DropUnownedObjectStatement.DropCryptographicProviderStatement((src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropDatabaseAuditSpecificationStatement as src ->
        DropUnownedObjectStatement.DropDatabaseAuditSpecificationStatement((src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropEndpointStatement as src ->
        DropUnownedObjectStatement.DropEndpointStatement((src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropEventSessionStatement as src ->
        DropUnownedObjectStatement.DropEventSessionStatement((src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.SessionScope))
      | :? ScriptDom.DropExternalDataSourceStatement as src ->
        DropUnownedObjectStatement.DropExternalDataSourceStatement((src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropExternalFileFormatStatement as src ->
        DropUnownedObjectStatement.DropExternalFileFormatStatement((src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropExternalResourcePoolStatement as src ->
        DropUnownedObjectStatement.DropExternalResourcePoolStatement((src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropFederationStatement as src ->
        DropUnownedObjectStatement.DropFederationStatement((src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropFullTextCatalogStatement as src ->
        DropUnownedObjectStatement.DropFullTextCatalogStatement((src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropFullTextStopListStatement as src ->
        DropUnownedObjectStatement.DropFullTextStopListStatement((src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropLoginStatement as src ->
        DropUnownedObjectStatement.DropLoginStatement((src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropMessageTypeStatement as src ->
        DropUnownedObjectStatement.DropMessageTypeStatement((src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropPartitionFunctionStatement as src ->
        DropUnownedObjectStatement.DropPartitionFunctionStatement((src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropPartitionSchemeStatement as src ->
        DropUnownedObjectStatement.DropPartitionSchemeStatement((src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropRemoteServiceBindingStatement as src ->
        DropUnownedObjectStatement.DropRemoteServiceBindingStatement((src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropResourcePoolStatement as src ->
        DropUnownedObjectStatement.DropResourcePoolStatement((src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropRoleStatement as src ->
        DropUnownedObjectStatement.DropRoleStatement((src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropRouteStatement as src ->
        DropUnownedObjectStatement.DropRouteStatement((src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropSearchPropertyListStatement as src ->
        DropUnownedObjectStatement.DropSearchPropertyListStatement((src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropServerAuditSpecificationStatement as src ->
        DropUnownedObjectStatement.DropServerAuditSpecificationStatement((src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropServerAuditStatement as src ->
        DropUnownedObjectStatement.DropServerAuditStatement((src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropServerRoleStatement as src ->
        DropUnownedObjectStatement.DropServerRoleStatement((src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropServiceStatement as src ->
        DropUnownedObjectStatement.DropServiceStatement((src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropSymmetricKeyStatement as src ->
        DropUnownedObjectStatement.DropSymmetricKeyStatement((src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.RemoveProviderKey))
      | :? ScriptDom.DropUserStatement as src ->
        DropUnownedObjectStatement.DropUserStatement((src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropWorkloadClassifierStatement as src ->
        DropUnownedObjectStatement.DropWorkloadClassifierStatement((src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DropWorkloadGroupStatement as src ->
        DropUnownedObjectStatement.DropWorkloadGroupStatement((src.IsIfExists),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] EventSessionStatement = (* IsAbstract = false *)
  | Base of EventDeclarations:(EventDeclaration) list * Name:Identifier option * SessionOptions:(SessionOption) list * SessionScope:ScriptDom.EventSessionScope * TargetDeclarations:(TargetDeclaration) list
  | AlterEventSessionStatement of DropEventDeclarations:(EventSessionObjectName) list * DropTargetDeclarations:(EventSessionObjectName) list * EventDeclarations:(EventDeclaration) list * Name:Identifier option * SessionOptions:(SessionOption) list * SessionScope:ScriptDom.EventSessionScope * StatementType:ScriptDom.AlterEventSessionStatementType * TargetDeclarations:(TargetDeclaration) list
  | CreateEventSessionStatement of EventDeclarations:(EventDeclaration) list * Name:Identifier option * SessionOptions:(SessionOption) list * SessionScope:ScriptDom.EventSessionScope * TargetDeclarations:(TargetDeclaration) list
  member this.ToCs() : ScriptDom.EventSessionStatement =
    match this with
    | AlterEventSessionStatement(DropEventDeclarations=aDropEventDeclarations; DropTargetDeclarations=aDropTargetDeclarations; EventDeclarations=aEventDeclarations; Name=aName; SessionOptions=aSessionOptions; SessionScope=aSessionScope; StatementType=aStatementType; TargetDeclarations=aTargetDeclarations) ->
      let ret = ScriptDom.AlterEventSessionStatement()
      for e in aDropEventDeclarations do ret.DropEventDeclarations.Add (e.ToCs())
      for e in aDropTargetDeclarations do ret.DropTargetDeclarations.Add (e.ToCs())
      for e in aEventDeclarations do ret.EventDeclarations.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aSessionOptions do ret.SessionOptions.Add (e.ToCs())
      ret.SessionScope <- aSessionScope
      ret.StatementType <- aStatementType
      for e in aTargetDeclarations do ret.TargetDeclarations.Add (e.ToCs())
      ret :> ScriptDom.EventSessionStatement (* 335 *)
    | CreateEventSessionStatement(EventDeclarations=aEventDeclarations; Name=aName; SessionOptions=aSessionOptions; SessionScope=aSessionScope; TargetDeclarations=aTargetDeclarations) ->
      let ret = ScriptDom.CreateEventSessionStatement()
      for e in aEventDeclarations do ret.EventDeclarations.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aSessionOptions do ret.SessionOptions.Add (e.ToCs())
      ret.SessionScope <- aSessionScope
      for e in aTargetDeclarations do ret.TargetDeclarations.Add (e.ToCs())
      ret :> ScriptDom.EventSessionStatement (* 335 *)
    | Base(EventDeclarations=aEventDeclarations; Name=aName; SessionOptions=aSessionOptions; SessionScope=aSessionScope; TargetDeclarations=aTargetDeclarations) ->

      let ret = ScriptDom.EventSessionStatement()
      for e in aEventDeclarations do ret.EventDeclarations.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aSessionOptions do ret.SessionOptions.Add (e.ToCs())
      ret.SessionScope <- aSessionScope
      for e in aTargetDeclarations do ret.TargetDeclarations.Add (e.ToCs())
      ret
  static member FromCs(src:ScriptDom.EventSessionStatement, fragmentMapping:FragmentMapping) : EventSessionStatement =
    let ret =
      match src with
      | :? ScriptDom.AlterEventSessionStatement as src ->
        EventSessionStatement.AlterEventSessionStatement((src.DropEventDeclarations |> Seq.map (fun src -> EventSessionObjectName.EventSessionObjectName((src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.DropTargetDeclarations |> Seq.map (fun src -> EventSessionObjectName.EventSessionObjectName((src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.EventDeclarations |> Seq.map (fun src -> EventDeclaration.EventDeclaration((src.EventDeclarationActionParameters |> Seq.map (fun src -> EventSessionObjectName.EventSessionObjectName((src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.EventDeclarationPredicateParameter |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))), (src.EventDeclarationSetParameters |> Seq.map (fun src -> EventDeclarationSetParameter.EventDeclarationSetParameter((src.EventField |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.EventValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.ObjectName |> Option.ofObj |> Option.map (fun x -> EventSessionObjectName.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.SessionOptions |> Seq.map (fun x -> SessionOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.SessionScope),(src.StatementType),(src.TargetDeclarations |> Seq.map (fun src -> TargetDeclaration.TargetDeclaration((src.ObjectName |> Option.ofObj |> Option.map (fun x -> EventSessionObjectName.FromCs(x, fragmentMapping))), (src.TargetDeclarationParameters |> Seq.map (fun src -> EventDeclarationSetParameter.EventDeclarationSetParameter((src.EventField |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.EventValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq))) |> List.ofSeq))
      | :? ScriptDom.CreateEventSessionStatement as src ->
        EventSessionStatement.CreateEventSessionStatement((src.EventDeclarations |> Seq.map (fun src -> EventDeclaration.EventDeclaration((src.EventDeclarationActionParameters |> Seq.map (fun src -> EventSessionObjectName.EventSessionObjectName((src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.EventDeclarationPredicateParameter |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))), (src.EventDeclarationSetParameters |> Seq.map (fun src -> EventDeclarationSetParameter.EventDeclarationSetParameter((src.EventField |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.EventValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.ObjectName |> Option.ofObj |> Option.map (fun x -> EventSessionObjectName.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.SessionOptions |> Seq.map (fun x -> SessionOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.SessionScope),(src.TargetDeclarations |> Seq.map (fun src -> TargetDeclaration.TargetDeclaration((src.ObjectName |> Option.ofObj |> Option.map (fun x -> EventSessionObjectName.FromCs(x, fragmentMapping))), (src.TargetDeclarationParameters |> Seq.map (fun src -> EventDeclarationSetParameter.EventDeclarationSetParameter((src.EventField |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.EventValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq))) |> List.ofSeq))
      | _ -> (* :? ScriptDom.EventSessionStatement as src *)
        EventSessionStatement.Base(((src.EventDeclarations |> Seq.map (fun src -> EventDeclaration.EventDeclaration((src.EventDeclarationActionParameters |> Seq.map (fun src -> EventSessionObjectName.EventSessionObjectName((src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.EventDeclarationPredicateParameter |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))), (src.EventDeclarationSetParameters |> Seq.map (fun src -> EventDeclarationSetParameter.EventDeclarationSetParameter((src.EventField |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.EventValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.ObjectName |> Option.ofObj |> Option.map (fun x -> EventSessionObjectName.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.SessionOptions |> Seq.map (fun x -> SessionOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.SessionScope), (src.TargetDeclarations |> Seq.map (fun src -> TargetDeclaration.TargetDeclaration((src.ObjectName |> Option.ofObj |> Option.map (fun x -> EventSessionObjectName.FromCs(x, fragmentMapping))), (src.TargetDeclarationParameters |> Seq.map (fun src -> EventDeclarationSetParameter.EventDeclarationSetParameter((src.EventField |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.EventValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq))) |> List.ofSeq))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ExternalDataSourceStatement = (* IsAbstract = true *)
  | AlterExternalDataSourceStatement of DataSourceType:ScriptDom.ExternalDataSourceType * ExternalDataSourceOptions:(ExternalDataSourceOption) list * Location:Literal option * Name:Identifier option * PreviousPushDownOption:ScriptDom.ExternalDataSourcePushdownOption * PushdownOption:ScriptDom.ExternalDataSourcePushdownOption
  | CreateExternalDataSourceStatement of DataSourceType:ScriptDom.ExternalDataSourceType * ExternalDataSourceOptions:(ExternalDataSourceOption) list * Location:Literal option * Name:Identifier option * PushdownOption:ScriptDom.ExternalDataSourcePushdownOption
  member this.ToCs() : ScriptDom.ExternalDataSourceStatement =
    match this with
    | AlterExternalDataSourceStatement(DataSourceType=aDataSourceType; ExternalDataSourceOptions=aExternalDataSourceOptions; Location=aLocation; Name=aName; PreviousPushDownOption=aPreviousPushDownOption; PushdownOption=aPushdownOption) ->
      let ret = ScriptDom.AlterExternalDataSourceStatement()
      ret.DataSourceType <- aDataSourceType
      for e in aExternalDataSourceOptions do ret.ExternalDataSourceOptions.Add (e.ToCs())
      ret.Location <- aLocation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PreviousPushDownOption <- aPreviousPushDownOption
      ret.PushdownOption <- aPushdownOption
      ret :> ScriptDom.ExternalDataSourceStatement (* 335 *)
    | CreateExternalDataSourceStatement(DataSourceType=aDataSourceType; ExternalDataSourceOptions=aExternalDataSourceOptions; Location=aLocation; Name=aName; PushdownOption=aPushdownOption) ->
      let ret = ScriptDom.CreateExternalDataSourceStatement()
      ret.DataSourceType <- aDataSourceType
      for e in aExternalDataSourceOptions do ret.ExternalDataSourceOptions.Add (e.ToCs())
      ret.Location <- aLocation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PushdownOption <- aPushdownOption
      ret :> ScriptDom.ExternalDataSourceStatement (* 335 *)
  static member FromCs(src:ScriptDom.ExternalDataSourceStatement, fragmentMapping:FragmentMapping) : ExternalDataSourceStatement =
    let ret =
      match src with
      | :? ScriptDom.AlterExternalDataSourceStatement as src ->
        ExternalDataSourceStatement.AlterExternalDataSourceStatement((src.DataSourceType),(src.ExternalDataSourceOptions |> Seq.map (fun x -> ExternalDataSourceOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Location |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.PreviousPushDownOption),(src.PushdownOption))
      | :? ScriptDom.CreateExternalDataSourceStatement as src ->
        ExternalDataSourceStatement.CreateExternalDataSourceStatement((src.DataSourceType),(src.ExternalDataSourceOptions |> Seq.map (fun x -> ExternalDataSourceOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Location |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.PushdownOption))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ExternalFileFormatStatement = (* IsAbstract = true *)
  | CreateExternalFileFormatStatement of ExternalFileFormatOptions:(ExternalFileFormatOption) list * FormatType:ScriptDom.ExternalFileFormatType * Name:Identifier option
  member this.ToCs() : ScriptDom.ExternalFileFormatStatement =
    match this with
    | CreateExternalFileFormatStatement(ExternalFileFormatOptions=aExternalFileFormatOptions; FormatType=aFormatType; Name=aName) ->
      let ret = ScriptDom.CreateExternalFileFormatStatement()
      for e in aExternalFileFormatOptions do ret.ExternalFileFormatOptions.Add (e.ToCs())
      ret.FormatType <- aFormatType
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ExternalFileFormatStatement (* 335 *)
  static member FromCs(src:ScriptDom.ExternalFileFormatStatement, fragmentMapping:FragmentMapping) : ExternalFileFormatStatement =
    let ret =
      match src with
      | :? ScriptDom.CreateExternalFileFormatStatement as src ->
        ExternalFileFormatStatement.CreateExternalFileFormatStatement((src.ExternalFileFormatOptions |> Seq.map (fun x -> ExternalFileFormatOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.FormatType),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ExternalResourcePoolStatement = (* IsAbstract = false *)
  | Base of ExternalResourcePoolParameters:(ExternalResourcePoolParameter) list * Name:Identifier option
  | AlterExternalResourcePoolStatement of ExternalResourcePoolParameters:(ExternalResourcePoolParameter) list * Name:Identifier option
  | CreateExternalResourcePoolStatement of ExternalResourcePoolParameters:(ExternalResourcePoolParameter) list * Name:Identifier option
  member this.ToCs() : ScriptDom.ExternalResourcePoolStatement =
    match this with
    | AlterExternalResourcePoolStatement(ExternalResourcePoolParameters=aExternalResourcePoolParameters; Name=aName) ->
      let ret = ScriptDom.AlterExternalResourcePoolStatement()
      for e in aExternalResourcePoolParameters do ret.ExternalResourcePoolParameters.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ExternalResourcePoolStatement (* 335 *)
    | CreateExternalResourcePoolStatement(ExternalResourcePoolParameters=aExternalResourcePoolParameters; Name=aName) ->
      let ret = ScriptDom.CreateExternalResourcePoolStatement()
      for e in aExternalResourcePoolParameters do ret.ExternalResourcePoolParameters.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ExternalResourcePoolStatement (* 335 *)
    | Base(ExternalResourcePoolParameters=aExternalResourcePoolParameters; Name=aName) ->

      let ret = ScriptDom.ExternalResourcePoolStatement()
      for e in aExternalResourcePoolParameters do ret.ExternalResourcePoolParameters.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret
  static member FromCs(src:ScriptDom.ExternalResourcePoolStatement, fragmentMapping:FragmentMapping) : ExternalResourcePoolStatement =
    let ret =
      match src with
      | :? ScriptDom.AlterExternalResourcePoolStatement as src ->
        ExternalResourcePoolStatement.AlterExternalResourcePoolStatement((src.ExternalResourcePoolParameters |> Seq.map (fun src -> ExternalResourcePoolParameter.ExternalResourcePoolParameter((src.AffinitySpecification |> Option.ofObj |> Option.map (fun x -> ExternalResourcePoolAffinitySpecification.FromCs(x, fragmentMapping))), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CreateExternalResourcePoolStatement as src ->
        ExternalResourcePoolStatement.CreateExternalResourcePoolStatement((src.ExternalResourcePoolParameters |> Seq.map (fun src -> ExternalResourcePoolParameter.ExternalResourcePoolParameter((src.AffinitySpecification |> Option.ofObj |> Option.map (fun x -> ExternalResourcePoolAffinitySpecification.FromCs(x, fragmentMapping))), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | _ -> (* :? ScriptDom.ExternalResourcePoolStatement as src *)
        ExternalResourcePoolStatement.Base(((src.ExternalResourcePoolParameters |> Seq.map (fun src -> ExternalResourcePoolParameter.ExternalResourcePoolParameter((src.AffinitySpecification |> Option.ofObj |> Option.map (fun x -> ExternalResourcePoolAffinitySpecification.FromCs(x, fragmentMapping))), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ExternalTableStatement = (* IsAbstract = true *)
  | CreateExternalTableStatement of ColumnDefinitions:(ExternalTableColumnDefinition) list * DataSource:Identifier option * ExternalTableOptions:(ExternalTableOption) list * SchemaObjectName:SchemaObjectName option * SelectStatement:SelectStatement option
  member this.ToCs() : ScriptDom.ExternalTableStatement =
    match this with
    | CreateExternalTableStatement(ColumnDefinitions=aColumnDefinitions; DataSource=aDataSource; ExternalTableOptions=aExternalTableOptions; SchemaObjectName=aSchemaObjectName; SelectStatement=aSelectStatement) ->
      let ret = ScriptDom.CreateExternalTableStatement()
      for e in aColumnDefinitions do ret.ColumnDefinitions.Add (e.ToCs())
      ret.DataSource <- aDataSource |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aExternalTableOptions do ret.ExternalTableOptions.Add (e.ToCs())
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SelectStatement <- aSelectStatement |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ExternalTableStatement (* 335 *)
  static member FromCs(src:ScriptDom.ExternalTableStatement, fragmentMapping:FragmentMapping) : ExternalTableStatement =
    let ret =
      match src with
      | :? ScriptDom.CreateExternalTableStatement as src ->
        ExternalTableStatement.CreateExternalTableStatement((src.ColumnDefinitions |> Seq.map (fun src -> ExternalTableColumnDefinition.ExternalTableColumnDefinition((src.ColumnDefinition |> Option.ofObj |> Option.map (fun x -> ColumnDefinitionBase.FromCs(x, fragmentMapping))), (src.NullableConstraint |> Option.ofObj |> Option.map (fun x -> NullableConstraintDefinition.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.DataSource |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.ExternalTableOptions |> Seq.map (fun x -> ExternalTableOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.SelectStatement |> Option.ofObj |> Option.map (fun x -> SelectStatement.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] FullTextCatalogStatement = (* IsAbstract = true *)
  | AlterFullTextCatalogStatement of Action:ScriptDom.AlterFullTextCatalogAction * Name:Identifier option * Options:(FullTextCatalogOption) list
  | CreateFullTextCatalogStatement of FileGroup:Identifier option * IsDefault:bool * Name:Identifier option * Options:(FullTextCatalogOption) list * Owner:Identifier option * Path:Literal option
  member this.ToCs() : ScriptDom.FullTextCatalogStatement =
    match this with
    | AlterFullTextCatalogStatement(Action=aAction; Name=aName; Options=aOptions) ->
      let ret = ScriptDom.AlterFullTextCatalogStatement()
      ret.Action <- aAction
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.FullTextCatalogStatement (* 335 *)
    | CreateFullTextCatalogStatement(FileGroup=aFileGroup; IsDefault=aIsDefault; Name=aName; Options=aOptions; Owner=aOwner; Path=aPath) ->
      let ret = ScriptDom.CreateFullTextCatalogStatement()
      ret.FileGroup <- aFileGroup |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsDefault <- aIsDefault
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.Owner <- aOwner |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Path <- aPath |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.FullTextCatalogStatement (* 335 *)
  static member FromCs(src:ScriptDom.FullTextCatalogStatement, fragmentMapping:FragmentMapping) : FullTextCatalogStatement =
    let ret =
      match src with
      | :? ScriptDom.AlterFullTextCatalogStatement as src ->
        FullTextCatalogStatement.AlterFullTextCatalogStatement((src.Action),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Options |> Seq.map (fun x -> FullTextCatalogOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.CreateFullTextCatalogStatement as src ->
        FullTextCatalogStatement.CreateFullTextCatalogStatement((src.FileGroup |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.IsDefault),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Options |> Seq.map (fun x -> FullTextCatalogOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Owner |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Path |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] IndexStatement = (* IsAbstract = true *)
  | AlterIndexStatement of All:bool * AlterIndexType:ScriptDom.AlterIndexType * IndexOptions:(IndexOption) list * Name:Identifier option * OnName:SchemaObjectName option * Partition:PartitionSpecifier option * PromotedPaths:(SelectiveXmlIndexPromotedPath) list * XmlNamespaces:XmlNamespaces option
  | CreateIndexStatement of Clustered:(bool) option * Columns:(ColumnWithSortOrder) list * FileStreamOn:IdentifierOrValueExpression option * FilterPredicate:BooleanExpression option * IncludeColumns:(ColumnReferenceExpression) list * IndexOptions:(IndexOption) list * Name:Identifier option * OnFileGroupOrPartitionScheme:FileGroupOrPartitionScheme option * OnName:SchemaObjectName option * Translated80SyntaxTo90:bool * Unique:bool
  | CreateSelectiveXmlIndexStatement of IndexOptions:(IndexOption) list * IsSecondary:bool * Name:Identifier option * OnName:SchemaObjectName option * PathName:Identifier option * PromotedPaths:(SelectiveXmlIndexPromotedPath) list * UsingXmlIndexName:Identifier option * XmlColumn:Identifier option * XmlNamespaces:XmlNamespaces option
  | CreateXmlIndexStatement of IndexOptions:(IndexOption) list * Name:Identifier option * OnName:SchemaObjectName option * Primary:bool * SecondaryXmlIndexName:Identifier option * SecondaryXmlIndexType:ScriptDom.SecondaryXmlIndexType * XmlColumn:Identifier option
  member this.ToCs() : ScriptDom.IndexStatement =
    match this with
    | AlterIndexStatement(All=aAll; AlterIndexType=aAlterIndexType; IndexOptions=aIndexOptions; Name=aName; OnName=aOnName; Partition=aPartition; PromotedPaths=aPromotedPaths; XmlNamespaces=aXmlNamespaces) ->
      let ret = ScriptDom.AlterIndexStatement()
      ret.All <- aAll
      ret.AlterIndexType <- aAlterIndexType
      for e in aIndexOptions do ret.IndexOptions.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OnName <- aOnName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Partition <- aPartition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aPromotedPaths do ret.PromotedPaths.Add (e.ToCs())
      ret.XmlNamespaces <- aXmlNamespaces |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.IndexStatement (* 335 *)
    | CreateIndexStatement(Clustered=aClustered; Columns=aColumns; FileStreamOn=aFileStreamOn; FilterPredicate=aFilterPredicate; IncludeColumns=aIncludeColumns; IndexOptions=aIndexOptions; Name=aName; OnFileGroupOrPartitionScheme=aOnFileGroupOrPartitionScheme; OnName=aOnName; Translated80SyntaxTo90=aTranslated80SyntaxTo90; Unique=aUnique) ->
      let ret = ScriptDom.CreateIndexStatement()
      ret.Clustered <- Option.toNullable aClustered
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.FileStreamOn <- aFileStreamOn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FilterPredicate <- aFilterPredicate |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aIncludeColumns do ret.IncludeColumns.Add (e.ToCs())
      for e in aIndexOptions do ret.IndexOptions.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OnFileGroupOrPartitionScheme <- aOnFileGroupOrPartitionScheme |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OnName <- aOnName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Translated80SyntaxTo90 <- aTranslated80SyntaxTo90
      ret.Unique <- aUnique
      ret :> ScriptDom.IndexStatement (* 335 *)
    | CreateSelectiveXmlIndexStatement(IndexOptions=aIndexOptions; IsSecondary=aIsSecondary; Name=aName; OnName=aOnName; PathName=aPathName; PromotedPaths=aPromotedPaths; UsingXmlIndexName=aUsingXmlIndexName; XmlColumn=aXmlColumn; XmlNamespaces=aXmlNamespaces) ->
      let ret = ScriptDom.CreateSelectiveXmlIndexStatement()
      for e in aIndexOptions do ret.IndexOptions.Add (e.ToCs())
      ret.IsSecondary <- aIsSecondary
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OnName <- aOnName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PathName <- aPathName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aPromotedPaths do ret.PromotedPaths.Add (e.ToCs())
      ret.UsingXmlIndexName <- aUsingXmlIndexName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.XmlColumn <- aXmlColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.XmlNamespaces <- aXmlNamespaces |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.IndexStatement (* 335 *)
    | CreateXmlIndexStatement(IndexOptions=aIndexOptions; Name=aName; OnName=aOnName; Primary=aPrimary; SecondaryXmlIndexName=aSecondaryXmlIndexName; SecondaryXmlIndexType=aSecondaryXmlIndexType; XmlColumn=aXmlColumn) ->
      let ret = ScriptDom.CreateXmlIndexStatement()
      for e in aIndexOptions do ret.IndexOptions.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OnName <- aOnName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Primary <- aPrimary
      ret.SecondaryXmlIndexName <- aSecondaryXmlIndexName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SecondaryXmlIndexType <- aSecondaryXmlIndexType
      ret.XmlColumn <- aXmlColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.IndexStatement (* 335 *)
  static member FromCs(src:ScriptDom.IndexStatement, fragmentMapping:FragmentMapping) : IndexStatement =
    let ret =
      match src with
      | :? ScriptDom.AlterIndexStatement as src ->
        IndexStatement.AlterIndexStatement((src.All),(src.AlterIndexType),(src.IndexOptions |> Seq.map (fun x -> IndexOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.OnName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.Partition |> Option.ofObj |> Option.map (fun x -> PartitionSpecifier.FromCs(x, fragmentMapping))),(src.PromotedPaths |> Seq.map (fun src -> SelectiveXmlIndexPromotedPath.SelectiveXmlIndexPromotedPath((src.IsSingleton), (src.MaxLength |> Option.ofObj |> Option.map (fun x -> IntegerLiteral.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Path |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.SQLDataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.XQueryDataType |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.XmlNamespaces |> Option.ofObj |> Option.map (fun x -> XmlNamespaces.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CreateIndexStatement as src ->
        IndexStatement.CreateIndexStatement((Option.ofNullable (src.Clustered)),(src.Columns |> Seq.map (fun src -> ColumnWithSortOrder.ColumnWithSortOrder((src.Column |> Option.ofObj |> Option.map (fun x -> ColumnReferenceExpression.FromCs(x, fragmentMapping))), (src.SortOrder))) |> List.ofSeq),(src.FileStreamOn |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))),(src.FilterPredicate |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))),(src.IncludeColumns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.IndexOptions |> Seq.map (fun x -> IndexOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.OnFileGroupOrPartitionScheme |> Option.ofObj |> Option.map (fun x -> FileGroupOrPartitionScheme.FromCs(x, fragmentMapping))),(src.OnName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.Translated80SyntaxTo90),(src.Unique))
      | :? ScriptDom.CreateSelectiveXmlIndexStatement as src ->
        IndexStatement.CreateSelectiveXmlIndexStatement((src.IndexOptions |> Seq.map (fun x -> IndexOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.IsSecondary),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.OnName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.PathName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.PromotedPaths |> Seq.map (fun src -> SelectiveXmlIndexPromotedPath.SelectiveXmlIndexPromotedPath((src.IsSingleton), (src.MaxLength |> Option.ofObj |> Option.map (fun x -> IntegerLiteral.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Path |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.SQLDataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.XQueryDataType |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.UsingXmlIndexName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.XmlColumn |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.XmlNamespaces |> Option.ofObj |> Option.map (fun x -> XmlNamespaces.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CreateXmlIndexStatement as src ->
        IndexStatement.CreateXmlIndexStatement((src.IndexOptions |> Seq.map (fun x -> IndexOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.OnName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.Primary),(src.SecondaryXmlIndexName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.SecondaryXmlIndexType),(src.XmlColumn |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] MasterKeyStatement = (* IsAbstract = true *)
  | AlterMasterKeyStatement of Option:ScriptDom.AlterMasterKeyOption * Password:Literal option
  | CreateMasterKeyStatement of Password:Literal option
  member this.ToCs() : ScriptDom.MasterKeyStatement =
    match this with
    | AlterMasterKeyStatement(Option=aOption; Password=aPassword) ->
      let ret = ScriptDom.AlterMasterKeyStatement()
      ret.Option <- aOption
      ret.Password <- aPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.MasterKeyStatement (* 335 *)
    | CreateMasterKeyStatement(Password=aPassword) ->
      let ret = ScriptDom.CreateMasterKeyStatement()
      ret.Password <- aPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.MasterKeyStatement (* 335 *)
  static member FromCs(src:ScriptDom.MasterKeyStatement, fragmentMapping:FragmentMapping) : MasterKeyStatement =
    let ret =
      match src with
      | :? ScriptDom.AlterMasterKeyStatement as src ->
        MasterKeyStatement.AlterMasterKeyStatement((src.Option),(src.Password |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CreateMasterKeyStatement as src ->
        MasterKeyStatement.CreateMasterKeyStatement((src.Password |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] MessageTypeStatementBase = (* IsAbstract = true *)
  | AlterMessageTypeStatement of Name:Identifier option * ValidationMethod:ScriptDom.MessageValidationMethod * XmlSchemaCollectionName:SchemaObjectName option
  | CreateMessageTypeStatement of Name:Identifier option * Owner:Identifier option * ValidationMethod:ScriptDom.MessageValidationMethod * XmlSchemaCollectionName:SchemaObjectName option
  member this.ToCs() : ScriptDom.MessageTypeStatementBase =
    match this with
    | AlterMessageTypeStatement(Name=aName; ValidationMethod=aValidationMethod; XmlSchemaCollectionName=aXmlSchemaCollectionName) ->
      let ret = ScriptDom.AlterMessageTypeStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ValidationMethod <- aValidationMethod
      ret.XmlSchemaCollectionName <- aXmlSchemaCollectionName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.MessageTypeStatementBase (* 335 *)
    | CreateMessageTypeStatement(Name=aName; Owner=aOwner; ValidationMethod=aValidationMethod; XmlSchemaCollectionName=aXmlSchemaCollectionName) ->
      let ret = ScriptDom.CreateMessageTypeStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Owner <- aOwner |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ValidationMethod <- aValidationMethod
      ret.XmlSchemaCollectionName <- aXmlSchemaCollectionName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.MessageTypeStatementBase (* 335 *)
  static member FromCs(src:ScriptDom.MessageTypeStatementBase, fragmentMapping:FragmentMapping) : MessageTypeStatementBase =
    let ret =
      match src with
      | :? ScriptDom.AlterMessageTypeStatement as src ->
        MessageTypeStatementBase.AlterMessageTypeStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.ValidationMethod),(src.XmlSchemaCollectionName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CreateMessageTypeStatement as src ->
        MessageTypeStatementBase.CreateMessageTypeStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Owner |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.ValidationMethod),(src.XmlSchemaCollectionName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ProcedureStatementBodyBase = (* IsAbstract = true *)
  | FunctionStatementBody of FunctionStatementBody
  | ProcedureStatementBody of ProcedureStatementBody
  member this.ToCs() : ScriptDom.ProcedureStatementBodyBase =
    match this with
    | FunctionStatementBody(x) -> x.ToCs() :> ScriptDom.ProcedureStatementBodyBase (* 345 *)
    | ProcedureStatementBody(x) -> x.ToCs() :> ScriptDom.ProcedureStatementBodyBase (* 345 *)
  static member FromCs(src:ScriptDom.ProcedureStatementBodyBase, fragmentMapping:FragmentMapping) : ProcedureStatementBodyBase =
    let ret =
      match src with
      | :? ScriptDom.FunctionStatementBody as src ->
        match src with
        | :? ScriptDom.AlterFunctionStatement as src->
          ProcedureStatementBodyBase.FunctionStatementBody((FunctionStatementBody.AlterFunctionStatement((src.MethodSpecifier |> Option.ofObj |> Option.map (fun x -> MethodSpecifier.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.Options |> Seq.map (fun x -> FunctionOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.OrderHint |> Option.ofObj |> Option.map (fun x -> OrderBulkInsertOption.FromCs(x, fragmentMapping))), (src.Parameters |> Seq.map (fun src -> ProcedureParameter.ProcedureParameter((src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.IsVarying), (src.Modifier), (src.Nullable |> Option.ofObj |> Option.map (fun x -> NullableConstraintDefinition.FromCs(x, fragmentMapping))), (src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.VariableName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.ReturnType |> Option.ofObj |> Option.map (fun x -> FunctionReturnType.FromCs(x, fragmentMapping))), (src.StatementList |> Option.ofObj |> Option.map (fun x -> StatementList.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CreateFunctionStatement as src->
          ProcedureStatementBodyBase.FunctionStatementBody((FunctionStatementBody.CreateFunctionStatement((src.MethodSpecifier |> Option.ofObj |> Option.map (fun x -> MethodSpecifier.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.Options |> Seq.map (fun x -> FunctionOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.OrderHint |> Option.ofObj |> Option.map (fun x -> OrderBulkInsertOption.FromCs(x, fragmentMapping))), (src.Parameters |> Seq.map (fun src -> ProcedureParameter.ProcedureParameter((src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.IsVarying), (src.Modifier), (src.Nullable |> Option.ofObj |> Option.map (fun x -> NullableConstraintDefinition.FromCs(x, fragmentMapping))), (src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.VariableName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.ReturnType |> Option.ofObj |> Option.map (fun x -> FunctionReturnType.FromCs(x, fragmentMapping))), (src.StatementList |> Option.ofObj |> Option.map (fun x -> StatementList.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CreateOrAlterFunctionStatement as src->
          ProcedureStatementBodyBase.FunctionStatementBody((FunctionStatementBody.CreateOrAlterFunctionStatement((src.MethodSpecifier |> Option.ofObj |> Option.map (fun x -> MethodSpecifier.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.Options |> Seq.map (fun x -> FunctionOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.OrderHint |> Option.ofObj |> Option.map (fun x -> OrderBulkInsertOption.FromCs(x, fragmentMapping))), (src.Parameters |> Seq.map (fun src -> ProcedureParameter.ProcedureParameter((src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.IsVarying), (src.Modifier), (src.Nullable |> Option.ofObj |> Option.map (fun x -> NullableConstraintDefinition.FromCs(x, fragmentMapping))), (src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.VariableName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.ReturnType |> Option.ofObj |> Option.map (fun x -> FunctionReturnType.FromCs(x, fragmentMapping))), (src.StatementList |> Option.ofObj |> Option.map (fun x -> StatementList.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.ProcedureStatementBody as src ->
        match src with
        | :? ScriptDom.AlterProcedureStatement as src->
          ProcedureStatementBodyBase.ProcedureStatementBody((ProcedureStatementBody.AlterProcedureStatement((src.IsForReplication), (src.MethodSpecifier |> Option.ofObj |> Option.map (fun x -> MethodSpecifier.FromCs(x, fragmentMapping))), (src.Options |> Seq.map (fun x -> ProcedureOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Parameters |> Seq.map (fun src -> ProcedureParameter.ProcedureParameter((src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.IsVarying), (src.Modifier), (src.Nullable |> Option.ofObj |> Option.map (fun x -> NullableConstraintDefinition.FromCs(x, fragmentMapping))), (src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.VariableName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.ProcedureReference |> Option.ofObj |> Option.map (fun x -> ProcedureReference.FromCs(x, fragmentMapping))), (src.StatementList |> Option.ofObj |> Option.map (fun x -> StatementList.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CreateOrAlterProcedureStatement as src->
          ProcedureStatementBodyBase.ProcedureStatementBody((ProcedureStatementBody.CreateOrAlterProcedureStatement((src.IsForReplication), (src.MethodSpecifier |> Option.ofObj |> Option.map (fun x -> MethodSpecifier.FromCs(x, fragmentMapping))), (src.Options |> Seq.map (fun x -> ProcedureOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Parameters |> Seq.map (fun src -> ProcedureParameter.ProcedureParameter((src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.IsVarying), (src.Modifier), (src.Nullable |> Option.ofObj |> Option.map (fun x -> NullableConstraintDefinition.FromCs(x, fragmentMapping))), (src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.VariableName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.ProcedureReference |> Option.ofObj |> Option.map (fun x -> ProcedureReference.FromCs(x, fragmentMapping))), (src.StatementList |> Option.ofObj |> Option.map (fun x -> StatementList.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.CreateProcedureStatement as src->
          ProcedureStatementBodyBase.ProcedureStatementBody((ProcedureStatementBody.CreateProcedureStatement((src.IsForReplication), (src.MethodSpecifier |> Option.ofObj |> Option.map (fun x -> MethodSpecifier.FromCs(x, fragmentMapping))), (src.Options |> Seq.map (fun x -> ProcedureOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Parameters |> Seq.map (fun src -> ProcedureParameter.ProcedureParameter((src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.IsVarying), (src.Modifier), (src.Nullable |> Option.ofObj |> Option.map (fun x -> NullableConstraintDefinition.FromCs(x, fragmentMapping))), (src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.VariableName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.ProcedureReference |> Option.ofObj |> Option.map (fun x -> ProcedureReference.FromCs(x, fragmentMapping))), (src.StatementList |> Option.ofObj |> Option.map (fun x -> StatementList.FromCs(x, fragmentMapping))))  ))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] QueueStatement = (* IsAbstract = true *)
  | AlterQueueStatement of Name:SchemaObjectName option * QueueOptions:(QueueOption) list
  | CreateQueueStatement of Name:SchemaObjectName option * OnFileGroup:IdentifierOrValueExpression option * QueueOptions:(QueueOption) list
  member this.ToCs() : ScriptDom.QueueStatement =
    match this with
    | AlterQueueStatement(Name=aName; QueueOptions=aQueueOptions) ->
      let ret = ScriptDom.AlterQueueStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aQueueOptions do ret.QueueOptions.Add (e.ToCs())
      ret :> ScriptDom.QueueStatement (* 335 *)
    | CreateQueueStatement(Name=aName; OnFileGroup=aOnFileGroup; QueueOptions=aQueueOptions) ->
      let ret = ScriptDom.CreateQueueStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OnFileGroup <- aOnFileGroup |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aQueueOptions do ret.QueueOptions.Add (e.ToCs())
      ret :> ScriptDom.QueueStatement (* 335 *)
  static member FromCs(src:ScriptDom.QueueStatement, fragmentMapping:FragmentMapping) : QueueStatement =
    let ret =
      match src with
      | :? ScriptDom.AlterQueueStatement as src ->
        QueueStatement.AlterQueueStatement((src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.QueueOptions |> Seq.map (fun x -> QueueOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.CreateQueueStatement as src ->
        QueueStatement.CreateQueueStatement((src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.OnFileGroup |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))),(src.QueueOptions |> Seq.map (fun x -> QueueOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] RemoteServiceBindingStatementBase = (* IsAbstract = true *)
  | AlterRemoteServiceBindingStatement of Name:Identifier option * Options:(RemoteServiceBindingOption) list
  | CreateRemoteServiceBindingStatement of Name:Identifier option * Options:(RemoteServiceBindingOption) list * Owner:Identifier option * Service:Literal option
  member this.ToCs() : ScriptDom.RemoteServiceBindingStatementBase =
    match this with
    | AlterRemoteServiceBindingStatement(Name=aName; Options=aOptions) ->
      let ret = ScriptDom.AlterRemoteServiceBindingStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.RemoteServiceBindingStatementBase (* 335 *)
    | CreateRemoteServiceBindingStatement(Name=aName; Options=aOptions; Owner=aOwner; Service=aService) ->
      let ret = ScriptDom.CreateRemoteServiceBindingStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.Owner <- aOwner |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Service <- aService |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.RemoteServiceBindingStatementBase (* 335 *)
  static member FromCs(src:ScriptDom.RemoteServiceBindingStatementBase, fragmentMapping:FragmentMapping) : RemoteServiceBindingStatementBase =
    let ret =
      match src with
      | :? ScriptDom.AlterRemoteServiceBindingStatement as src ->
        RemoteServiceBindingStatementBase.AlterRemoteServiceBindingStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Options |> Seq.map (fun x -> RemoteServiceBindingOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.CreateRemoteServiceBindingStatement as src ->
        RemoteServiceBindingStatementBase.CreateRemoteServiceBindingStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Options |> Seq.map (fun x -> RemoteServiceBindingOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Owner |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Service |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ResourcePoolStatement = (* IsAbstract = false *)
  | Base of Name:Identifier option * ResourcePoolParameters:(ResourcePoolParameter) list
  | AlterResourcePoolStatement of Name:Identifier option * ResourcePoolParameters:(ResourcePoolParameter) list
  | CreateResourcePoolStatement of Name:Identifier option * ResourcePoolParameters:(ResourcePoolParameter) list
  member this.ToCs() : ScriptDom.ResourcePoolStatement =
    match this with
    | AlterResourcePoolStatement(Name=aName; ResourcePoolParameters=aResourcePoolParameters) ->
      let ret = ScriptDom.AlterResourcePoolStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aResourcePoolParameters do ret.ResourcePoolParameters.Add (e.ToCs())
      ret :> ScriptDom.ResourcePoolStatement (* 335 *)
    | CreateResourcePoolStatement(Name=aName; ResourcePoolParameters=aResourcePoolParameters) ->
      let ret = ScriptDom.CreateResourcePoolStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aResourcePoolParameters do ret.ResourcePoolParameters.Add (e.ToCs())
      ret :> ScriptDom.ResourcePoolStatement (* 335 *)
    | Base(Name=aName; ResourcePoolParameters=aResourcePoolParameters) ->

      let ret = ScriptDom.ResourcePoolStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aResourcePoolParameters do ret.ResourcePoolParameters.Add (e.ToCs())
      ret
  static member FromCs(src:ScriptDom.ResourcePoolStatement, fragmentMapping:FragmentMapping) : ResourcePoolStatement =
    let ret =
      match src with
      | :? ScriptDom.AlterResourcePoolStatement as src ->
        ResourcePoolStatement.AlterResourcePoolStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.ResourcePoolParameters |> Seq.map (fun src -> ResourcePoolParameter.ResourcePoolParameter((src.AffinitySpecification |> Option.ofObj |> Option.map (fun x -> ResourcePoolAffinitySpecification.FromCs(x, fragmentMapping))), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq))
      | :? ScriptDom.CreateResourcePoolStatement as src ->
        ResourcePoolStatement.CreateResourcePoolStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.ResourcePoolParameters |> Seq.map (fun src -> ResourcePoolParameter.ResourcePoolParameter((src.AffinitySpecification |> Option.ofObj |> Option.map (fun x -> ResourcePoolAffinitySpecification.FromCs(x, fragmentMapping))), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq))
      | _ -> (* :? ScriptDom.ResourcePoolStatement as src *)
        ResourcePoolStatement.Base(((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ResourcePoolParameters |> Seq.map (fun src -> ResourcePoolParameter.ResourcePoolParameter((src.AffinitySpecification |> Option.ofObj |> Option.map (fun x -> ResourcePoolAffinitySpecification.FromCs(x, fragmentMapping))), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] RoleStatement = (* IsAbstract = true *)
  | AlterRoleStatement of AlterRoleStatement
  | CreateRoleStatement of CreateRoleStatement
  member this.ToCs() : ScriptDom.RoleStatement =
    match this with
    | AlterRoleStatement(x) -> x.ToCs() :> ScriptDom.RoleStatement (* 345 *)
    | CreateRoleStatement(x) -> x.ToCs() :> ScriptDom.RoleStatement (* 345 *)
  static member FromCs(src:ScriptDom.RoleStatement, fragmentMapping:FragmentMapping) : RoleStatement =
    let ret =
      match src with
      | :? ScriptDom.AlterRoleStatement as src ->
        match src with
        | :? ScriptDom.AlterServerRoleStatement as src->
          RoleStatement.AlterRoleStatement((AlterRoleStatement.AlterServerRoleStatement((src.Action |> Option.ofObj |> Option.map (fun x -> AlterRoleAction.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | _ -> (* :? ScriptDom.AlterRoleStatement as src *)
          RoleStatement.AlterRoleStatement((AlterRoleStatement.Base((src.Action |> Option.ofObj |> Option.map (fun x -> AlterRoleAction.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))))
      | :? ScriptDom.CreateRoleStatement as src ->
        match src with
        | :? ScriptDom.CreateServerRoleStatement as src->
          RoleStatement.CreateRoleStatement((CreateRoleStatement.CreateServerRoleStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Owner |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  ))
        | _ -> (* :? ScriptDom.CreateRoleStatement as src *)
          RoleStatement.CreateRoleStatement((CreateRoleStatement.Base((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Owner |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] RouteStatement = (* IsAbstract = true *)
  | AlterRouteStatement of Name:Identifier option * RouteOptions:(RouteOption) list
  | CreateRouteStatement of Name:Identifier option * Owner:Identifier option * RouteOptions:(RouteOption) list
  member this.ToCs() : ScriptDom.RouteStatement =
    match this with
    | AlterRouteStatement(Name=aName; RouteOptions=aRouteOptions) ->
      let ret = ScriptDom.AlterRouteStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aRouteOptions do ret.RouteOptions.Add (e.ToCs())
      ret :> ScriptDom.RouteStatement (* 335 *)
    | CreateRouteStatement(Name=aName; Owner=aOwner; RouteOptions=aRouteOptions) ->
      let ret = ScriptDom.CreateRouteStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Owner <- aOwner |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aRouteOptions do ret.RouteOptions.Add (e.ToCs())
      ret :> ScriptDom.RouteStatement (* 335 *)
  static member FromCs(src:ScriptDom.RouteStatement, fragmentMapping:FragmentMapping) : RouteStatement =
    let ret =
      match src with
      | :? ScriptDom.AlterRouteStatement as src ->
        RouteStatement.AlterRouteStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.RouteOptions |> Seq.map (fun src -> RouteOption.RouteOption((src.Literal |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.OptionKind))) |> List.ofSeq))
      | :? ScriptDom.CreateRouteStatement as src ->
        RouteStatement.CreateRouteStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Owner |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.RouteOptions |> Seq.map (fun src -> RouteOption.RouteOption((src.Literal |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.OptionKind))) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] SecurityPolicyStatement = (* IsAbstract = true *)
  | AlterSecurityPolicyStatement of ActionType:ScriptDom.SecurityPolicyActionType * Name:SchemaObjectName option * NotForReplication:bool * SecurityPolicyOptions:(SecurityPolicyOption) list * SecurityPredicateActions:(SecurityPredicateAction) list
  | CreateSecurityPolicyStatement of ActionType:ScriptDom.SecurityPolicyActionType * Name:SchemaObjectName option * NotForReplication:bool * SecurityPolicyOptions:(SecurityPolicyOption) list * SecurityPredicateActions:(SecurityPredicateAction) list
  member this.ToCs() : ScriptDom.SecurityPolicyStatement =
    match this with
    | AlterSecurityPolicyStatement(ActionType=aActionType; Name=aName; NotForReplication=aNotForReplication; SecurityPolicyOptions=aSecurityPolicyOptions; SecurityPredicateActions=aSecurityPredicateActions) ->
      let ret = ScriptDom.AlterSecurityPolicyStatement()
      ret.ActionType <- aActionType
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.NotForReplication <- aNotForReplication
      for e in aSecurityPolicyOptions do ret.SecurityPolicyOptions.Add (e.ToCs())
      for e in aSecurityPredicateActions do ret.SecurityPredicateActions.Add (e.ToCs())
      ret :> ScriptDom.SecurityPolicyStatement (* 335 *)
    | CreateSecurityPolicyStatement(ActionType=aActionType; Name=aName; NotForReplication=aNotForReplication; SecurityPolicyOptions=aSecurityPolicyOptions; SecurityPredicateActions=aSecurityPredicateActions) ->
      let ret = ScriptDom.CreateSecurityPolicyStatement()
      ret.ActionType <- aActionType
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.NotForReplication <- aNotForReplication
      for e in aSecurityPolicyOptions do ret.SecurityPolicyOptions.Add (e.ToCs())
      for e in aSecurityPredicateActions do ret.SecurityPredicateActions.Add (e.ToCs())
      ret :> ScriptDom.SecurityPolicyStatement (* 335 *)
  static member FromCs(src:ScriptDom.SecurityPolicyStatement, fragmentMapping:FragmentMapping) : SecurityPolicyStatement =
    let ret =
      match src with
      | :? ScriptDom.AlterSecurityPolicyStatement as src ->
        SecurityPolicyStatement.AlterSecurityPolicyStatement((src.ActionType),(src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.NotForReplication),(src.SecurityPolicyOptions |> Seq.map (fun src -> SecurityPolicyOption.SecurityPolicyOption((src.OptionKind), (src.OptionState))) |> List.ofSeq),(src.SecurityPredicateActions |> Seq.map (fun src -> SecurityPredicateAction.SecurityPredicateAction((src.ActionType), (src.FunctionCall |> Option.ofObj |> Option.map (fun x -> FunctionCall.FromCs(x, fragmentMapping))), (src.SecurityPredicateOperation), (src.SecurityPredicateType), (src.TargetObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))) |> List.ofSeq))
      | :? ScriptDom.CreateSecurityPolicyStatement as src ->
        SecurityPolicyStatement.CreateSecurityPolicyStatement((src.ActionType),(src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.NotForReplication),(src.SecurityPolicyOptions |> Seq.map (fun src -> SecurityPolicyOption.SecurityPolicyOption((src.OptionKind), (src.OptionState))) |> List.ofSeq),(src.SecurityPredicateActions |> Seq.map (fun src -> SecurityPredicateAction.SecurityPredicateAction((src.ActionType), (src.FunctionCall |> Option.ofObj |> Option.map (fun x -> FunctionCall.FromCs(x, fragmentMapping))), (src.SecurityPredicateOperation), (src.SecurityPredicateType), (src.TargetObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] SecurityStatement = (* IsAbstract = true *)
  | DenyStatement of AsClause:Identifier option * CascadeOption:bool * Permissions:(Permission) list * Principals:(SecurityPrincipal) list * SecurityTargetObject:SecurityTargetObject option
  | GrantStatement of AsClause:Identifier option * Permissions:(Permission) list * Principals:(SecurityPrincipal) list * SecurityTargetObject:SecurityTargetObject option * WithGrantOption:bool
  | RevokeStatement of AsClause:Identifier option * CascadeOption:bool * GrantOptionFor:bool * Permissions:(Permission) list * Principals:(SecurityPrincipal) list * SecurityTargetObject:SecurityTargetObject option
  member this.ToCs() : ScriptDom.SecurityStatement =
    match this with
    | DenyStatement(AsClause=aAsClause; CascadeOption=aCascadeOption; Permissions=aPermissions; Principals=aPrincipals; SecurityTargetObject=aSecurityTargetObject) ->
      let ret = ScriptDom.DenyStatement()
      ret.AsClause <- aAsClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.CascadeOption <- aCascadeOption
      for e in aPermissions do ret.Permissions.Add (e.ToCs())
      for e in aPrincipals do ret.Principals.Add (e.ToCs())
      ret.SecurityTargetObject <- aSecurityTargetObject |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SecurityStatement (* 335 *)
    | GrantStatement(AsClause=aAsClause; Permissions=aPermissions; Principals=aPrincipals; SecurityTargetObject=aSecurityTargetObject; WithGrantOption=aWithGrantOption) ->
      let ret = ScriptDom.GrantStatement()
      ret.AsClause <- aAsClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aPermissions do ret.Permissions.Add (e.ToCs())
      for e in aPrincipals do ret.Principals.Add (e.ToCs())
      ret.SecurityTargetObject <- aSecurityTargetObject |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WithGrantOption <- aWithGrantOption
      ret :> ScriptDom.SecurityStatement (* 335 *)
    | RevokeStatement(AsClause=aAsClause; CascadeOption=aCascadeOption; GrantOptionFor=aGrantOptionFor; Permissions=aPermissions; Principals=aPrincipals; SecurityTargetObject=aSecurityTargetObject) ->
      let ret = ScriptDom.RevokeStatement()
      ret.AsClause <- aAsClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.CascadeOption <- aCascadeOption
      ret.GrantOptionFor <- aGrantOptionFor
      for e in aPermissions do ret.Permissions.Add (e.ToCs())
      for e in aPrincipals do ret.Principals.Add (e.ToCs())
      ret.SecurityTargetObject <- aSecurityTargetObject |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SecurityStatement (* 335 *)
  static member FromCs(src:ScriptDom.SecurityStatement, fragmentMapping:FragmentMapping) : SecurityStatement =
    let ret =
      match src with
      | :? ScriptDom.DenyStatement as src ->
        SecurityStatement.DenyStatement((src.AsClause |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.CascadeOption),(src.Permissions |> Seq.map (fun src -> Permission.Permission((src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Identifiers |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq))) |> List.ofSeq),(src.Principals |> Seq.map (fun src -> SecurityPrincipal.SecurityPrincipal((src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.PrincipalType))) |> List.ofSeq),(src.SecurityTargetObject |> Option.ofObj |> Option.map (fun x -> SecurityTargetObject.FromCs(x, fragmentMapping))))
      | :? ScriptDom.GrantStatement as src ->
        SecurityStatement.GrantStatement((src.AsClause |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Permissions |> Seq.map (fun src -> Permission.Permission((src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Identifiers |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq))) |> List.ofSeq),(src.Principals |> Seq.map (fun src -> SecurityPrincipal.SecurityPrincipal((src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.PrincipalType))) |> List.ofSeq),(src.SecurityTargetObject |> Option.ofObj |> Option.map (fun x -> SecurityTargetObject.FromCs(x, fragmentMapping))),(src.WithGrantOption))
      | :? ScriptDom.RevokeStatement as src ->
        SecurityStatement.RevokeStatement((src.AsClause |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.CascadeOption),(src.GrantOptionFor),(src.Permissions |> Seq.map (fun src -> Permission.Permission((src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Identifiers |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq))) |> List.ofSeq),(src.Principals |> Seq.map (fun src -> SecurityPrincipal.SecurityPrincipal((src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.PrincipalType))) |> List.ofSeq),(src.SecurityTargetObject |> Option.ofObj |> Option.map (fun x -> SecurityTargetObject.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] SecurityStatementBody80 = (* IsAbstract = true *)
  | DenyStatement80 of CascadeOption:bool * SecurityElement80:SecurityElement80 option * SecurityUserClause80:SecurityUserClause80 option
  | GrantStatement80 of AsClause:Identifier option * SecurityElement80:SecurityElement80 option * SecurityUserClause80:SecurityUserClause80 option * WithGrantOption:bool
  | RevokeStatement80 of AsClause:Identifier option * CascadeOption:bool * GrantOptionFor:bool * SecurityElement80:SecurityElement80 option * SecurityUserClause80:SecurityUserClause80 option
  member this.ToCs() : ScriptDom.SecurityStatementBody80 =
    match this with
    | DenyStatement80(CascadeOption=aCascadeOption; SecurityElement80=aSecurityElement80; SecurityUserClause80=aSecurityUserClause80) ->
      let ret = ScriptDom.DenyStatement80()
      ret.CascadeOption <- aCascadeOption
      ret.SecurityElement80 <- aSecurityElement80 |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SecurityUserClause80 <- aSecurityUserClause80 |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SecurityStatementBody80 (* 335 *)
    | GrantStatement80(AsClause=aAsClause; SecurityElement80=aSecurityElement80; SecurityUserClause80=aSecurityUserClause80; WithGrantOption=aWithGrantOption) ->
      let ret = ScriptDom.GrantStatement80()
      ret.AsClause <- aAsClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SecurityElement80 <- aSecurityElement80 |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SecurityUserClause80 <- aSecurityUserClause80 |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WithGrantOption <- aWithGrantOption
      ret :> ScriptDom.SecurityStatementBody80 (* 335 *)
    | RevokeStatement80(AsClause=aAsClause; CascadeOption=aCascadeOption; GrantOptionFor=aGrantOptionFor; SecurityElement80=aSecurityElement80; SecurityUserClause80=aSecurityUserClause80) ->
      let ret = ScriptDom.RevokeStatement80()
      ret.AsClause <- aAsClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.CascadeOption <- aCascadeOption
      ret.GrantOptionFor <- aGrantOptionFor
      ret.SecurityElement80 <- aSecurityElement80 |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SecurityUserClause80 <- aSecurityUserClause80 |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SecurityStatementBody80 (* 335 *)
  static member FromCs(src:ScriptDom.SecurityStatementBody80, fragmentMapping:FragmentMapping) : SecurityStatementBody80 =
    let ret =
      match src with
      | :? ScriptDom.DenyStatement80 as src ->
        SecurityStatementBody80.DenyStatement80((src.CascadeOption),(src.SecurityElement80 |> Option.ofObj |> Option.map (fun x -> SecurityElement80.FromCs(x, fragmentMapping))),(src.SecurityUserClause80 |> Option.ofObj |> Option.map (fun x -> SecurityUserClause80.FromCs(x, fragmentMapping))))
      | :? ScriptDom.GrantStatement80 as src ->
        SecurityStatementBody80.GrantStatement80((src.AsClause |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.SecurityElement80 |> Option.ofObj |> Option.map (fun x -> SecurityElement80.FromCs(x, fragmentMapping))),(src.SecurityUserClause80 |> Option.ofObj |> Option.map (fun x -> SecurityUserClause80.FromCs(x, fragmentMapping))),(src.WithGrantOption))
      | :? ScriptDom.RevokeStatement80 as src ->
        SecurityStatementBody80.RevokeStatement80((src.AsClause |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.CascadeOption),(src.GrantOptionFor),(src.SecurityElement80 |> Option.ofObj |> Option.map (fun x -> SecurityElement80.FromCs(x, fragmentMapping))),(src.SecurityUserClause80 |> Option.ofObj |> Option.map (fun x -> SecurityUserClause80.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] SensitivityClassificationStatement = (* IsAbstract = true *)
  | AddSensitivityClassificationStatement of Columns:(ColumnReferenceExpression) list * Options:(SensitivityClassificationOption) list
  | DropSensitivityClassificationStatement of Columns:(ColumnReferenceExpression) list
  member this.ToCs() : ScriptDom.SensitivityClassificationStatement =
    match this with
    | AddSensitivityClassificationStatement(Columns=aColumns; Options=aOptions) ->
      let ret = ScriptDom.AddSensitivityClassificationStatement()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.SensitivityClassificationStatement (* 335 *)
    | DropSensitivityClassificationStatement(Columns=aColumns) ->
      let ret = ScriptDom.DropSensitivityClassificationStatement()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret :> ScriptDom.SensitivityClassificationStatement (* 335 *)
  static member FromCs(src:ScriptDom.SensitivityClassificationStatement, fragmentMapping:FragmentMapping) : SensitivityClassificationStatement =
    let ret =
      match src with
      | :? ScriptDom.AddSensitivityClassificationStatement as src ->
        SensitivityClassificationStatement.AddSensitivityClassificationStatement((src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.Options |> Seq.map (fun src -> SensitivityClassificationOption.SensitivityClassificationOption((src.Type), (src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq))
      | :? ScriptDom.DropSensitivityClassificationStatement as src ->
        SensitivityClassificationStatement.DropSensitivityClassificationStatement((src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] SequenceStatement = (* IsAbstract = true *)
  | AlterSequenceStatement of Name:SchemaObjectName option * SequenceOptions:(SequenceOption) list
  | CreateSequenceStatement of Name:SchemaObjectName option * SequenceOptions:(SequenceOption) list
  member this.ToCs() : ScriptDom.SequenceStatement =
    match this with
    | AlterSequenceStatement(Name=aName; SequenceOptions=aSequenceOptions) ->
      let ret = ScriptDom.AlterSequenceStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aSequenceOptions do ret.SequenceOptions.Add (e.ToCs())
      ret :> ScriptDom.SequenceStatement (* 335 *)
    | CreateSequenceStatement(Name=aName; SequenceOptions=aSequenceOptions) ->
      let ret = ScriptDom.CreateSequenceStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aSequenceOptions do ret.SequenceOptions.Add (e.ToCs())
      ret :> ScriptDom.SequenceStatement (* 335 *)
  static member FromCs(src:ScriptDom.SequenceStatement, fragmentMapping:FragmentMapping) : SequenceStatement =
    let ret =
      match src with
      | :? ScriptDom.AlterSequenceStatement as src ->
        SequenceStatement.AlterSequenceStatement((src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.SequenceOptions |> Seq.map (fun x -> SequenceOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.CreateSequenceStatement as src ->
        SequenceStatement.CreateSequenceStatement((src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.SequenceOptions |> Seq.map (fun x -> SequenceOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ServerAuditStatement = (* IsAbstract = true *)
  | AlterServerAuditStatement of AuditName:Identifier option * AuditTarget:AuditTarget option * NewName:Identifier option * Options:(AuditOption) list * PredicateExpression:BooleanExpression option * RemoveWhere:bool
  | CreateServerAuditStatement of AuditName:Identifier option * AuditTarget:AuditTarget option * Options:(AuditOption) list * PredicateExpression:BooleanExpression option
  member this.ToCs() : ScriptDom.ServerAuditStatement =
    match this with
    | AlterServerAuditStatement(AuditName=aAuditName; AuditTarget=aAuditTarget; NewName=aNewName; Options=aOptions; PredicateExpression=aPredicateExpression; RemoveWhere=aRemoveWhere) ->
      let ret = ScriptDom.AlterServerAuditStatement()
      ret.AuditName <- aAuditName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.AuditTarget <- aAuditTarget |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.NewName <- aNewName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.PredicateExpression <- aPredicateExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.RemoveWhere <- aRemoveWhere
      ret :> ScriptDom.ServerAuditStatement (* 335 *)
    | CreateServerAuditStatement(AuditName=aAuditName; AuditTarget=aAuditTarget; Options=aOptions; PredicateExpression=aPredicateExpression) ->
      let ret = ScriptDom.CreateServerAuditStatement()
      ret.AuditName <- aAuditName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.AuditTarget <- aAuditTarget |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.PredicateExpression <- aPredicateExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ServerAuditStatement (* 335 *)
  static member FromCs(src:ScriptDom.ServerAuditStatement, fragmentMapping:FragmentMapping) : ServerAuditStatement =
    let ret =
      match src with
      | :? ScriptDom.AlterServerAuditStatement as src ->
        ServerAuditStatement.AlterServerAuditStatement((src.AuditName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.AuditTarget |> Option.ofObj |> Option.map (fun x -> AuditTarget.FromCs(x, fragmentMapping))),(src.NewName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Options |> Seq.map (fun x -> AuditOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.PredicateExpression |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))),(src.RemoveWhere))
      | :? ScriptDom.CreateServerAuditStatement as src ->
        ServerAuditStatement.CreateServerAuditStatement((src.AuditName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.AuditTarget |> Option.ofObj |> Option.map (fun x -> AuditTarget.FromCs(x, fragmentMapping))),(src.Options |> Seq.map (fun x -> AuditOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.PredicateExpression |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] SetOnOffStatement = (* IsAbstract = true *)
  | PredicateSetStatement of IsOn:bool * Options:ScriptDom.SetOptions
  | SetIdentityInsertStatement of IsOn:bool * Table:SchemaObjectName option
  | SetOffsetsStatement of IsOn:bool * Options:ScriptDom.SetOffsets
  | SetStatisticsStatement of IsOn:bool * Options:ScriptDom.SetStatisticsOptions
  member this.ToCs() : ScriptDom.SetOnOffStatement =
    match this with
    | PredicateSetStatement(IsOn=aIsOn; Options=aOptions) ->
      let ret = ScriptDom.PredicateSetStatement()
      ret.IsOn <- aIsOn
      ret.Options <- aOptions
      ret :> ScriptDom.SetOnOffStatement (* 335 *)
    | SetIdentityInsertStatement(IsOn=aIsOn; Table=aTable) ->
      let ret = ScriptDom.SetIdentityInsertStatement()
      ret.IsOn <- aIsOn
      ret.Table <- aTable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SetOnOffStatement (* 335 *)
    | SetOffsetsStatement(IsOn=aIsOn; Options=aOptions) ->
      let ret = ScriptDom.SetOffsetsStatement()
      ret.IsOn <- aIsOn
      ret.Options <- aOptions
      ret :> ScriptDom.SetOnOffStatement (* 335 *)
    | SetStatisticsStatement(IsOn=aIsOn; Options=aOptions) ->
      let ret = ScriptDom.SetStatisticsStatement()
      ret.IsOn <- aIsOn
      ret.Options <- aOptions
      ret :> ScriptDom.SetOnOffStatement (* 335 *)
  static member FromCs(src:ScriptDom.SetOnOffStatement, fragmentMapping:FragmentMapping) : SetOnOffStatement =
    let ret =
      match src with
      | :? ScriptDom.PredicateSetStatement as src ->
        SetOnOffStatement.PredicateSetStatement((src.IsOn),(src.Options))
      | :? ScriptDom.SetIdentityInsertStatement as src ->
        SetOnOffStatement.SetIdentityInsertStatement((src.IsOn),(src.Table |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.SetOffsetsStatement as src ->
        SetOnOffStatement.SetOffsetsStatement((src.IsOn),(src.Options))
      | :? ScriptDom.SetStatisticsStatement as src ->
        SetOnOffStatement.SetStatisticsStatement((src.IsOn),(src.Options))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] SignatureStatementBase = (* IsAbstract = true *)
  | AddSignatureStatement of Cryptos:(CryptoMechanism) list * Element:SchemaObjectName option * ElementKind:ScriptDom.SignableElementKind * IsCounter:bool
  | DropSignatureStatement of Cryptos:(CryptoMechanism) list * Element:SchemaObjectName option * ElementKind:ScriptDom.SignableElementKind * IsCounter:bool
  member this.ToCs() : ScriptDom.SignatureStatementBase =
    match this with
    | AddSignatureStatement(Cryptos=aCryptos; Element=aElement; ElementKind=aElementKind; IsCounter=aIsCounter) ->
      let ret = ScriptDom.AddSignatureStatement()
      for e in aCryptos do ret.Cryptos.Add (e.ToCs())
      ret.Element <- aElement |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ElementKind <- aElementKind
      ret.IsCounter <- aIsCounter
      ret :> ScriptDom.SignatureStatementBase (* 335 *)
    | DropSignatureStatement(Cryptos=aCryptos; Element=aElement; ElementKind=aElementKind; IsCounter=aIsCounter) ->
      let ret = ScriptDom.DropSignatureStatement()
      for e in aCryptos do ret.Cryptos.Add (e.ToCs())
      ret.Element <- aElement |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ElementKind <- aElementKind
      ret.IsCounter <- aIsCounter
      ret :> ScriptDom.SignatureStatementBase (* 335 *)
  static member FromCs(src:ScriptDom.SignatureStatementBase, fragmentMapping:FragmentMapping) : SignatureStatementBase =
    let ret =
      match src with
      | :? ScriptDom.AddSignatureStatement as src ->
        SignatureStatementBase.AddSignatureStatement((src.Cryptos |> Seq.map (fun src -> CryptoMechanism.CryptoMechanism((src.CryptoMechanismType), (src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.PasswordOrSignature |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.Element |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.ElementKind),(src.IsCounter))
      | :? ScriptDom.DropSignatureStatement as src ->
        SignatureStatementBase.DropSignatureStatement((src.Cryptos |> Seq.map (fun src -> CryptoMechanism.CryptoMechanism((src.CryptoMechanismType), (src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.PasswordOrSignature |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.Element |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.ElementKind),(src.IsCounter))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] StatementWithCtesAndXmlNamespaces = (* IsAbstract = true *)
  | DataModificationStatement of DataModificationStatement
  | SelectStatement of SelectStatement
  member this.ToCs() : ScriptDom.StatementWithCtesAndXmlNamespaces =
    match this with
    | DataModificationStatement(x) -> x.ToCs() :> ScriptDom.StatementWithCtesAndXmlNamespaces (* 345 *)
    | SelectStatement(x) -> x.ToCs() :> ScriptDom.StatementWithCtesAndXmlNamespaces (* 345 *)
  static member FromCs(src:ScriptDom.StatementWithCtesAndXmlNamespaces, fragmentMapping:FragmentMapping) : StatementWithCtesAndXmlNamespaces =
    let ret =
      match src with
      | :? ScriptDom.DataModificationStatement as src ->
        match src with
        | :? ScriptDom.DeleteStatement as src->
          StatementWithCtesAndXmlNamespaces.DataModificationStatement((DataModificationStatement.DeleteStatement((src.DeleteSpecification |> Option.ofObj |> Option.map (fun x -> DeleteSpecification.FromCs(x, fragmentMapping))), (src.OptimizerHints |> Seq.map (fun x -> OptimizerHint.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.WithCtesAndXmlNamespaces |> Option.ofObj |> Option.map (fun x -> WithCtesAndXmlNamespaces.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.InsertStatement as src->
          StatementWithCtesAndXmlNamespaces.DataModificationStatement((DataModificationStatement.InsertStatement((src.InsertSpecification |> Option.ofObj |> Option.map (fun x -> InsertSpecification.FromCs(x, fragmentMapping))), (src.OptimizerHints |> Seq.map (fun x -> OptimizerHint.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.WithCtesAndXmlNamespaces |> Option.ofObj |> Option.map (fun x -> WithCtesAndXmlNamespaces.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.MergeStatement as src->
          StatementWithCtesAndXmlNamespaces.DataModificationStatement((DataModificationStatement.MergeStatement((src.MergeSpecification |> Option.ofObj |> Option.map (fun x -> MergeSpecification.FromCs(x, fragmentMapping))), (src.OptimizerHints |> Seq.map (fun x -> OptimizerHint.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.WithCtesAndXmlNamespaces |> Option.ofObj |> Option.map (fun x -> WithCtesAndXmlNamespaces.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.UpdateStatement as src->
          StatementWithCtesAndXmlNamespaces.DataModificationStatement((DataModificationStatement.UpdateStatement((src.OptimizerHints |> Seq.map (fun x -> OptimizerHint.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.UpdateSpecification |> Option.ofObj |> Option.map (fun x -> UpdateSpecification.FromCs(x, fragmentMapping))), (src.WithCtesAndXmlNamespaces |> Option.ofObj |> Option.map (fun x -> WithCtesAndXmlNamespaces.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.SelectStatement as src ->
        match src with
        | :? ScriptDom.SelectStatementSnippet as src->
          StatementWithCtesAndXmlNamespaces.SelectStatement((SelectStatement.SelectStatementSnippet((src.ComputeClauses |> Seq.map (fun src -> ComputeClause.ComputeClause((src.ByExpressions |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.ComputeFunctions |> Seq.map (fun src -> ComputeFunction.ComputeFunction((src.ComputeFunctionType), (src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq))) |> List.ofSeq), (src.Into |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.On |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.OptimizerHints |> Seq.map (fun x -> OptimizerHint.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.QueryExpression |> Option.ofObj |> Option.map (fun x -> QueryExpression.FromCs(x, fragmentMapping))), (Option.ofObj (src.Script)), (src.WithCtesAndXmlNamespaces |> Option.ofObj |> Option.map (fun x -> WithCtesAndXmlNamespaces.FromCs(x, fragmentMapping))))  ))
        | _ -> (* :? ScriptDom.SelectStatement as src *)
          StatementWithCtesAndXmlNamespaces.SelectStatement((SelectStatement.Base((src.ComputeClauses |> Seq.map (fun src -> ComputeClause.ComputeClause((src.ByExpressions |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.ComputeFunctions |> Seq.map (fun src -> ComputeFunction.ComputeFunction((src.ComputeFunctionType), (src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq))) |> List.ofSeq), (src.Into |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.On |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.OptimizerHints |> Seq.map (fun x -> OptimizerHint.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.QueryExpression |> Option.ofObj |> Option.map (fun x -> QueryExpression.FromCs(x, fragmentMapping))), (src.WithCtesAndXmlNamespaces |> Option.ofObj |> Option.map (fun x -> WithCtesAndXmlNamespaces.FromCs(x, fragmentMapping))))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] SymmetricKeyStatement = (* IsAbstract = true *)
  | AlterSymmetricKeyStatement of EncryptingMechanisms:(CryptoMechanism) list * IsAdd:bool * Name:Identifier option
  | CreateSymmetricKeyStatement of EncryptingMechanisms:(CryptoMechanism) list * KeyOptions:(KeyOption) list * Name:Identifier option * Owner:Identifier option * Provider:Identifier option
  member this.ToCs() : ScriptDom.SymmetricKeyStatement =
    match this with
    | AlterSymmetricKeyStatement(EncryptingMechanisms=aEncryptingMechanisms; IsAdd=aIsAdd; Name=aName) ->
      let ret = ScriptDom.AlterSymmetricKeyStatement()
      for e in aEncryptingMechanisms do ret.EncryptingMechanisms.Add (e.ToCs())
      ret.IsAdd <- aIsAdd
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SymmetricKeyStatement (* 335 *)
    | CreateSymmetricKeyStatement(EncryptingMechanisms=aEncryptingMechanisms; KeyOptions=aKeyOptions; Name=aName; Owner=aOwner; Provider=aProvider) ->
      let ret = ScriptDom.CreateSymmetricKeyStatement()
      for e in aEncryptingMechanisms do ret.EncryptingMechanisms.Add (e.ToCs())
      for e in aKeyOptions do ret.KeyOptions.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Owner <- aOwner |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Provider <- aProvider |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SymmetricKeyStatement (* 335 *)
  static member FromCs(src:ScriptDom.SymmetricKeyStatement, fragmentMapping:FragmentMapping) : SymmetricKeyStatement =
    let ret =
      match src with
      | :? ScriptDom.AlterSymmetricKeyStatement as src ->
        SymmetricKeyStatement.AlterSymmetricKeyStatement((src.EncryptingMechanisms |> Seq.map (fun src -> CryptoMechanism.CryptoMechanism((src.CryptoMechanismType), (src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.PasswordOrSignature |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.IsAdd),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CreateSymmetricKeyStatement as src ->
        SymmetricKeyStatement.CreateSymmetricKeyStatement((src.EncryptingMechanisms |> Seq.map (fun src -> CryptoMechanism.CryptoMechanism((src.CryptoMechanismType), (src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.PasswordOrSignature |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.KeyOptions |> Seq.map (fun x -> KeyOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Owner |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Provider |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] TextModificationStatement = (* IsAbstract = true *)
  | UpdateTextStatement of Bulk:bool * Column:ColumnReferenceExpression option * DeleteLength:ScalarExpression option * InsertOffset:ScalarExpression option * SourceColumn:ColumnReferenceExpression option * SourceParameter:ValueExpression option * TextId:ValueExpression option * Timestamp:Literal option * WithLog:bool
  | WriteTextStatement of Bulk:bool * Column:ColumnReferenceExpression option * SourceParameter:ValueExpression option * TextId:ValueExpression option * Timestamp:Literal option * WithLog:bool
  member this.ToCs() : ScriptDom.TextModificationStatement =
    match this with
    | UpdateTextStatement(Bulk=aBulk; Column=aColumn; DeleteLength=aDeleteLength; InsertOffset=aInsertOffset; SourceColumn=aSourceColumn; SourceParameter=aSourceParameter; TextId=aTextId; Timestamp=aTimestamp; WithLog=aWithLog) ->
      let ret = ScriptDom.UpdateTextStatement()
      ret.Bulk <- aBulk
      ret.Column <- aColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DeleteLength <- aDeleteLength |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.InsertOffset <- aInsertOffset |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SourceColumn <- aSourceColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SourceParameter <- aSourceParameter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TextId <- aTextId |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Timestamp <- aTimestamp |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WithLog <- aWithLog
      ret :> ScriptDom.TextModificationStatement (* 335 *)
    | WriteTextStatement(Bulk=aBulk; Column=aColumn; SourceParameter=aSourceParameter; TextId=aTextId; Timestamp=aTimestamp; WithLog=aWithLog) ->
      let ret = ScriptDom.WriteTextStatement()
      ret.Bulk <- aBulk
      ret.Column <- aColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SourceParameter <- aSourceParameter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TextId <- aTextId |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Timestamp <- aTimestamp |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WithLog <- aWithLog
      ret :> ScriptDom.TextModificationStatement (* 335 *)
  static member FromCs(src:ScriptDom.TextModificationStatement, fragmentMapping:FragmentMapping) : TextModificationStatement =
    let ret =
      match src with
      | :? ScriptDom.UpdateTextStatement as src ->
        TextModificationStatement.UpdateTextStatement((src.Bulk),(src.Column |> Option.ofObj |> Option.map (fun x -> ColumnReferenceExpression.FromCs(x, fragmentMapping))),(src.DeleteLength |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.InsertOffset |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.SourceColumn |> Option.ofObj |> Option.map (fun x -> ColumnReferenceExpression.FromCs(x, fragmentMapping))),(src.SourceParameter |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))),(src.TextId |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))),(src.Timestamp |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.WithLog))
      | :? ScriptDom.WriteTextStatement as src ->
        TextModificationStatement.WriteTextStatement((src.Bulk),(src.Column |> Option.ofObj |> Option.map (fun x -> ColumnReferenceExpression.FromCs(x, fragmentMapping))),(src.SourceParameter |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))),(src.TextId |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))),(src.Timestamp |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))),(src.WithLog))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] TransactionStatement = (* IsAbstract = true *)
  | BeginTransactionStatement of Distributed:bool * MarkDefined:bool * MarkDescription:ValueExpression option * Name:IdentifierOrValueExpression option
  | CommitTransactionStatement of DelayedDurabilityOption:ScriptDom.OptionState * Name:IdentifierOrValueExpression option
  | RollbackTransactionStatement of Name:IdentifierOrValueExpression option
  | SaveTransactionStatement of Name:IdentifierOrValueExpression option
  member this.ToCs() : ScriptDom.TransactionStatement =
    match this with
    | BeginTransactionStatement(Distributed=aDistributed; MarkDefined=aMarkDefined; MarkDescription=aMarkDescription; Name=aName) ->
      let ret = ScriptDom.BeginTransactionStatement()
      ret.Distributed <- aDistributed
      ret.MarkDefined <- aMarkDefined
      ret.MarkDescription <- aMarkDescription |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TransactionStatement (* 335 *)
    | CommitTransactionStatement(DelayedDurabilityOption=aDelayedDurabilityOption; Name=aName) ->
      let ret = ScriptDom.CommitTransactionStatement()
      ret.DelayedDurabilityOption <- aDelayedDurabilityOption
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TransactionStatement (* 335 *)
    | RollbackTransactionStatement(Name=aName) ->
      let ret = ScriptDom.RollbackTransactionStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TransactionStatement (* 335 *)
    | SaveTransactionStatement(Name=aName) ->
      let ret = ScriptDom.SaveTransactionStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TransactionStatement (* 335 *)
  static member FromCs(src:ScriptDom.TransactionStatement, fragmentMapping:FragmentMapping) : TransactionStatement =
    let ret =
      match src with
      | :? ScriptDom.BeginTransactionStatement as src ->
        TransactionStatement.BeginTransactionStatement((src.Distributed),(src.MarkDefined),(src.MarkDescription |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CommitTransactionStatement as src ->
        TransactionStatement.CommitTransactionStatement((src.DelayedDurabilityOption),(src.Name |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.RollbackTransactionStatement as src ->
        TransactionStatement.RollbackTransactionStatement((src.Name |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.SaveTransactionStatement as src ->
        TransactionStatement.SaveTransactionStatement((src.Name |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] TriggerStatementBody = (* IsAbstract = true *)
  | AlterTriggerStatement of IsNotForReplication:bool * MethodSpecifier:MethodSpecifier option * Name:SchemaObjectName option * Options:(TriggerOption) list * StatementList:StatementList option * TriggerActions:(TriggerAction) list * TriggerObject:TriggerObject option * TriggerType:ScriptDom.TriggerType * WithAppend:bool
  | CreateOrAlterTriggerStatement of IsNotForReplication:bool * MethodSpecifier:MethodSpecifier option * Name:SchemaObjectName option * Options:(TriggerOption) list * StatementList:StatementList option * TriggerActions:(TriggerAction) list * TriggerObject:TriggerObject option * TriggerType:ScriptDom.TriggerType * WithAppend:bool
  | CreateTriggerStatement of IsNotForReplication:bool * MethodSpecifier:MethodSpecifier option * Name:SchemaObjectName option * Options:(TriggerOption) list * StatementList:StatementList option * TriggerActions:(TriggerAction) list * TriggerObject:TriggerObject option * TriggerType:ScriptDom.TriggerType * WithAppend:bool
  member this.ToCs() : ScriptDom.TriggerStatementBody =
    match this with
    | AlterTriggerStatement(IsNotForReplication=aIsNotForReplication; MethodSpecifier=aMethodSpecifier; Name=aName; Options=aOptions; StatementList=aStatementList; TriggerActions=aTriggerActions; TriggerObject=aTriggerObject; TriggerType=aTriggerType; WithAppend=aWithAppend) ->
      let ret = ScriptDom.AlterTriggerStatement()
      ret.IsNotForReplication <- aIsNotForReplication
      ret.MethodSpecifier <- aMethodSpecifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.StatementList <- aStatementList |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aTriggerActions do ret.TriggerActions.Add (e.ToCs())
      ret.TriggerObject <- aTriggerObject |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TriggerType <- aTriggerType
      ret.WithAppend <- aWithAppend
      ret :> ScriptDom.TriggerStatementBody (* 335 *)
    | CreateOrAlterTriggerStatement(IsNotForReplication=aIsNotForReplication; MethodSpecifier=aMethodSpecifier; Name=aName; Options=aOptions; StatementList=aStatementList; TriggerActions=aTriggerActions; TriggerObject=aTriggerObject; TriggerType=aTriggerType; WithAppend=aWithAppend) ->
      let ret = ScriptDom.CreateOrAlterTriggerStatement()
      ret.IsNotForReplication <- aIsNotForReplication
      ret.MethodSpecifier <- aMethodSpecifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.StatementList <- aStatementList |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aTriggerActions do ret.TriggerActions.Add (e.ToCs())
      ret.TriggerObject <- aTriggerObject |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TriggerType <- aTriggerType
      ret.WithAppend <- aWithAppend
      ret :> ScriptDom.TriggerStatementBody (* 335 *)
    | CreateTriggerStatement(IsNotForReplication=aIsNotForReplication; MethodSpecifier=aMethodSpecifier; Name=aName; Options=aOptions; StatementList=aStatementList; TriggerActions=aTriggerActions; TriggerObject=aTriggerObject; TriggerType=aTriggerType; WithAppend=aWithAppend) ->
      let ret = ScriptDom.CreateTriggerStatement()
      ret.IsNotForReplication <- aIsNotForReplication
      ret.MethodSpecifier <- aMethodSpecifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.StatementList <- aStatementList |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aTriggerActions do ret.TriggerActions.Add (e.ToCs())
      ret.TriggerObject <- aTriggerObject |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TriggerType <- aTriggerType
      ret.WithAppend <- aWithAppend
      ret :> ScriptDom.TriggerStatementBody (* 335 *)
  static member FromCs(src:ScriptDom.TriggerStatementBody, fragmentMapping:FragmentMapping) : TriggerStatementBody =
    let ret =
      match src with
      | :? ScriptDom.AlterTriggerStatement as src ->
        TriggerStatementBody.AlterTriggerStatement((src.IsNotForReplication),(src.MethodSpecifier |> Option.ofObj |> Option.map (fun x -> MethodSpecifier.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.Options |> Seq.map (fun x -> TriggerOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.StatementList |> Option.ofObj |> Option.map (fun x -> StatementList.FromCs(x, fragmentMapping))),(src.TriggerActions |> Seq.map (fun src -> TriggerAction.TriggerAction((src.EventTypeGroup |> Option.ofObj |> Option.map (fun x -> EventTypeGroupContainer.FromCs(x, fragmentMapping))), (src.TriggerActionType))) |> List.ofSeq),(src.TriggerObject |> Option.ofObj |> Option.map (fun x -> TriggerObject.FromCs(x, fragmentMapping))),(src.TriggerType),(src.WithAppend))
      | :? ScriptDom.CreateOrAlterTriggerStatement as src ->
        TriggerStatementBody.CreateOrAlterTriggerStatement((src.IsNotForReplication),(src.MethodSpecifier |> Option.ofObj |> Option.map (fun x -> MethodSpecifier.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.Options |> Seq.map (fun x -> TriggerOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.StatementList |> Option.ofObj |> Option.map (fun x -> StatementList.FromCs(x, fragmentMapping))),(src.TriggerActions |> Seq.map (fun src -> TriggerAction.TriggerAction((src.EventTypeGroup |> Option.ofObj |> Option.map (fun x -> EventTypeGroupContainer.FromCs(x, fragmentMapping))), (src.TriggerActionType))) |> List.ofSeq),(src.TriggerObject |> Option.ofObj |> Option.map (fun x -> TriggerObject.FromCs(x, fragmentMapping))),(src.TriggerType),(src.WithAppend))
      | :? ScriptDom.CreateTriggerStatement as src ->
        TriggerStatementBody.CreateTriggerStatement((src.IsNotForReplication),(src.MethodSpecifier |> Option.ofObj |> Option.map (fun x -> MethodSpecifier.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.Options |> Seq.map (fun x -> TriggerOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.StatementList |> Option.ofObj |> Option.map (fun x -> StatementList.FromCs(x, fragmentMapping))),(src.TriggerActions |> Seq.map (fun src -> TriggerAction.TriggerAction((src.EventTypeGroup |> Option.ofObj |> Option.map (fun x -> EventTypeGroupContainer.FromCs(x, fragmentMapping))), (src.TriggerActionType))) |> List.ofSeq),(src.TriggerObject |> Option.ofObj |> Option.map (fun x -> TriggerObject.FromCs(x, fragmentMapping))),(src.TriggerType),(src.WithAppend))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] UserStatement = (* IsAbstract = true *)
  | AlterUserStatement of Name:Identifier option * UserOptions:(PrincipalOption) list
  | CreateUserStatement of Name:Identifier option * UserLoginOption:UserLoginOption option * UserOptions:(PrincipalOption) list
  member this.ToCs() : ScriptDom.UserStatement =
    match this with
    | AlterUserStatement(Name=aName; UserOptions=aUserOptions) ->
      let ret = ScriptDom.AlterUserStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aUserOptions do ret.UserOptions.Add (e.ToCs())
      ret :> ScriptDom.UserStatement (* 335 *)
    | CreateUserStatement(Name=aName; UserLoginOption=aUserLoginOption; UserOptions=aUserOptions) ->
      let ret = ScriptDom.CreateUserStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UserLoginOption <- aUserLoginOption |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aUserOptions do ret.UserOptions.Add (e.ToCs())
      ret :> ScriptDom.UserStatement (* 335 *)
  static member FromCs(src:ScriptDom.UserStatement, fragmentMapping:FragmentMapping) : UserStatement =
    let ret =
      match src with
      | :? ScriptDom.AlterUserStatement as src ->
        UserStatement.AlterUserStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.UserOptions |> Seq.map (fun x -> PrincipalOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.CreateUserStatement as src ->
        UserStatement.CreateUserStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.UserLoginOption |> Option.ofObj |> Option.map (fun x -> UserLoginOption.FromCs(x, fragmentMapping))),(src.UserOptions |> Seq.map (fun x -> PrincipalOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ViewStatementBody = (* IsAbstract = true *)
  | AlterViewStatement of Columns:(Identifier) list * IsDisable:bool * IsMaterialized:bool * IsRebuild:bool * SchemaObjectName:SchemaObjectName option * SelectStatement:SelectStatement option * ViewOptions:(ViewOption) list * WithCheckOption:bool
  | CreateOrAlterViewStatement of Columns:(Identifier) list * IsMaterialized:bool * SchemaObjectName:SchemaObjectName option * SelectStatement:SelectStatement option * ViewOptions:(ViewOption) list * WithCheckOption:bool
  | CreateViewStatement of Columns:(Identifier) list * IsMaterialized:bool * SchemaObjectName:SchemaObjectName option * SelectStatement:SelectStatement option * ViewOptions:(ViewOption) list * WithCheckOption:bool
  member this.ToCs() : ScriptDom.ViewStatementBody =
    match this with
    | AlterViewStatement(Columns=aColumns; IsDisable=aIsDisable; IsMaterialized=aIsMaterialized; IsRebuild=aIsRebuild; SchemaObjectName=aSchemaObjectName; SelectStatement=aSelectStatement; ViewOptions=aViewOptions; WithCheckOption=aWithCheckOption) ->
      let ret = ScriptDom.AlterViewStatement()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.IsDisable <- aIsDisable
      ret.IsMaterialized <- aIsMaterialized
      ret.IsRebuild <- aIsRebuild
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SelectStatement <- aSelectStatement |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aViewOptions do ret.ViewOptions.Add (e.ToCs())
      ret.WithCheckOption <- aWithCheckOption
      ret :> ScriptDom.ViewStatementBody (* 335 *)
    | CreateOrAlterViewStatement(Columns=aColumns; IsMaterialized=aIsMaterialized; SchemaObjectName=aSchemaObjectName; SelectStatement=aSelectStatement; ViewOptions=aViewOptions; WithCheckOption=aWithCheckOption) ->
      let ret = ScriptDom.CreateOrAlterViewStatement()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.IsMaterialized <- aIsMaterialized
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SelectStatement <- aSelectStatement |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aViewOptions do ret.ViewOptions.Add (e.ToCs())
      ret.WithCheckOption <- aWithCheckOption
      ret :> ScriptDom.ViewStatementBody (* 335 *)
    | CreateViewStatement(Columns=aColumns; IsMaterialized=aIsMaterialized; SchemaObjectName=aSchemaObjectName; SelectStatement=aSelectStatement; ViewOptions=aViewOptions; WithCheckOption=aWithCheckOption) ->
      let ret = ScriptDom.CreateViewStatement()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.IsMaterialized <- aIsMaterialized
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SelectStatement <- aSelectStatement |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aViewOptions do ret.ViewOptions.Add (e.ToCs())
      ret.WithCheckOption <- aWithCheckOption
      ret :> ScriptDom.ViewStatementBody (* 335 *)
  static member FromCs(src:ScriptDom.ViewStatementBody, fragmentMapping:FragmentMapping) : ViewStatementBody =
    let ret =
      match src with
      | :? ScriptDom.AlterViewStatement as src ->
        ViewStatementBody.AlterViewStatement((src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.IsDisable),(src.IsMaterialized),(src.IsRebuild),(src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.SelectStatement |> Option.ofObj |> Option.map (fun x -> SelectStatement.FromCs(x, fragmentMapping))),(src.ViewOptions |> Seq.map (fun x -> ViewOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.WithCheckOption))
      | :? ScriptDom.CreateOrAlterViewStatement as src ->
        ViewStatementBody.CreateOrAlterViewStatement((src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.IsMaterialized),(src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.SelectStatement |> Option.ofObj |> Option.map (fun x -> SelectStatement.FromCs(x, fragmentMapping))),(src.ViewOptions |> Seq.map (fun x -> ViewOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.WithCheckOption))
      | :? ScriptDom.CreateViewStatement as src ->
        ViewStatementBody.CreateViewStatement((src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.IsMaterialized),(src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.SelectStatement |> Option.ofObj |> Option.map (fun x -> SelectStatement.FromCs(x, fragmentMapping))),(src.ViewOptions |> Seq.map (fun x -> ViewOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.WithCheckOption))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] WaitForSupportedStatement = (* IsAbstract = true *)
  | GetConversationGroupStatement of GroupId:VariableReference option * Queue:SchemaObjectName option
  | ReceiveStatement of Into:VariableTableReference option * IsConversationGroupIdWhere:bool * Queue:SchemaObjectName option * SelectElements:(SelectElement) list * Top:ScalarExpression option * Where:ValueExpression option
  member this.ToCs() : ScriptDom.WaitForSupportedStatement =
    match this with
    | GetConversationGroupStatement(GroupId=aGroupId; Queue=aQueue) ->
      let ret = ScriptDom.GetConversationGroupStatement()
      ret.GroupId <- aGroupId |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Queue <- aQueue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.WaitForSupportedStatement (* 335 *)
    | ReceiveStatement(Into=aInto; IsConversationGroupIdWhere=aIsConversationGroupIdWhere; Queue=aQueue; SelectElements=aSelectElements; Top=aTop; Where=aWhere) ->
      let ret = ScriptDom.ReceiveStatement()
      ret.Into <- aInto |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsConversationGroupIdWhere <- aIsConversationGroupIdWhere
      ret.Queue <- aQueue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aSelectElements do ret.SelectElements.Add (e.ToCs())
      ret.Top <- aTop |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Where <- aWhere |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.WaitForSupportedStatement (* 335 *)
  static member FromCs(src:ScriptDom.WaitForSupportedStatement, fragmentMapping:FragmentMapping) : WaitForSupportedStatement =
    let ret =
      match src with
      | :? ScriptDom.GetConversationGroupStatement as src ->
        WaitForSupportedStatement.GetConversationGroupStatement((src.GroupId |> Option.ofObj |> Option.map (fun x -> VariableReference.FromCs(x, fragmentMapping))),(src.Queue |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ReceiveStatement as src ->
        WaitForSupportedStatement.ReceiveStatement((src.Into |> Option.ofObj |> Option.map (fun x -> VariableTableReference.FromCs(x, fragmentMapping))),(src.IsConversationGroupIdWhere),(src.Queue |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.SelectElements |> Seq.map (fun x -> SelectElement.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Top |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.Where |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] WorkloadClassifierStatement = (* IsAbstract = true *)
  | CreateWorkloadClassifierStatement of ClassifierName:Identifier option * Options:(WorkloadClassifierOption) list
  member this.ToCs() : ScriptDom.WorkloadClassifierStatement =
    match this with
    | CreateWorkloadClassifierStatement(ClassifierName=aClassifierName; Options=aOptions) ->
      let ret = ScriptDom.CreateWorkloadClassifierStatement()
      ret.ClassifierName <- aClassifierName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.WorkloadClassifierStatement (* 335 *)
  static member FromCs(src:ScriptDom.WorkloadClassifierStatement, fragmentMapping:FragmentMapping) : WorkloadClassifierStatement =
    let ret =
      match src with
      | :? ScriptDom.CreateWorkloadClassifierStatement as src ->
        WorkloadClassifierStatement.CreateWorkloadClassifierStatement((src.ClassifierName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Options |> Seq.map (fun x -> WorkloadClassifierOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] WorkloadGroupStatement = (* IsAbstract = true *)
  | AlterWorkloadGroupStatement of ExternalPoolName:Identifier option * Name:Identifier option * PoolName:Identifier option * WorkloadGroupParameters:(WorkloadGroupParameter) list
  | CreateWorkloadGroupStatement of ExternalPoolName:Identifier option * Name:Identifier option * PoolName:Identifier option * WorkloadGroupParameters:(WorkloadGroupParameter) list
  member this.ToCs() : ScriptDom.WorkloadGroupStatement =
    match this with
    | AlterWorkloadGroupStatement(ExternalPoolName=aExternalPoolName; Name=aName; PoolName=aPoolName; WorkloadGroupParameters=aWorkloadGroupParameters) ->
      let ret = ScriptDom.AlterWorkloadGroupStatement()
      ret.ExternalPoolName <- aExternalPoolName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PoolName <- aPoolName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aWorkloadGroupParameters do ret.WorkloadGroupParameters.Add (e.ToCs())
      ret :> ScriptDom.WorkloadGroupStatement (* 335 *)
    | CreateWorkloadGroupStatement(ExternalPoolName=aExternalPoolName; Name=aName; PoolName=aPoolName; WorkloadGroupParameters=aWorkloadGroupParameters) ->
      let ret = ScriptDom.CreateWorkloadGroupStatement()
      ret.ExternalPoolName <- aExternalPoolName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PoolName <- aPoolName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aWorkloadGroupParameters do ret.WorkloadGroupParameters.Add (e.ToCs())
      ret :> ScriptDom.WorkloadGroupStatement (* 335 *)
  static member FromCs(src:ScriptDom.WorkloadGroupStatement, fragmentMapping:FragmentMapping) : WorkloadGroupStatement =
    let ret =
      match src with
      | :? ScriptDom.AlterWorkloadGroupStatement as src ->
        WorkloadGroupStatement.AlterWorkloadGroupStatement((src.ExternalPoolName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.PoolName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.WorkloadGroupParameters |> Seq.map (fun x -> WorkloadGroupParameter.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.CreateWorkloadGroupStatement as src ->
        WorkloadGroupStatement.CreateWorkloadGroupStatement((src.ExternalPoolName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.PoolName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.WorkloadGroupParameters |> Seq.map (fun x -> WorkloadGroupParameter.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] JoinTableReference = (* IsAbstract = true *)
  | QualifiedJoin of FirstTableReference:TableReference option * JoinHint:ScriptDom.JoinHint * QualifiedJoinType:ScriptDom.QualifiedJoinType * SearchCondition:BooleanExpression option * SecondTableReference:TableReference option
  | UnqualifiedJoin of FirstTableReference:TableReference option * SecondTableReference:TableReference option * UnqualifiedJoinType:ScriptDom.UnqualifiedJoinType
  member this.ToCs() : ScriptDom.JoinTableReference =
    match this with
    | QualifiedJoin(FirstTableReference=aFirstTableReference; JoinHint=aJoinHint; QualifiedJoinType=aQualifiedJoinType; SearchCondition=aSearchCondition; SecondTableReference=aSecondTableReference) ->
      let ret = ScriptDom.QualifiedJoin()
      ret.FirstTableReference <- aFirstTableReference |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.JoinHint <- aJoinHint
      ret.QualifiedJoinType <- aQualifiedJoinType
      ret.SearchCondition <- aSearchCondition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SecondTableReference <- aSecondTableReference |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.JoinTableReference (* 335 *)
    | UnqualifiedJoin(FirstTableReference=aFirstTableReference; SecondTableReference=aSecondTableReference; UnqualifiedJoinType=aUnqualifiedJoinType) ->
      let ret = ScriptDom.UnqualifiedJoin()
      ret.FirstTableReference <- aFirstTableReference |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SecondTableReference <- aSecondTableReference |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UnqualifiedJoinType <- aUnqualifiedJoinType
      ret :> ScriptDom.JoinTableReference (* 335 *)
  static member FromCs(src:ScriptDom.JoinTableReference, fragmentMapping:FragmentMapping) : JoinTableReference =
    let ret =
      match src with
      | :? ScriptDom.QualifiedJoin as src ->
        JoinTableReference.QualifiedJoin((src.FirstTableReference |> Option.ofObj |> Option.map (fun x -> TableReference.FromCs(x, fragmentMapping))),(src.JoinHint),(src.QualifiedJoinType),(src.SearchCondition |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))),(src.SecondTableReference |> Option.ofObj |> Option.map (fun x -> TableReference.FromCs(x, fragmentMapping))))
      | :? ScriptDom.UnqualifiedJoin as src ->
        JoinTableReference.UnqualifiedJoin((src.FirstTableReference |> Option.ofObj |> Option.map (fun x -> TableReference.FromCs(x, fragmentMapping))),(src.SecondTableReference |> Option.ofObj |> Option.map (fun x -> TableReference.FromCs(x, fragmentMapping))),(src.UnqualifiedJoinType))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] TableReferenceWithAlias = (* IsAbstract = true *)
  | AdHocTableReference of Alias:Identifier option * DataSource:AdHocDataSource option * Object:SchemaObjectNameOrValueExpression option
  | BuiltInFunctionTableReference of Alias:Identifier option * Name:Identifier option * Parameters:(ScalarExpression) list
  | FullTextTableReference of Alias:Identifier option * Columns:(ColumnReferenceExpression) list * FullTextFunctionType:ScriptDom.FullTextFunctionType * Language:ValueExpression option * PropertyName:StringLiteral option * SearchCondition:ValueExpression option * TableName:SchemaObjectName option * TopN:ValueExpression option
  | GlobalFunctionTableReference of Alias:Identifier option * Name:Identifier option * Parameters:(ScalarExpression) list
  | InternalOpenRowset of Alias:Identifier option * Identifier:Identifier option * VarArgs:(ScalarExpression) list
  | NamedTableReference of Alias:Identifier option * ForPath:bool * SchemaObject:SchemaObjectName option * TableHints:(TableHint) list * TableSampleClause:TableSampleClause option * TemporalClause:TemporalClause option
  | OpenJsonTableReference of Alias:Identifier option * RowPattern:ScalarExpression option * SchemaDeclarationItems:(SchemaDeclarationItemOpenjson) list * Variable:ScalarExpression option
  | OpenQueryTableReference of Alias:Identifier option * LinkedServer:Identifier option * Query:StringLiteral option
  | OpenRowsetTableReference of Alias:Identifier option * DataSource:StringLiteral option * Object:SchemaObjectName option * Password:StringLiteral option * ProviderName:StringLiteral option * ProviderString:StringLiteral option * Query:StringLiteral option * UserId:StringLiteral option
  | OpenXmlTableReference of Alias:Identifier option * Flags:ValueExpression option * RowPattern:ValueExpression option * SchemaDeclarationItems:(SchemaDeclarationItem) list * TableName:SchemaObjectName option * Variable:VariableReference option
  | PivotedTableReference of AggregateFunctionIdentifier:MultiPartIdentifier option * Alias:Identifier option * InColumns:(Identifier) list * PivotColumn:ColumnReferenceExpression option * TableReference:TableReference option * ValueColumns:(ColumnReferenceExpression) list
  | SemanticTableReference of Alias:Identifier option * Columns:(ColumnReferenceExpression) list * MatchedColumn:ColumnReferenceExpression option * MatchedKey:ScalarExpression option * SemanticFunctionType:ScriptDom.SemanticFunctionType * SourceKey:ScalarExpression option * TableName:SchemaObjectName option
  | TableReferenceWithAliasAndColumns of TableReferenceWithAliasAndColumns
  | UnpivotedTableReference of Alias:Identifier option * InColumns:(ColumnReferenceExpression) list * PivotColumn:Identifier option * TableReference:TableReference option * ValueColumn:Identifier option
  | VariableTableReference of Alias:Identifier option * Variable:VariableReference option
  member this.ToCs() : ScriptDom.TableReferenceWithAlias =
    match this with
    | AdHocTableReference(Alias=aAlias; DataSource=aDataSource; Object=aObject) ->
      let ret = ScriptDom.AdHocTableReference()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DataSource <- aDataSource |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Object <- aObject |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableReferenceWithAlias (* 335 *)
    | BuiltInFunctionTableReference(Alias=aAlias; Name=aName; Parameters=aParameters) ->
      let ret = ScriptDom.BuiltInFunctionTableReference()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret :> ScriptDom.TableReferenceWithAlias (* 335 *)
    | FullTextTableReference(Alias=aAlias; Columns=aColumns; FullTextFunctionType=aFullTextFunctionType; Language=aLanguage; PropertyName=aPropertyName; SearchCondition=aSearchCondition; TableName=aTableName; TopN=aTopN) ->
      let ret = ScriptDom.FullTextTableReference()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.FullTextFunctionType <- aFullTextFunctionType
      ret.Language <- aLanguage |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PropertyName <- aPropertyName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SearchCondition <- aSearchCondition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TableName <- aTableName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TopN <- aTopN |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableReferenceWithAlias (* 335 *)
    | GlobalFunctionTableReference(Alias=aAlias; Name=aName; Parameters=aParameters) ->
      let ret = ScriptDom.GlobalFunctionTableReference()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret :> ScriptDom.TableReferenceWithAlias (* 335 *)
    | InternalOpenRowset(Alias=aAlias; Identifier=aIdentifier; VarArgs=aVarArgs) ->
      let ret = ScriptDom.InternalOpenRowset()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Identifier <- aIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aVarArgs do ret.VarArgs.Add (e.ToCs())
      ret :> ScriptDom.TableReferenceWithAlias (* 335 *)
    | NamedTableReference(Alias=aAlias; ForPath=aForPath; SchemaObject=aSchemaObject; TableHints=aTableHints; TableSampleClause=aTableSampleClause; TemporalClause=aTemporalClause) ->
      let ret = ScriptDom.NamedTableReference()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ForPath <- aForPath
      ret.SchemaObject <- aSchemaObject |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aTableHints do ret.TableHints.Add (e.ToCs())
      ret.TableSampleClause <- aTableSampleClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TemporalClause <- aTemporalClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableReferenceWithAlias (* 335 *)
    | OpenJsonTableReference(Alias=aAlias; RowPattern=aRowPattern; SchemaDeclarationItems=aSchemaDeclarationItems; Variable=aVariable) ->
      let ret = ScriptDom.OpenJsonTableReference()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.RowPattern <- aRowPattern |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aSchemaDeclarationItems do ret.SchemaDeclarationItems.Add (e.ToCs())
      ret.Variable <- aVariable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableReferenceWithAlias (* 335 *)
    | OpenQueryTableReference(Alias=aAlias; LinkedServer=aLinkedServer; Query=aQuery) ->
      let ret = ScriptDom.OpenQueryTableReference()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.LinkedServer <- aLinkedServer |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Query <- aQuery |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableReferenceWithAlias (* 335 *)
    | OpenRowsetTableReference(Alias=aAlias; DataSource=aDataSource; Object=aObject; Password=aPassword; ProviderName=aProviderName; ProviderString=aProviderString; Query=aQuery; UserId=aUserId) ->
      let ret = ScriptDom.OpenRowsetTableReference()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DataSource <- aDataSource |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Object <- aObject |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Password <- aPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ProviderName <- aProviderName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ProviderString <- aProviderString |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Query <- aQuery |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UserId <- aUserId |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableReferenceWithAlias (* 335 *)
    | OpenXmlTableReference(Alias=aAlias; Flags=aFlags; RowPattern=aRowPattern; SchemaDeclarationItems=aSchemaDeclarationItems; TableName=aTableName; Variable=aVariable) ->
      let ret = ScriptDom.OpenXmlTableReference()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Flags <- aFlags |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.RowPattern <- aRowPattern |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aSchemaDeclarationItems do ret.SchemaDeclarationItems.Add (e.ToCs())
      ret.TableName <- aTableName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Variable <- aVariable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableReferenceWithAlias (* 335 *)
    | PivotedTableReference(AggregateFunctionIdentifier=aAggregateFunctionIdentifier; Alias=aAlias; InColumns=aInColumns; PivotColumn=aPivotColumn; TableReference=aTableReference; ValueColumns=aValueColumns) ->
      let ret = ScriptDom.PivotedTableReference()
      ret.AggregateFunctionIdentifier <- aAggregateFunctionIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aInColumns do ret.InColumns.Add (e.ToCs())
      ret.PivotColumn <- aPivotColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TableReference <- aTableReference |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aValueColumns do ret.ValueColumns.Add (e.ToCs())
      ret :> ScriptDom.TableReferenceWithAlias (* 335 *)
    | SemanticTableReference(Alias=aAlias; Columns=aColumns; MatchedColumn=aMatchedColumn; MatchedKey=aMatchedKey; SemanticFunctionType=aSemanticFunctionType; SourceKey=aSourceKey; TableName=aTableName) ->
      let ret = ScriptDom.SemanticTableReference()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.MatchedColumn <- aMatchedColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.MatchedKey <- aMatchedKey |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SemanticFunctionType <- aSemanticFunctionType
      ret.SourceKey <- aSourceKey |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TableName <- aTableName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableReferenceWithAlias (* 335 *)
    | TableReferenceWithAliasAndColumns(x) -> x.ToCs() :> ScriptDom.TableReferenceWithAlias (* 345 *)
    | UnpivotedTableReference(Alias=aAlias; InColumns=aInColumns; PivotColumn=aPivotColumn; TableReference=aTableReference; ValueColumn=aValueColumn) ->
      let ret = ScriptDom.UnpivotedTableReference()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aInColumns do ret.InColumns.Add (e.ToCs())
      ret.PivotColumn <- aPivotColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TableReference <- aTableReference |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ValueColumn <- aValueColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableReferenceWithAlias (* 335 *)
    | VariableTableReference(Alias=aAlias; Variable=aVariable) ->
      let ret = ScriptDom.VariableTableReference()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Variable <- aVariable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableReferenceWithAlias (* 335 *)
  static member FromCs(src:ScriptDom.TableReferenceWithAlias, fragmentMapping:FragmentMapping) : TableReferenceWithAlias =
    let ret =
      match src with
      | :? ScriptDom.AdHocTableReference as src ->
        TableReferenceWithAlias.AdHocTableReference((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.DataSource |> Option.ofObj |> Option.map (fun x -> AdHocDataSource.FromCs(x, fragmentMapping))),(src.Object |> Option.ofObj |> Option.map (fun x -> SchemaObjectNameOrValueExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.BuiltInFunctionTableReference as src ->
        TableReferenceWithAlias.BuiltInFunctionTableReference((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Parameters |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.FullTextTableReference as src ->
        TableReferenceWithAlias.FullTextTableReference((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.FullTextFunctionType),(src.Language |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))),(src.PropertyName |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))),(src.SearchCondition |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))),(src.TableName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.TopN |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.GlobalFunctionTableReference as src ->
        TableReferenceWithAlias.GlobalFunctionTableReference((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Parameters |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.InternalOpenRowset as src ->
        TableReferenceWithAlias.InternalOpenRowset((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.VarArgs |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.NamedTableReference as src ->
        TableReferenceWithAlias.NamedTableReference((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.ForPath),(src.SchemaObject |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.TableHints |> Seq.map (fun x -> TableHint.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.TableSampleClause |> Option.ofObj |> Option.map (fun x -> TableSampleClause.FromCs(x, fragmentMapping))),(src.TemporalClause |> Option.ofObj |> Option.map (fun x -> TemporalClause.FromCs(x, fragmentMapping))))
      | :? ScriptDom.OpenJsonTableReference as src ->
        TableReferenceWithAlias.OpenJsonTableReference((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.RowPattern |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.SchemaDeclarationItems |> Seq.map (fun src -> SchemaDeclarationItemOpenjson.SchemaDeclarationItemOpenjson((src.AsJson), (src.ColumnDefinition |> Option.ofObj |> Option.map (fun x -> ColumnDefinitionBase.FromCs(x, fragmentMapping))), (src.Mapping |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.Variable |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.OpenQueryTableReference as src ->
        TableReferenceWithAlias.OpenQueryTableReference((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.LinkedServer |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Query |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))))
      | :? ScriptDom.OpenRowsetTableReference as src ->
        TableReferenceWithAlias.OpenRowsetTableReference((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.DataSource |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))),(src.Object |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.Password |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))),(src.ProviderName |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))),(src.ProviderString |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))),(src.Query |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))),(src.UserId |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))))
      | :? ScriptDom.OpenXmlTableReference as src ->
        TableReferenceWithAlias.OpenXmlTableReference((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Flags |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))),(src.RowPattern |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))),(src.SchemaDeclarationItems |> Seq.map (fun x -> SchemaDeclarationItem.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.TableName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.Variable |> Option.ofObj |> Option.map (fun x -> VariableReference.FromCs(x, fragmentMapping))))
      | :? ScriptDom.PivotedTableReference as src ->
        TableReferenceWithAlias.PivotedTableReference((src.AggregateFunctionIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))),(src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.InColumns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.PivotColumn |> Option.ofObj |> Option.map (fun x -> ColumnReferenceExpression.FromCs(x, fragmentMapping))),(src.TableReference |> Option.ofObj |> Option.map (fun x -> TableReference.FromCs(x, fragmentMapping))),(src.ValueColumns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq))
      | :? ScriptDom.SemanticTableReference as src ->
        TableReferenceWithAlias.SemanticTableReference((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.MatchedColumn |> Option.ofObj |> Option.map (fun x -> ColumnReferenceExpression.FromCs(x, fragmentMapping))),(src.MatchedKey |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.SemanticFunctionType),(src.SourceKey |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.TableName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.TableReferenceWithAliasAndColumns as src ->
        match src with
        | :? ScriptDom.BulkOpenRowset as src->
          TableReferenceWithAlias.TableReferenceWithAliasAndColumns((TableReferenceWithAliasAndColumns.BulkOpenRowset((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.DataFile |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))), (src.Options |> Seq.map (fun x -> BulkInsertOption.FromCs(x, fragmentMapping)) |> List.ofSeq))  ))
        | :? ScriptDom.ChangeTableChangesTableReference as src->
          TableReferenceWithAlias.TableReferenceWithAliasAndColumns((TableReferenceWithAliasAndColumns.ChangeTableChangesTableReference((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.SinceVersion |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))), (src.Target |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.ChangeTableVersionTableReference as src->
          TableReferenceWithAlias.TableReferenceWithAliasAndColumns((TableReferenceWithAliasAndColumns.ChangeTableVersionTableReference((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.PrimaryKeyColumns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.PrimaryKeyValues |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Target |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.DataModificationTableReference as src->
          TableReferenceWithAlias.TableReferenceWithAliasAndColumns((TableReferenceWithAliasAndColumns.DataModificationTableReference((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.DataModificationSpecification |> Option.ofObj |> Option.map (fun x -> DataModificationSpecification.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.InlineDerivedTable as src->
          TableReferenceWithAlias.TableReferenceWithAliasAndColumns((TableReferenceWithAliasAndColumns.InlineDerivedTable((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.RowValues |> Seq.map (fun src -> RowValue.RowValue((src.ColumnValues |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq))) |> List.ofSeq))  ))
        | :? ScriptDom.QueryDerivedTable as src->
          TableReferenceWithAlias.TableReferenceWithAliasAndColumns((TableReferenceWithAliasAndColumns.QueryDerivedTable((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.QueryExpression |> Option.ofObj |> Option.map (fun x -> QueryExpression.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.SchemaObjectFunctionTableReference as src->
          TableReferenceWithAlias.TableReferenceWithAliasAndColumns((TableReferenceWithAliasAndColumns.SchemaObjectFunctionTableReference((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Parameters |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.SchemaObject |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))  ))
        | :? ScriptDom.VariableMethodCallTableReference as src->
          TableReferenceWithAlias.TableReferenceWithAliasAndColumns((TableReferenceWithAliasAndColumns.VariableMethodCallTableReference((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.MethodName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Parameters |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Variable |> Option.ofObj |> Option.map (fun x -> VariableReference.FromCs(x, fragmentMapping))))  ))
      | :? ScriptDom.UnpivotedTableReference as src ->
        TableReferenceWithAlias.UnpivotedTableReference((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.InColumns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.PivotColumn |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.TableReference |> Option.ofObj |> Option.map (fun x -> TableReference.FromCs(x, fragmentMapping))),(src.ValueColumn |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | :? ScriptDom.VariableTableReference as src ->
        TableReferenceWithAlias.VariableTableReference((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Variable |> Option.ofObj |> Option.map (fun x -> VariableReference.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] CaseExpression = (* IsAbstract = true *)
  | SearchedCaseExpression of Collation:Identifier option * ElseExpression:ScalarExpression option * WhenClauses:(SearchedWhenClause) list
  | SimpleCaseExpression of Collation:Identifier option * ElseExpression:ScalarExpression option * InputExpression:ScalarExpression option * WhenClauses:(SimpleWhenClause) list
  member this.ToCs() : ScriptDom.CaseExpression =
    match this with
    | SearchedCaseExpression(Collation=aCollation; ElseExpression=aElseExpression; WhenClauses=aWhenClauses) ->
      let ret = ScriptDom.SearchedCaseExpression()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ElseExpression <- aElseExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aWhenClauses do ret.WhenClauses.Add (e.ToCs())
      ret :> ScriptDom.CaseExpression (* 335 *)
    | SimpleCaseExpression(Collation=aCollation; ElseExpression=aElseExpression; InputExpression=aInputExpression; WhenClauses=aWhenClauses) ->
      let ret = ScriptDom.SimpleCaseExpression()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ElseExpression <- aElseExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.InputExpression <- aInputExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aWhenClauses do ret.WhenClauses.Add (e.ToCs())
      ret :> ScriptDom.CaseExpression (* 335 *)
  static member FromCs(src:ScriptDom.CaseExpression, fragmentMapping:FragmentMapping) : CaseExpression =
    let ret =
      match src with
      | :? ScriptDom.SearchedCaseExpression as src ->
        CaseExpression.SearchedCaseExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.ElseExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.WhenClauses |> Seq.map (fun src -> SearchedWhenClause.SearchedWhenClause((src.ThenExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.WhenExpression |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq))
      | :? ScriptDom.SimpleCaseExpression as src ->
        CaseExpression.SimpleCaseExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.ElseExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.InputExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))),(src.WhenClauses |> Seq.map (fun src -> SimpleWhenClause.SimpleWhenClause((src.ThenExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.WhenExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ValueExpression = (* IsAbstract = true *)
  | GlobalVariableExpression of Collation:Identifier option * Name:String option
  | Literal of Literal
  | VariableReference of Collation:Identifier option * Name:String option
  member this.ToCs() : ScriptDom.ValueExpression =
    match this with
    | GlobalVariableExpression(Collation=aCollation; Name=aName) ->
      let ret = ScriptDom.GlobalVariableExpression()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.toObj
      ret :> ScriptDom.ValueExpression (* 335 *)
    | Literal(x) -> x.ToCs() :> ScriptDom.ValueExpression (* 345 *)
    | VariableReference(Collation=aCollation; Name=aName) ->
      let ret = ScriptDom.VariableReference()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.toObj
      ret :> ScriptDom.ValueExpression (* 335 *)
  static member FromCs(src:ScriptDom.ValueExpression, fragmentMapping:FragmentMapping) : ValueExpression =
    let ret =
      match src with
      | :? ScriptDom.GlobalVariableExpression as src ->
        ValueExpression.GlobalVariableExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(Option.ofObj (src.Name)))
      | :? ScriptDom.Literal as src ->
        match src with
        | :? ScriptDom.BinaryLiteral as src->
          ValueExpression.Literal((Literal.BinaryLiteral((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.IsLargeObject), (src.LiteralType), (Option.ofObj (src.Value)))  ))
        | :? ScriptDom.DefaultLiteral as src->
          ValueExpression.Literal((Literal.DefaultLiteral((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.LiteralType), (Option.ofObj (src.Value)))  ))
        | :? ScriptDom.IdentifierLiteral as src->
          ValueExpression.Literal((Literal.IdentifierLiteral((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.LiteralType), (src.QuoteType), (Option.ofObj (src.Value)))  ))
        | :? ScriptDom.IntegerLiteral as src->
          ValueExpression.Literal((Literal.IntegerLiteral((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.LiteralType), (Option.ofObj (src.Value)))  ))
        | :? ScriptDom.MaxLiteral as src->
          ValueExpression.Literal((Literal.MaxLiteral((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.LiteralType), (Option.ofObj (src.Value)))  ))
        | :? ScriptDom.MoneyLiteral as src->
          ValueExpression.Literal((Literal.MoneyLiteral((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.LiteralType), (Option.ofObj (src.Value)))  ))
        | :? ScriptDom.NullLiteral as src->
          ValueExpression.Literal((Literal.NullLiteral((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.LiteralType), (Option.ofObj (src.Value)))  ))
        | :? ScriptDom.NumericLiteral as src->
          ValueExpression.Literal((Literal.NumericLiteral((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.LiteralType), (Option.ofObj (src.Value)))  ))
        | :? ScriptDom.OdbcLiteral as src->
          ValueExpression.Literal((Literal.OdbcLiteral((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.IsNational), (src.LiteralType), (src.OdbcLiteralType), (Option.ofObj (src.Value)))  ))
        | :? ScriptDom.RealLiteral as src->
          ValueExpression.Literal((Literal.RealLiteral((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.LiteralType), (Option.ofObj (src.Value)))  ))
        | :? ScriptDom.StringLiteral as src->
          ValueExpression.Literal((Literal.StringLiteral((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.IsLargeObject), (src.IsNational), (src.LiteralType), (Option.ofObj (src.Value)))  ))
      | :? ScriptDom.VariableReference as src ->
        ValueExpression.VariableReference((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(Option.ofObj (src.Name)))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] FunctionStatementBody = (* IsAbstract = true *)
  | AlterFunctionStatement of MethodSpecifier:MethodSpecifier option * Name:SchemaObjectName option * Options:(FunctionOption) list * OrderHint:OrderBulkInsertOption option * Parameters:(ProcedureParameter) list * ReturnType:FunctionReturnType option * StatementList:StatementList option
  | CreateFunctionStatement of MethodSpecifier:MethodSpecifier option * Name:SchemaObjectName option * Options:(FunctionOption) list * OrderHint:OrderBulkInsertOption option * Parameters:(ProcedureParameter) list * ReturnType:FunctionReturnType option * StatementList:StatementList option
  | CreateOrAlterFunctionStatement of MethodSpecifier:MethodSpecifier option * Name:SchemaObjectName option * Options:(FunctionOption) list * OrderHint:OrderBulkInsertOption option * Parameters:(ProcedureParameter) list * ReturnType:FunctionReturnType option * StatementList:StatementList option
  member this.ToCs() : ScriptDom.FunctionStatementBody =
    match this with
    | AlterFunctionStatement(MethodSpecifier=aMethodSpecifier; Name=aName; Options=aOptions; OrderHint=aOrderHint; Parameters=aParameters; ReturnType=aReturnType; StatementList=aStatementList) ->
      let ret = ScriptDom.AlterFunctionStatement()
      ret.MethodSpecifier <- aMethodSpecifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.OrderHint <- aOrderHint |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret.ReturnType <- aReturnType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StatementList <- aStatementList |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.FunctionStatementBody (* 335 *)
    | CreateFunctionStatement(MethodSpecifier=aMethodSpecifier; Name=aName; Options=aOptions; OrderHint=aOrderHint; Parameters=aParameters; ReturnType=aReturnType; StatementList=aStatementList) ->
      let ret = ScriptDom.CreateFunctionStatement()
      ret.MethodSpecifier <- aMethodSpecifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.OrderHint <- aOrderHint |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret.ReturnType <- aReturnType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StatementList <- aStatementList |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.FunctionStatementBody (* 335 *)
    | CreateOrAlterFunctionStatement(MethodSpecifier=aMethodSpecifier; Name=aName; Options=aOptions; OrderHint=aOrderHint; Parameters=aParameters; ReturnType=aReturnType; StatementList=aStatementList) ->
      let ret = ScriptDom.CreateOrAlterFunctionStatement()
      ret.MethodSpecifier <- aMethodSpecifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.OrderHint <- aOrderHint |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret.ReturnType <- aReturnType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StatementList <- aStatementList |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.FunctionStatementBody (* 335 *)
  static member FromCs(src:ScriptDom.FunctionStatementBody, fragmentMapping:FragmentMapping) : FunctionStatementBody =
    let ret =
      match src with
      | :? ScriptDom.AlterFunctionStatement as src ->
        FunctionStatementBody.AlterFunctionStatement((src.MethodSpecifier |> Option.ofObj |> Option.map (fun x -> MethodSpecifier.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.Options |> Seq.map (fun x -> FunctionOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.OrderHint |> Option.ofObj |> Option.map (fun x -> OrderBulkInsertOption.FromCs(x, fragmentMapping))),(src.Parameters |> Seq.map (fun src -> ProcedureParameter.ProcedureParameter((src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.IsVarying), (src.Modifier), (src.Nullable |> Option.ofObj |> Option.map (fun x -> NullableConstraintDefinition.FromCs(x, fragmentMapping))), (src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.VariableName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.ReturnType |> Option.ofObj |> Option.map (fun x -> FunctionReturnType.FromCs(x, fragmentMapping))),(src.StatementList |> Option.ofObj |> Option.map (fun x -> StatementList.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CreateFunctionStatement as src ->
        FunctionStatementBody.CreateFunctionStatement((src.MethodSpecifier |> Option.ofObj |> Option.map (fun x -> MethodSpecifier.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.Options |> Seq.map (fun x -> FunctionOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.OrderHint |> Option.ofObj |> Option.map (fun x -> OrderBulkInsertOption.FromCs(x, fragmentMapping))),(src.Parameters |> Seq.map (fun src -> ProcedureParameter.ProcedureParameter((src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.IsVarying), (src.Modifier), (src.Nullable |> Option.ofObj |> Option.map (fun x -> NullableConstraintDefinition.FromCs(x, fragmentMapping))), (src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.VariableName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.ReturnType |> Option.ofObj |> Option.map (fun x -> FunctionReturnType.FromCs(x, fragmentMapping))),(src.StatementList |> Option.ofObj |> Option.map (fun x -> StatementList.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CreateOrAlterFunctionStatement as src ->
        FunctionStatementBody.CreateOrAlterFunctionStatement((src.MethodSpecifier |> Option.ofObj |> Option.map (fun x -> MethodSpecifier.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.Options |> Seq.map (fun x -> FunctionOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.OrderHint |> Option.ofObj |> Option.map (fun x -> OrderBulkInsertOption.FromCs(x, fragmentMapping))),(src.Parameters |> Seq.map (fun src -> ProcedureParameter.ProcedureParameter((src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.IsVarying), (src.Modifier), (src.Nullable |> Option.ofObj |> Option.map (fun x -> NullableConstraintDefinition.FromCs(x, fragmentMapping))), (src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.VariableName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.ReturnType |> Option.ofObj |> Option.map (fun x -> FunctionReturnType.FromCs(x, fragmentMapping))),(src.StatementList |> Option.ofObj |> Option.map (fun x -> StatementList.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ProcedureStatementBody = (* IsAbstract = true *)
  | AlterProcedureStatement of IsForReplication:bool * MethodSpecifier:MethodSpecifier option * Options:(ProcedureOption) list * Parameters:(ProcedureParameter) list * ProcedureReference:ProcedureReference option * StatementList:StatementList option
  | CreateOrAlterProcedureStatement of IsForReplication:bool * MethodSpecifier:MethodSpecifier option * Options:(ProcedureOption) list * Parameters:(ProcedureParameter) list * ProcedureReference:ProcedureReference option * StatementList:StatementList option
  | CreateProcedureStatement of IsForReplication:bool * MethodSpecifier:MethodSpecifier option * Options:(ProcedureOption) list * Parameters:(ProcedureParameter) list * ProcedureReference:ProcedureReference option * StatementList:StatementList option
  member this.ToCs() : ScriptDom.ProcedureStatementBody =
    match this with
    | AlterProcedureStatement(IsForReplication=aIsForReplication; MethodSpecifier=aMethodSpecifier; Options=aOptions; Parameters=aParameters; ProcedureReference=aProcedureReference; StatementList=aStatementList) ->
      let ret = ScriptDom.AlterProcedureStatement()
      ret.IsForReplication <- aIsForReplication
      ret.MethodSpecifier <- aMethodSpecifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret.ProcedureReference <- aProcedureReference |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StatementList <- aStatementList |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ProcedureStatementBody (* 335 *)
    | CreateOrAlterProcedureStatement(IsForReplication=aIsForReplication; MethodSpecifier=aMethodSpecifier; Options=aOptions; Parameters=aParameters; ProcedureReference=aProcedureReference; StatementList=aStatementList) ->
      let ret = ScriptDom.CreateOrAlterProcedureStatement()
      ret.IsForReplication <- aIsForReplication
      ret.MethodSpecifier <- aMethodSpecifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret.ProcedureReference <- aProcedureReference |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StatementList <- aStatementList |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ProcedureStatementBody (* 335 *)
    | CreateProcedureStatement(IsForReplication=aIsForReplication; MethodSpecifier=aMethodSpecifier; Options=aOptions; Parameters=aParameters; ProcedureReference=aProcedureReference; StatementList=aStatementList) ->
      let ret = ScriptDom.CreateProcedureStatement()
      ret.IsForReplication <- aIsForReplication
      ret.MethodSpecifier <- aMethodSpecifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret.ProcedureReference <- aProcedureReference |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StatementList <- aStatementList |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ProcedureStatementBody (* 335 *)
  static member FromCs(src:ScriptDom.ProcedureStatementBody, fragmentMapping:FragmentMapping) : ProcedureStatementBody =
    let ret =
      match src with
      | :? ScriptDom.AlterProcedureStatement as src ->
        ProcedureStatementBody.AlterProcedureStatement((src.IsForReplication),(src.MethodSpecifier |> Option.ofObj |> Option.map (fun x -> MethodSpecifier.FromCs(x, fragmentMapping))),(src.Options |> Seq.map (fun x -> ProcedureOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Parameters |> Seq.map (fun src -> ProcedureParameter.ProcedureParameter((src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.IsVarying), (src.Modifier), (src.Nullable |> Option.ofObj |> Option.map (fun x -> NullableConstraintDefinition.FromCs(x, fragmentMapping))), (src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.VariableName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.ProcedureReference |> Option.ofObj |> Option.map (fun x -> ProcedureReference.FromCs(x, fragmentMapping))),(src.StatementList |> Option.ofObj |> Option.map (fun x -> StatementList.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CreateOrAlterProcedureStatement as src ->
        ProcedureStatementBody.CreateOrAlterProcedureStatement((src.IsForReplication),(src.MethodSpecifier |> Option.ofObj |> Option.map (fun x -> MethodSpecifier.FromCs(x, fragmentMapping))),(src.Options |> Seq.map (fun x -> ProcedureOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Parameters |> Seq.map (fun src -> ProcedureParameter.ProcedureParameter((src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.IsVarying), (src.Modifier), (src.Nullable |> Option.ofObj |> Option.map (fun x -> NullableConstraintDefinition.FromCs(x, fragmentMapping))), (src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.VariableName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.ProcedureReference |> Option.ofObj |> Option.map (fun x -> ProcedureReference.FromCs(x, fragmentMapping))),(src.StatementList |> Option.ofObj |> Option.map (fun x -> StatementList.FromCs(x, fragmentMapping))))
      | :? ScriptDom.CreateProcedureStatement as src ->
        ProcedureStatementBody.CreateProcedureStatement((src.IsForReplication),(src.MethodSpecifier |> Option.ofObj |> Option.map (fun x -> MethodSpecifier.FromCs(x, fragmentMapping))),(src.Options |> Seq.map (fun x -> ProcedureOption.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Parameters |> Seq.map (fun src -> ProcedureParameter.ProcedureParameter((src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.IsVarying), (src.Modifier), (src.Nullable |> Option.ofObj |> Option.map (fun x -> NullableConstraintDefinition.FromCs(x, fragmentMapping))), (src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.VariableName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))) |> List.ofSeq),(src.ProcedureReference |> Option.ofObj |> Option.map (fun x -> ProcedureReference.FromCs(x, fragmentMapping))),(src.StatementList |> Option.ofObj |> Option.map (fun x -> StatementList.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] AlterRoleStatement = (* IsAbstract = false *)
  | Base of Action:AlterRoleAction option * Name:Identifier option
  | AlterServerRoleStatement of Action:AlterRoleAction option * Name:Identifier option
  member this.ToCs() : ScriptDom.AlterRoleStatement =
    match this with
    | AlterServerRoleStatement(Action=aAction; Name=aName) ->
      let ret = ScriptDom.AlterServerRoleStatement()
      ret.Action <- aAction |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AlterRoleStatement (* 335 *)
    | Base(Action=aAction; Name=aName) ->

      let ret = ScriptDom.AlterRoleStatement()
      ret.Action <- aAction |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret
  static member FromCs(src:ScriptDom.AlterRoleStatement, fragmentMapping:FragmentMapping) : AlterRoleStatement =
    let ret =
      match src with
      | :? ScriptDom.AlterServerRoleStatement as src ->
        AlterRoleStatement.AlterServerRoleStatement((src.Action |> Option.ofObj |> Option.map (fun x -> AlterRoleAction.FromCs(x, fragmentMapping))),(src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | _ -> (* :? ScriptDom.AlterRoleStatement as src *)
        AlterRoleStatement.Base(((src.Action |> Option.ofObj |> Option.map (fun x -> AlterRoleAction.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] CreateRoleStatement = (* IsAbstract = false *)
  | Base of Name:Identifier option * Owner:Identifier option
  | CreateServerRoleStatement of Name:Identifier option * Owner:Identifier option
  member this.ToCs() : ScriptDom.CreateRoleStatement =
    match this with
    | CreateServerRoleStatement(Name=aName; Owner=aOwner) ->
      let ret = ScriptDom.CreateServerRoleStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Owner <- aOwner |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CreateRoleStatement (* 335 *)
    | Base(Name=aName; Owner=aOwner) ->

      let ret = ScriptDom.CreateRoleStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Owner <- aOwner |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret
  static member FromCs(src:ScriptDom.CreateRoleStatement, fragmentMapping:FragmentMapping) : CreateRoleStatement =
    let ret =
      match src with
      | :? ScriptDom.CreateServerRoleStatement as src ->
        CreateRoleStatement.CreateServerRoleStatement((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Owner |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
      | _ -> (* :? ScriptDom.CreateRoleStatement as src *)
        CreateRoleStatement.Base(((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Owner |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] DataModificationStatement = (* IsAbstract = true *)
  | DeleteStatement of DeleteSpecification:DeleteSpecification option * OptimizerHints:(OptimizerHint) list * WithCtesAndXmlNamespaces:WithCtesAndXmlNamespaces option
  | InsertStatement of InsertSpecification:InsertSpecification option * OptimizerHints:(OptimizerHint) list * WithCtesAndXmlNamespaces:WithCtesAndXmlNamespaces option
  | MergeStatement of MergeSpecification:MergeSpecification option * OptimizerHints:(OptimizerHint) list * WithCtesAndXmlNamespaces:WithCtesAndXmlNamespaces option
  | UpdateStatement of OptimizerHints:(OptimizerHint) list * UpdateSpecification:UpdateSpecification option * WithCtesAndXmlNamespaces:WithCtesAndXmlNamespaces option
  member this.ToCs() : ScriptDom.DataModificationStatement =
    match this with
    | DeleteStatement(DeleteSpecification=aDeleteSpecification; OptimizerHints=aOptimizerHints; WithCtesAndXmlNamespaces=aWithCtesAndXmlNamespaces) ->
      let ret = ScriptDom.DeleteStatement()
      ret.DeleteSpecification <- aDeleteSpecification |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptimizerHints do ret.OptimizerHints.Add (e.ToCs())
      ret.WithCtesAndXmlNamespaces <- aWithCtesAndXmlNamespaces |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DataModificationStatement (* 335 *)
    | InsertStatement(InsertSpecification=aInsertSpecification; OptimizerHints=aOptimizerHints; WithCtesAndXmlNamespaces=aWithCtesAndXmlNamespaces) ->
      let ret = ScriptDom.InsertStatement()
      ret.InsertSpecification <- aInsertSpecification |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptimizerHints do ret.OptimizerHints.Add (e.ToCs())
      ret.WithCtesAndXmlNamespaces <- aWithCtesAndXmlNamespaces |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DataModificationStatement (* 335 *)
    | MergeStatement(MergeSpecification=aMergeSpecification; OptimizerHints=aOptimizerHints; WithCtesAndXmlNamespaces=aWithCtesAndXmlNamespaces) ->
      let ret = ScriptDom.MergeStatement()
      ret.MergeSpecification <- aMergeSpecification |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptimizerHints do ret.OptimizerHints.Add (e.ToCs())
      ret.WithCtesAndXmlNamespaces <- aWithCtesAndXmlNamespaces |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DataModificationStatement (* 335 *)
    | UpdateStatement(OptimizerHints=aOptimizerHints; UpdateSpecification=aUpdateSpecification; WithCtesAndXmlNamespaces=aWithCtesAndXmlNamespaces) ->
      let ret = ScriptDom.UpdateStatement()
      for e in aOptimizerHints do ret.OptimizerHints.Add (e.ToCs())
      ret.UpdateSpecification <- aUpdateSpecification |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WithCtesAndXmlNamespaces <- aWithCtesAndXmlNamespaces |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DataModificationStatement (* 335 *)
  static member FromCs(src:ScriptDom.DataModificationStatement, fragmentMapping:FragmentMapping) : DataModificationStatement =
    let ret =
      match src with
      | :? ScriptDom.DeleteStatement as src ->
        DataModificationStatement.DeleteStatement((src.DeleteSpecification |> Option.ofObj |> Option.map (fun x -> DeleteSpecification.FromCs(x, fragmentMapping))),(src.OptimizerHints |> Seq.map (fun x -> OptimizerHint.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.WithCtesAndXmlNamespaces |> Option.ofObj |> Option.map (fun x -> WithCtesAndXmlNamespaces.FromCs(x, fragmentMapping))))
      | :? ScriptDom.InsertStatement as src ->
        DataModificationStatement.InsertStatement((src.InsertSpecification |> Option.ofObj |> Option.map (fun x -> InsertSpecification.FromCs(x, fragmentMapping))),(src.OptimizerHints |> Seq.map (fun x -> OptimizerHint.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.WithCtesAndXmlNamespaces |> Option.ofObj |> Option.map (fun x -> WithCtesAndXmlNamespaces.FromCs(x, fragmentMapping))))
      | :? ScriptDom.MergeStatement as src ->
        DataModificationStatement.MergeStatement((src.MergeSpecification |> Option.ofObj |> Option.map (fun x -> MergeSpecification.FromCs(x, fragmentMapping))),(src.OptimizerHints |> Seq.map (fun x -> OptimizerHint.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.WithCtesAndXmlNamespaces |> Option.ofObj |> Option.map (fun x -> WithCtesAndXmlNamespaces.FromCs(x, fragmentMapping))))
      | :? ScriptDom.UpdateStatement as src ->
        DataModificationStatement.UpdateStatement((src.OptimizerHints |> Seq.map (fun x -> OptimizerHint.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.UpdateSpecification |> Option.ofObj |> Option.map (fun x -> UpdateSpecification.FromCs(x, fragmentMapping))),(src.WithCtesAndXmlNamespaces |> Option.ofObj |> Option.map (fun x -> WithCtesAndXmlNamespaces.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] SelectStatement = (* IsAbstract = false *)
  | Base of ComputeClauses:(ComputeClause) list * Into:SchemaObjectName option * On:Identifier option * OptimizerHints:(OptimizerHint) list * QueryExpression:QueryExpression option * WithCtesAndXmlNamespaces:WithCtesAndXmlNamespaces option
  | SelectStatementSnippet of ComputeClauses:(ComputeClause) list * Into:SchemaObjectName option * On:Identifier option * OptimizerHints:(OptimizerHint) list * QueryExpression:QueryExpression option * Script:String option * WithCtesAndXmlNamespaces:WithCtesAndXmlNamespaces option
  member this.ToCs() : ScriptDom.SelectStatement =
    match this with
    | SelectStatementSnippet(ComputeClauses=aComputeClauses; Into=aInto; On=aOn; OptimizerHints=aOptimizerHints; QueryExpression=aQueryExpression; Script=aScript; WithCtesAndXmlNamespaces=aWithCtesAndXmlNamespaces) ->
      let ret = ScriptDom.SelectStatementSnippet()
      for e in aComputeClauses do ret.ComputeClauses.Add (e.ToCs())
      ret.Into <- aInto |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.On <- aOn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptimizerHints do ret.OptimizerHints.Add (e.ToCs())
      ret.QueryExpression <- aQueryExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Script <- aScript |> Option.toObj
      ret.WithCtesAndXmlNamespaces <- aWithCtesAndXmlNamespaces |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SelectStatement (* 335 *)
    | Base(ComputeClauses=aComputeClauses; Into=aInto; On=aOn; OptimizerHints=aOptimizerHints; QueryExpression=aQueryExpression; WithCtesAndXmlNamespaces=aWithCtesAndXmlNamespaces) ->

      let ret = ScriptDom.SelectStatement()
      for e in aComputeClauses do ret.ComputeClauses.Add (e.ToCs())
      ret.Into <- aInto |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.On <- aOn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptimizerHints do ret.OptimizerHints.Add (e.ToCs())
      ret.QueryExpression <- aQueryExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WithCtesAndXmlNamespaces <- aWithCtesAndXmlNamespaces |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret
  static member FromCs(src:ScriptDom.SelectStatement, fragmentMapping:FragmentMapping) : SelectStatement =
    let ret =
      match src with
      | :? ScriptDom.SelectStatementSnippet as src ->
        SelectStatement.SelectStatementSnippet((src.ComputeClauses |> Seq.map (fun src -> ComputeClause.ComputeClause((src.ByExpressions |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.ComputeFunctions |> Seq.map (fun src -> ComputeFunction.ComputeFunction((src.ComputeFunctionType), (src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq))) |> List.ofSeq),(src.Into |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))),(src.On |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.OptimizerHints |> Seq.map (fun x -> OptimizerHint.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.QueryExpression |> Option.ofObj |> Option.map (fun x -> QueryExpression.FromCs(x, fragmentMapping))),(Option.ofObj (src.Script)),(src.WithCtesAndXmlNamespaces |> Option.ofObj |> Option.map (fun x -> WithCtesAndXmlNamespaces.FromCs(x, fragmentMapping))))
      | _ -> (* :? ScriptDom.SelectStatement as src *)
        SelectStatement.Base(((src.ComputeClauses |> Seq.map (fun src -> ComputeClause.ComputeClause((src.ByExpressions |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.ComputeFunctions |> Seq.map (fun src -> ComputeFunction.ComputeFunction((src.ComputeFunctionType), (src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq))) |> List.ofSeq), (src.Into |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.On |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.OptimizerHints |> Seq.map (fun x -> OptimizerHint.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.QueryExpression |> Option.ofObj |> Option.map (fun x -> QueryExpression.FromCs(x, fragmentMapping))), (src.WithCtesAndXmlNamespaces |> Option.ofObj |> Option.map (fun x -> WithCtesAndXmlNamespaces.FromCs(x, fragmentMapping))))  )
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] TableReferenceWithAliasAndColumns = (* IsAbstract = true *)
  | BulkOpenRowset of Alias:Identifier option * Columns:(Identifier) list * DataFile:StringLiteral option * Options:(BulkInsertOption) list
  | ChangeTableChangesTableReference of Alias:Identifier option * Columns:(Identifier) list * SinceVersion:ValueExpression option * Target:SchemaObjectName option
  | ChangeTableVersionTableReference of Alias:Identifier option * Columns:(Identifier) list * PrimaryKeyColumns:(Identifier) list * PrimaryKeyValues:(ScalarExpression) list * Target:SchemaObjectName option
  | DataModificationTableReference of Alias:Identifier option * Columns:(Identifier) list * DataModificationSpecification:DataModificationSpecification option
  | InlineDerivedTable of Alias:Identifier option * Columns:(Identifier) list * RowValues:(RowValue) list
  | QueryDerivedTable of Alias:Identifier option * Columns:(Identifier) list * QueryExpression:QueryExpression option
  | SchemaObjectFunctionTableReference of Alias:Identifier option * Columns:(Identifier) list * Parameters:(ScalarExpression) list * SchemaObject:SchemaObjectName option
  | VariableMethodCallTableReference of Alias:Identifier option * Columns:(Identifier) list * MethodName:Identifier option * Parameters:(ScalarExpression) list * Variable:VariableReference option
  member this.ToCs() : ScriptDom.TableReferenceWithAliasAndColumns =
    match this with
    | BulkOpenRowset(Alias=aAlias; Columns=aColumns; DataFile=aDataFile; Options=aOptions) ->
      let ret = ScriptDom.BulkOpenRowset()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.DataFile <- aDataFile |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.TableReferenceWithAliasAndColumns (* 335 *)
    | ChangeTableChangesTableReference(Alias=aAlias; Columns=aColumns; SinceVersion=aSinceVersion; Target=aTarget) ->
      let ret = ScriptDom.ChangeTableChangesTableReference()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.SinceVersion <- aSinceVersion |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Target <- aTarget |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableReferenceWithAliasAndColumns (* 335 *)
    | ChangeTableVersionTableReference(Alias=aAlias; Columns=aColumns; PrimaryKeyColumns=aPrimaryKeyColumns; PrimaryKeyValues=aPrimaryKeyValues; Target=aTarget) ->
      let ret = ScriptDom.ChangeTableVersionTableReference()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aColumns do ret.Columns.Add (e.ToCs())
      for e in aPrimaryKeyColumns do ret.PrimaryKeyColumns.Add (e.ToCs())
      for e in aPrimaryKeyValues do ret.PrimaryKeyValues.Add (e.ToCs())
      ret.Target <- aTarget |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableReferenceWithAliasAndColumns (* 335 *)
    | DataModificationTableReference(Alias=aAlias; Columns=aColumns; DataModificationSpecification=aDataModificationSpecification) ->
      let ret = ScriptDom.DataModificationTableReference()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.DataModificationSpecification <- aDataModificationSpecification |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableReferenceWithAliasAndColumns (* 335 *)
    | InlineDerivedTable(Alias=aAlias; Columns=aColumns; RowValues=aRowValues) ->
      let ret = ScriptDom.InlineDerivedTable()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aColumns do ret.Columns.Add (e.ToCs())
      for e in aRowValues do ret.RowValues.Add (e.ToCs())
      ret :> ScriptDom.TableReferenceWithAliasAndColumns (* 335 *)
    | QueryDerivedTable(Alias=aAlias; Columns=aColumns; QueryExpression=aQueryExpression) ->
      let ret = ScriptDom.QueryDerivedTable()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.QueryExpression <- aQueryExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableReferenceWithAliasAndColumns (* 335 *)
    | SchemaObjectFunctionTableReference(Alias=aAlias; Columns=aColumns; Parameters=aParameters; SchemaObject=aSchemaObject) ->
      let ret = ScriptDom.SchemaObjectFunctionTableReference()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aColumns do ret.Columns.Add (e.ToCs())
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret.SchemaObject <- aSchemaObject |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableReferenceWithAliasAndColumns (* 335 *)
    | VariableMethodCallTableReference(Alias=aAlias; Columns=aColumns; MethodName=aMethodName; Parameters=aParameters; Variable=aVariable) ->
      let ret = ScriptDom.VariableMethodCallTableReference()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.MethodName <- aMethodName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret.Variable <- aVariable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableReferenceWithAliasAndColumns (* 335 *)
  static member FromCs(src:ScriptDom.TableReferenceWithAliasAndColumns, fragmentMapping:FragmentMapping) : TableReferenceWithAliasAndColumns =
    let ret =
      match src with
      | :? ScriptDom.BulkOpenRowset as src ->
        TableReferenceWithAliasAndColumns.BulkOpenRowset((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.DataFile |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))),(src.Options |> Seq.map (fun x -> BulkInsertOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
      | :? ScriptDom.ChangeTableChangesTableReference as src ->
        TableReferenceWithAliasAndColumns.ChangeTableChangesTableReference((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.SinceVersion |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))),(src.Target |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.ChangeTableVersionTableReference as src ->
        TableReferenceWithAliasAndColumns.ChangeTableVersionTableReference((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.PrimaryKeyColumns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.PrimaryKeyValues |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Target |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.DataModificationTableReference as src ->
        TableReferenceWithAliasAndColumns.DataModificationTableReference((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.DataModificationSpecification |> Option.ofObj |> Option.map (fun x -> DataModificationSpecification.FromCs(x, fragmentMapping))))
      | :? ScriptDom.InlineDerivedTable as src ->
        TableReferenceWithAliasAndColumns.InlineDerivedTable((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.RowValues |> Seq.map (fun src -> RowValue.RowValue((src.ColumnValues |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq))) |> List.ofSeq))
      | :? ScriptDom.QueryDerivedTable as src ->
        TableReferenceWithAliasAndColumns.QueryDerivedTable((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.QueryExpression |> Option.ofObj |> Option.map (fun x -> QueryExpression.FromCs(x, fragmentMapping))))
      | :? ScriptDom.SchemaObjectFunctionTableReference as src ->
        TableReferenceWithAliasAndColumns.SchemaObjectFunctionTableReference((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Parameters |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.SchemaObject |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
      | :? ScriptDom.VariableMethodCallTableReference as src ->
        TableReferenceWithAliasAndColumns.VariableMethodCallTableReference((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.MethodName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.Parameters |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq),(src.Variable |> Option.ofObj |> Option.map (fun x -> VariableReference.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] Literal = (* IsAbstract = true *)
  | BinaryLiteral of Collation:Identifier option * IsLargeObject:bool * LiteralType:ScriptDom.LiteralType * Value:String option
  | DefaultLiteral of Collation:Identifier option * LiteralType:ScriptDom.LiteralType * Value:String option
  | IdentifierLiteral of Collation:Identifier option * LiteralType:ScriptDom.LiteralType * QuoteType:ScriptDom.QuoteType * Value:String option
  | IntegerLiteral of Collation:Identifier option * LiteralType:ScriptDom.LiteralType * Value:String option
  | MaxLiteral of Collation:Identifier option * LiteralType:ScriptDom.LiteralType * Value:String option
  | MoneyLiteral of Collation:Identifier option * LiteralType:ScriptDom.LiteralType * Value:String option
  | NullLiteral of Collation:Identifier option * LiteralType:ScriptDom.LiteralType * Value:String option
  | NumericLiteral of Collation:Identifier option * LiteralType:ScriptDom.LiteralType * Value:String option
  | OdbcLiteral of Collation:Identifier option * IsNational:bool * LiteralType:ScriptDom.LiteralType * OdbcLiteralType:ScriptDom.OdbcLiteralType * Value:String option
  | RealLiteral of Collation:Identifier option * LiteralType:ScriptDom.LiteralType * Value:String option
  | StringLiteral of Collation:Identifier option * IsLargeObject:bool * IsNational:bool * LiteralType:ScriptDom.LiteralType * Value:String option
  member this.ToCs() : ScriptDom.Literal =
    match this with
    | BinaryLiteral(Collation=aCollation; IsLargeObject=aIsLargeObject; LiteralType=aLiteralType; Value=aValue) ->
      let ret = ScriptDom.BinaryLiteral()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsLargeObject <- aIsLargeObject
       // Skipping prop LiteralType - it is Readonly
      ret.Value <- aValue |> Option.toObj
      ret :> ScriptDom.Literal (* 335 *)
    | DefaultLiteral(Collation=aCollation; LiteralType=aLiteralType; Value=aValue) ->
      let ret = ScriptDom.DefaultLiteral()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
       // Skipping prop LiteralType - it is Readonly
      ret.Value <- aValue |> Option.toObj
      ret :> ScriptDom.Literal (* 335 *)
    | IdentifierLiteral(Collation=aCollation; LiteralType=aLiteralType; QuoteType=aQuoteType; Value=aValue) ->
      let ret = ScriptDom.IdentifierLiteral()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
       // Skipping prop LiteralType - it is Readonly
      ret.QuoteType <- aQuoteType
      ret.Value <- aValue |> Option.toObj
      ret :> ScriptDom.Literal (* 335 *)
    | IntegerLiteral(Collation=aCollation; LiteralType=aLiteralType; Value=aValue) ->
      let ret = ScriptDom.IntegerLiteral()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
       // Skipping prop LiteralType - it is Readonly
      ret.Value <- aValue |> Option.toObj
      ret :> ScriptDom.Literal (* 335 *)
    | MaxLiteral(Collation=aCollation; LiteralType=aLiteralType; Value=aValue) ->
      let ret = ScriptDom.MaxLiteral()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
       // Skipping prop LiteralType - it is Readonly
      ret.Value <- aValue |> Option.toObj
      ret :> ScriptDom.Literal (* 335 *)
    | MoneyLiteral(Collation=aCollation; LiteralType=aLiteralType; Value=aValue) ->
      let ret = ScriptDom.MoneyLiteral()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
       // Skipping prop LiteralType - it is Readonly
      ret.Value <- aValue |> Option.toObj
      ret :> ScriptDom.Literal (* 335 *)
    | NullLiteral(Collation=aCollation; LiteralType=aLiteralType; Value=aValue) ->
      let ret = ScriptDom.NullLiteral()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
       // Skipping prop LiteralType - it is Readonly
      ret.Value <- aValue |> Option.toObj
      ret :> ScriptDom.Literal (* 335 *)
    | NumericLiteral(Collation=aCollation; LiteralType=aLiteralType; Value=aValue) ->
      let ret = ScriptDom.NumericLiteral()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
       // Skipping prop LiteralType - it is Readonly
      ret.Value <- aValue |> Option.toObj
      ret :> ScriptDom.Literal (* 335 *)
    | OdbcLiteral(Collation=aCollation; IsNational=aIsNational; LiteralType=aLiteralType; OdbcLiteralType=aOdbcLiteralType; Value=aValue) ->
      let ret = ScriptDom.OdbcLiteral()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsNational <- aIsNational
       // Skipping prop LiteralType - it is Readonly
      ret.OdbcLiteralType <- aOdbcLiteralType
      ret.Value <- aValue |> Option.toObj
      ret :> ScriptDom.Literal (* 335 *)
    | RealLiteral(Collation=aCollation; LiteralType=aLiteralType; Value=aValue) ->
      let ret = ScriptDom.RealLiteral()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
       // Skipping prop LiteralType - it is Readonly
      ret.Value <- aValue |> Option.toObj
      ret :> ScriptDom.Literal (* 335 *)
    | StringLiteral(Collation=aCollation; IsLargeObject=aIsLargeObject; IsNational=aIsNational; LiteralType=aLiteralType; Value=aValue) ->
      let ret = ScriptDom.StringLiteral()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsLargeObject <- aIsLargeObject
      ret.IsNational <- aIsNational
       // Skipping prop LiteralType - it is Readonly
      ret.Value <- aValue |> Option.toObj
      ret :> ScriptDom.Literal (* 335 *)
  static member FromCs(src:ScriptDom.Literal, fragmentMapping:FragmentMapping) : Literal =
    let ret =
      match src with
      | :? ScriptDom.BinaryLiteral as src ->
        Literal.BinaryLiteral((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.IsLargeObject),(src.LiteralType),(Option.ofObj (src.Value)))
      | :? ScriptDom.DefaultLiteral as src ->
        Literal.DefaultLiteral((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.LiteralType),(Option.ofObj (src.Value)))
      | :? ScriptDom.IdentifierLiteral as src ->
        Literal.IdentifierLiteral((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.LiteralType),(src.QuoteType),(Option.ofObj (src.Value)))
      | :? ScriptDom.IntegerLiteral as src ->
        Literal.IntegerLiteral((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.LiteralType),(Option.ofObj (src.Value)))
      | :? ScriptDom.MaxLiteral as src ->
        Literal.MaxLiteral((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.LiteralType),(Option.ofObj (src.Value)))
      | :? ScriptDom.MoneyLiteral as src ->
        Literal.MoneyLiteral((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.LiteralType),(Option.ofObj (src.Value)))
      | :? ScriptDom.NullLiteral as src ->
        Literal.NullLiteral((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.LiteralType),(Option.ofObj (src.Value)))
      | :? ScriptDom.NumericLiteral as src ->
        Literal.NumericLiteral((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.LiteralType),(Option.ofObj (src.Value)))
      | :? ScriptDom.OdbcLiteral as src ->
        Literal.OdbcLiteral((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.IsNational),(src.LiteralType),(src.OdbcLiteralType),(Option.ofObj (src.Value)))
      | :? ScriptDom.RealLiteral as src ->
        Literal.RealLiteral((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.LiteralType),(Option.ofObj (src.Value)))
      | :? ScriptDom.StringLiteral as src ->
        Literal.StringLiteral((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))),(src.IsLargeObject),(src.IsNational),(src.LiteralType),(Option.ofObj (src.Value)))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
// Rendering missing cases
and [<RequireQualifiedAccess>] StringLiteral = (* Abstract? = false *)
  | StringLiteral of Collation:Identifier option * IsLargeObject:bool * IsNational:bool * LiteralType:ScriptDom.LiteralType * Value:String option  
  member this.ToCs() : ScriptDom.StringLiteral =
    match this with
    | StringLiteral(Collation=aCollation; IsLargeObject=aIsLargeObject; IsNational=aIsNational; LiteralType=aLiteralType; Value=aValue) ->
      let ret = ScriptDom.StringLiteral()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsLargeObject <- aIsLargeObject
      ret.IsNational <- aIsNational
       // Skipping prop LiteralType - it is Readonly
      ret.Value <- aValue |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.StringLiteral, fragmentMapping:FragmentMapping) : StringLiteral =
    let ret =
      StringLiteral.StringLiteral((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.IsLargeObject), (src.IsNational), (src.LiteralType), (Option.ofObj (src.Value)))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] AlterAvailabilityGroupFailoverOption = (* Abstract? = false *)
  | AlterAvailabilityGroupFailoverOption of OptionKind:ScriptDom.FailoverActionOptionKind * Value:Literal option  
  member this.ToCs() : ScriptDom.AlterAvailabilityGroupFailoverOption =
    match this with
    | AlterAvailabilityGroupFailoverOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.AlterAvailabilityGroupFailoverOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.AlterAvailabilityGroupFailoverOption, fragmentMapping:FragmentMapping) : AlterAvailabilityGroupFailoverOption =
    let ret =
      AlterAvailabilityGroupFailoverOption.AlterAvailabilityGroupFailoverOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] FullTextIndexColumn = (* Abstract? = false *)
  | FullTextIndexColumn of LanguageTerm:IdentifierOrValueExpression option * Name:Identifier option * StatisticalSemantics:bool * TypeColumn:Identifier option  
  member this.ToCs() : ScriptDom.FullTextIndexColumn =
    match this with
    | FullTextIndexColumn(LanguageTerm=aLanguageTerm; Name=aName; StatisticalSemantics=aStatisticalSemantics; TypeColumn=aTypeColumn) ->
      let ret = ScriptDom.FullTextIndexColumn()
      ret.LanguageTerm <- aLanguageTerm |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StatisticalSemantics <- aStatisticalSemantics
      ret.TypeColumn <- aTypeColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.FullTextIndexColumn, fragmentMapping:FragmentMapping) : FullTextIndexColumn =
    let ret =
      FullTextIndexColumn.FullTextIndexColumn((src.LanguageTerm |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.StatisticalSemantics), (src.TypeColumn |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] SearchPropertyListFullTextIndexOption = (* Abstract? = false *)
  | SearchPropertyListFullTextIndexOption of IsOff:bool * OptionKind:ScriptDom.FullTextIndexOptionKind * PropertyListName:Identifier option  
  member this.ToCs() : ScriptDom.SearchPropertyListFullTextIndexOption =
    match this with
    | SearchPropertyListFullTextIndexOption(IsOff=aIsOff; OptionKind=aOptionKind; PropertyListName=aPropertyListName) ->
      let ret = ScriptDom.SearchPropertyListFullTextIndexOption()
      ret.IsOff <- aIsOff
      ret.OptionKind <- aOptionKind
      ret.PropertyListName <- aPropertyListName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.SearchPropertyListFullTextIndexOption, fragmentMapping:FragmentMapping) : SearchPropertyListFullTextIndexOption =
    let ret =
      SearchPropertyListFullTextIndexOption.SearchPropertyListFullTextIndexOption((src.IsOff), (src.OptionKind), (src.PropertyListName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] StopListFullTextIndexOption = (* Abstract? = false *)
  | StopListFullTextIndexOption of IsOff:bool * OptionKind:ScriptDom.FullTextIndexOptionKind * StopListName:Identifier option  
  member this.ToCs() : ScriptDom.StopListFullTextIndexOption =
    match this with
    | StopListFullTextIndexOption(IsOff=aIsOff; OptionKind=aOptionKind; StopListName=aStopListName) ->
      let ret = ScriptDom.StopListFullTextIndexOption()
      ret.IsOff <- aIsOff
      ret.OptionKind <- aOptionKind
      ret.StopListName <- aStopListName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.StopListFullTextIndexOption, fragmentMapping:FragmentMapping) : StopListFullTextIndexOption =
    let ret =
      StopListFullTextIndexOption.StopListFullTextIndexOption((src.IsOff), (src.OptionKind), (src.StopListName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] IdentifierOrValueExpression = (* Abstract? = false *)
  | IdentifierOrValueExpression of Identifier:Identifier option * Value:String option * ValueExpression:ValueExpression option  
  member this.ToCs() : ScriptDom.IdentifierOrValueExpression =
    match this with
    | IdentifierOrValueExpression(Identifier=aIdentifier; Value=aValue; ValueExpression=aValueExpression) ->
      let ret = ScriptDom.IdentifierOrValueExpression()
      ret.Identifier <- aIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
       // Skipping prop Value - it is Readonly
      ret.ValueExpression <- aValueExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.IdentifierOrValueExpression, fragmentMapping:FragmentMapping) : IdentifierOrValueExpression =
    let ret =
      IdentifierOrValueExpression.IdentifierOrValueExpression((src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (Option.ofObj (src.Value)), (src.ValueExpression |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] DatabaseAuditAction = (* Abstract? = false *)
  | DatabaseAuditAction of ActionKind:ScriptDom.DatabaseAuditActionKind  
  member this.ToCs() : ScriptDom.DatabaseAuditAction =
    match this with
    | DatabaseAuditAction(ActionKind=aActionKind) ->
      let ret = ScriptDom.DatabaseAuditAction()
      ret.ActionKind <- aActionKind
      ret (* 333 *)
  static member FromCs(src:ScriptDom.DatabaseAuditAction, fragmentMapping:FragmentMapping) : DatabaseAuditAction =
    let ret =
      DatabaseAuditAction.DatabaseAuditAction((src.ActionKind))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] SecurityPrincipal = (* Abstract? = false *)
  | SecurityPrincipal of Identifier:Identifier option * PrincipalType:ScriptDom.PrincipalType  
  member this.ToCs() : ScriptDom.SecurityPrincipal =
    match this with
    | SecurityPrincipal(Identifier=aIdentifier; PrincipalType=aPrincipalType) ->
      let ret = ScriptDom.SecurityPrincipal()
      ret.Identifier <- aIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PrincipalType <- aPrincipalType
      ret (* 333 *)
  static member FromCs(src:ScriptDom.SecurityPrincipal, fragmentMapping:FragmentMapping) : SecurityPrincipal =
    let ret =
      SecurityPrincipal.SecurityPrincipal((src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.PrincipalType))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] SecurityTargetObject = (* Abstract? = false *)
  | SecurityTargetObject of Columns:(Identifier) list * ObjectKind:ScriptDom.SecurityObjectKind * ObjectName:SecurityTargetObjectName option  
  member this.ToCs() : ScriptDom.SecurityTargetObject =
    match this with
    | SecurityTargetObject(Columns=aColumns; ObjectKind=aObjectKind; ObjectName=aObjectName) ->
      let ret = ScriptDom.SecurityTargetObject()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.ObjectKind <- aObjectKind
      ret.ObjectName <- aObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.SecurityTargetObject, fragmentMapping:FragmentMapping) : SecurityTargetObject =
    let ret =
      SecurityTargetObject.SecurityTargetObject((src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.ObjectKind), (src.ObjectName |> Option.ofObj |> Option.map (fun x -> SecurityTargetObjectName.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] CryptoMechanism = (* Abstract? = false *)
  | CryptoMechanism of CryptoMechanismType:ScriptDom.CryptoMechanismType * Identifier:Identifier option * PasswordOrSignature:Literal option  
  member this.ToCs() : ScriptDom.CryptoMechanism =
    match this with
    | CryptoMechanism(CryptoMechanismType=aCryptoMechanismType; Identifier=aIdentifier; PasswordOrSignature=aPasswordOrSignature) ->
      let ret = ScriptDom.CryptoMechanism()
      ret.CryptoMechanismType <- aCryptoMechanismType
      ret.Identifier <- aIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PasswordOrSignature <- aPasswordOrSignature |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.CryptoMechanism, fragmentMapping:FragmentMapping) : CryptoMechanism =
    let ret =
      CryptoMechanism.CryptoMechanism((src.CryptoMechanismType), (src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.PasswordOrSignature |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] EventSessionObjectName = (* Abstract? = false *)
  | EventSessionObjectName of MultiPartIdentifier:MultiPartIdentifier option  
  member this.ToCs() : ScriptDom.EventSessionObjectName =
    match this with
    | EventSessionObjectName(MultiPartIdentifier=aMultiPartIdentifier) ->
      let ret = ScriptDom.EventSessionObjectName()
      ret.MultiPartIdentifier <- aMultiPartIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.EventSessionObjectName, fragmentMapping:FragmentMapping) : EventSessionObjectName =
    let ret =
      EventSessionObjectName.EventSessionObjectName((src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] SourceDeclaration = (* Abstract? = false *)
  | SourceDeclaration of Value:EventSessionObjectName option  
  member this.ToCs() : ScriptDom.SourceDeclaration =
    match this with
    | SourceDeclaration(Value=aValue) ->
      let ret = ScriptDom.SourceDeclaration()
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.SourceDeclaration, fragmentMapping:FragmentMapping) : SourceDeclaration =
    let ret =
      SourceDeclaration.SourceDeclaration((src.Value |> Option.ofObj |> Option.map (fun x -> EventSessionObjectName.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ScalarSubquery = (* Abstract? = false *)
  | ScalarSubquery of Collation:Identifier option * QueryExpression:QueryExpression option  
  member this.ToCs() : ScriptDom.ScalarSubquery =
    match this with
    | ScalarSubquery(Collation=aCollation; QueryExpression=aQueryExpression) ->
      let ret = ScriptDom.ScalarSubquery()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.QueryExpression <- aQueryExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.ScalarSubquery, fragmentMapping:FragmentMapping) : ScalarSubquery =
    let ret =
      ScalarSubquery.ScalarSubquery((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.QueryExpression |> Option.ofObj |> Option.map (fun x -> QueryExpression.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ColumnReferenceExpression = (* Abstract? = false *)
  | ColumnReferenceExpression of Collation:Identifier option * ColumnType:ScriptDom.ColumnType * MultiPartIdentifier:MultiPartIdentifier option  
  member this.ToCs() : ScriptDom.ColumnReferenceExpression =
    match this with
    | ColumnReferenceExpression(Collation=aCollation; ColumnType=aColumnType; MultiPartIdentifier=aMultiPartIdentifier) ->
      let ret = ScriptDom.ColumnReferenceExpression()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ColumnType <- aColumnType
      ret.MultiPartIdentifier <- aMultiPartIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.ColumnReferenceExpression, fragmentMapping:FragmentMapping) : ColumnReferenceExpression =
    let ret =
      ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] GraphMatchNodeExpression = (* Abstract? = false *)
  | GraphMatchNodeExpression of Node:Identifier option * UsesLastNode:bool  
  member this.ToCs() : ScriptDom.GraphMatchNodeExpression =
    match this with
    | GraphMatchNodeExpression(Node=aNode; UsesLastNode=aUsesLastNode) ->
      let ret = ScriptDom.GraphMatchNodeExpression()
      ret.Node <- aNode |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UsesLastNode <- aUsesLastNode
      ret (* 333 *)
  static member FromCs(src:ScriptDom.GraphMatchNodeExpression, fragmentMapping:FragmentMapping) : GraphMatchNodeExpression =
    let ret =
      GraphMatchNodeExpression.GraphMatchNodeExpression((src.Node |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.UsesLastNode))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] GraphRecursiveMatchQuantifier = (* Abstract? = false *)
  | GraphRecursiveMatchQuantifier of IsPlusSign:bool * LowerLimit:Literal option * UpperLimit:Literal option  
  member this.ToCs() : ScriptDom.GraphRecursiveMatchQuantifier =
    match this with
    | GraphRecursiveMatchQuantifier(IsPlusSign=aIsPlusSign; LowerLimit=aLowerLimit; UpperLimit=aUpperLimit) ->
      let ret = ScriptDom.GraphRecursiveMatchQuantifier()
      ret.IsPlusSign <- aIsPlusSign
      ret.LowerLimit <- aLowerLimit |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UpperLimit <- aUpperLimit |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.GraphRecursiveMatchQuantifier, fragmentMapping:FragmentMapping) : GraphRecursiveMatchQuantifier =
    let ret =
      GraphRecursiveMatchQuantifier.GraphRecursiveMatchQuantifier((src.IsPlusSign), (src.LowerLimit |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.UpperLimit |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ColumnWithSortOrder = (* Abstract? = false *)
  | ColumnWithSortOrder of Column:ColumnReferenceExpression option * SortOrder:ScriptDom.SortOrder  
  member this.ToCs() : ScriptDom.ColumnWithSortOrder =
    match this with
    | ColumnWithSortOrder(Column=aColumn; SortOrder=aSortOrder) ->
      let ret = ScriptDom.ColumnWithSortOrder()
      ret.Column <- aColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SortOrder <- aSortOrder
      ret (* 333 *)
  static member FromCs(src:ScriptDom.ColumnWithSortOrder, fragmentMapping:FragmentMapping) : ColumnWithSortOrder =
    let ret =
      ColumnWithSortOrder.ColumnWithSortOrder((src.Column |> Option.ofObj |> Option.map (fun x -> ColumnReferenceExpression.FromCs(x, fragmentMapping))), (src.SortOrder))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] DefaultConstraintDefinition = (* Abstract? = false *)
  | DefaultConstraintDefinition of Column:Identifier option * ConstraintIdentifier:Identifier option * Expression:ScalarExpression option * WithValues:bool  
  member this.ToCs() : ScriptDom.DefaultConstraintDefinition =
    match this with
    | DefaultConstraintDefinition(Column=aColumn; ConstraintIdentifier=aConstraintIdentifier; Expression=aExpression; WithValues=aWithValues) ->
      let ret = ScriptDom.DefaultConstraintDefinition()
      ret.Column <- aColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ConstraintIdentifier <- aConstraintIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WithValues <- aWithValues
      ret (* 333 *)
  static member FromCs(src:ScriptDom.DefaultConstraintDefinition, fragmentMapping:FragmentMapping) : DefaultConstraintDefinition =
    let ret =
      DefaultConstraintDefinition.DefaultConstraintDefinition((src.Column |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ConstraintIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.WithValues))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ColumnEncryptionDefinition = (* Abstract? = false *)
  | ColumnEncryptionDefinition of Parameters:(ColumnEncryptionDefinitionParameter) list  
  member this.ToCs() : ScriptDom.ColumnEncryptionDefinition =
    match this with
    | ColumnEncryptionDefinition(Parameters=aParameters) ->
      let ret = ScriptDom.ColumnEncryptionDefinition()
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret (* 333 *)
  static member FromCs(src:ScriptDom.ColumnEncryptionDefinition, fragmentMapping:FragmentMapping) : ColumnEncryptionDefinition =
    let ret =
      ColumnEncryptionDefinition.ColumnEncryptionDefinition((src.Parameters |> Seq.map (fun x -> ColumnEncryptionDefinitionParameter.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] GeneratedAlwaysType = (* Abstract? = false *)
  | GeneratedAlwaysType   
  member this.ToCs() : ScriptDom.GeneratedAlwaysType =
    match this with
    | GeneratedAlwaysType -> ScriptDom.GeneratedAlwaysType() (* 327 *)
  static member FromCs(src:ScriptDom.GeneratedAlwaysType, fragmentMapping:FragmentMapping) : GeneratedAlwaysType =
    let ret =
      GeneratedAlwaysType.GeneratedAlwaysType 
    ret
and [<RequireQualifiedAccess>] IdentityOptions = (* Abstract? = false *)
  | IdentityOptions of IdentityIncrement:ScalarExpression option * IdentitySeed:ScalarExpression option * IsIdentityNotForReplication:bool  
  member this.ToCs() : ScriptDom.IdentityOptions =
    match this with
    | IdentityOptions(IdentityIncrement=aIdentityIncrement; IdentitySeed=aIdentitySeed; IsIdentityNotForReplication=aIsIdentityNotForReplication) ->
      let ret = ScriptDom.IdentityOptions()
      ret.IdentityIncrement <- aIdentityIncrement |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IdentitySeed <- aIdentitySeed |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsIdentityNotForReplication <- aIsIdentityNotForReplication
      ret (* 333 *)
  static member FromCs(src:ScriptDom.IdentityOptions, fragmentMapping:FragmentMapping) : IdentityOptions =
    let ret =
      IdentityOptions.IdentityOptions((src.IdentityIncrement |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.IdentitySeed |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.IsIdentityNotForReplication))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] IndexDefinition = (* Abstract? = false *)
  | IndexDefinition of Columns:(ColumnWithSortOrder) list * FileStreamOn:IdentifierOrValueExpression option * FilterPredicate:BooleanExpression option * IndexOptions:(IndexOption) list * IndexType:IndexType option * Name:Identifier option * OnFileGroupOrPartitionScheme:FileGroupOrPartitionScheme option * Unique:bool  
  member this.ToCs() : ScriptDom.IndexDefinition =
    match this with
    | IndexDefinition(Columns=aColumns; FileStreamOn=aFileStreamOn; FilterPredicate=aFilterPredicate; IndexOptions=aIndexOptions; IndexType=aIndexType; Name=aName; OnFileGroupOrPartitionScheme=aOnFileGroupOrPartitionScheme; Unique=aUnique) ->
      let ret = ScriptDom.IndexDefinition()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.FileStreamOn <- aFileStreamOn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FilterPredicate <- aFilterPredicate |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aIndexOptions do ret.IndexOptions.Add (e.ToCs())
      ret.IndexType <- aIndexType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OnFileGroupOrPartitionScheme <- aOnFileGroupOrPartitionScheme |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Unique <- aUnique
      ret (* 333 *)
  static member FromCs(src:ScriptDom.IndexDefinition, fragmentMapping:FragmentMapping) : IndexDefinition =
    let ret =
      IndexDefinition.IndexDefinition((src.Columns |> Seq.map (fun src -> ColumnWithSortOrder.ColumnWithSortOrder((src.Column |> Option.ofObj |> Option.map (fun x -> ColumnReferenceExpression.FromCs(x, fragmentMapping))), (src.SortOrder))) |> List.ofSeq), (src.FileStreamOn |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.FilterPredicate |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))), (src.IndexOptions |> Seq.map (fun x -> IndexOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.IndexType |> Option.ofObj |> Option.map (fun x -> IndexType.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.OnFileGroupOrPartitionScheme |> Option.ofObj |> Option.map (fun x -> FileGroupOrPartitionScheme.FromCs(x, fragmentMapping))), (src.Unique))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ColumnStorageOptions = (* Abstract? = false *)
  | ColumnStorageOptions of IsFileStream:bool * SparseOption:ScriptDom.SparseColumnOption  
  member this.ToCs() : ScriptDom.ColumnStorageOptions =
    match this with
    | ColumnStorageOptions(IsFileStream=aIsFileStream; SparseOption=aSparseOption) ->
      let ret = ScriptDom.ColumnStorageOptions()
      ret.IsFileStream <- aIsFileStream
      ret.SparseOption <- aSparseOption
      ret (* 333 *)
  static member FromCs(src:ScriptDom.ColumnStorageOptions, fragmentMapping:FragmentMapping) : ColumnStorageOptions =
    let ret =
      ColumnStorageOptions.ColumnStorageOptions((src.IsFileStream), (src.SparseOption))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] BinaryLiteral = (* Abstract? = false *)
  | BinaryLiteral of Collation:Identifier option * IsLargeObject:bool * LiteralType:ScriptDom.LiteralType * Value:String option  
  member this.ToCs() : ScriptDom.BinaryLiteral =
    match this with
    | BinaryLiteral(Collation=aCollation; IsLargeObject=aIsLargeObject; LiteralType=aLiteralType; Value=aValue) ->
      let ret = ScriptDom.BinaryLiteral()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsLargeObject <- aIsLargeObject
       // Skipping prop LiteralType - it is Readonly
      ret.Value <- aValue |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.BinaryLiteral, fragmentMapping:FragmentMapping) : BinaryLiteral =
    let ret =
      BinaryLiteral.BinaryLiteral((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.IsLargeObject), (src.LiteralType), (Option.ofObj (src.Value)))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ComputeFunction = (* Abstract? = false *)
  | ComputeFunction of ComputeFunctionType:ScriptDom.ComputeFunctionType * Expression:ScalarExpression option  
  member this.ToCs() : ScriptDom.ComputeFunction =
    match this with
    | ComputeFunction(ComputeFunctionType=aComputeFunctionType; Expression=aExpression) ->
      let ret = ScriptDom.ComputeFunction()
      ret.ComputeFunctionType <- aComputeFunctionType
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.ComputeFunction, fragmentMapping:FragmentMapping) : ComputeFunction =
    let ret =
      ComputeFunction.ComputeFunction((src.ComputeFunctionType), (src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] GraphConnectionBetweenNodes = (* Abstract? = false *)
  | GraphConnectionBetweenNodes of FromNode:SchemaObjectName option * ToNode:SchemaObjectName option  
  member this.ToCs() : ScriptDom.GraphConnectionBetweenNodes =
    match this with
    | GraphConnectionBetweenNodes(FromNode=aFromNode; ToNode=aToNode) ->
      let ret = ScriptDom.GraphConnectionBetweenNodes()
      ret.FromNode <- aFromNode |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ToNode <- aToNode |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.GraphConnectionBetweenNodes, fragmentMapping:FragmentMapping) : GraphConnectionBetweenNodes =
    let ret =
      GraphConnectionBetweenNodes.GraphConnectionBetweenNodes((src.FromNode |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.ToNode |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] IndexType = (* Abstract? = false *)
  | IndexType of IndexTypeKind:(ScriptDom.IndexTypeKind) option  
  member this.ToCs() : ScriptDom.IndexType =
    match this with
    | IndexType(IndexTypeKind=aIndexTypeKind) ->
      let ret = ScriptDom.IndexType()
      ret.IndexTypeKind <- Option.toNullable aIndexTypeKind
      ret (* 333 *)
  static member FromCs(src:ScriptDom.IndexType, fragmentMapping:FragmentMapping) : IndexType =
    let ret =
      IndexType.IndexType((Option.ofNullable (src.IndexTypeKind)))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] FileGroupOrPartitionScheme = (* Abstract? = false *)
  | FileGroupOrPartitionScheme of Name:IdentifierOrValueExpression option * PartitionSchemeColumns:(Identifier) list  
  member this.ToCs() : ScriptDom.FileGroupOrPartitionScheme =
    match this with
    | FileGroupOrPartitionScheme(Name=aName; PartitionSchemeColumns=aPartitionSchemeColumns) ->
      let ret = ScriptDom.FileGroupOrPartitionScheme()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aPartitionSchemeColumns do ret.PartitionSchemeColumns.Add (e.ToCs())
      ret (* 333 *)
  static member FromCs(src:ScriptDom.FileGroupOrPartitionScheme, fragmentMapping:FragmentMapping) : FileGroupOrPartitionScheme =
    let ret =
      FileGroupOrPartitionScheme.FileGroupOrPartitionScheme((src.Name |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.PartitionSchemeColumns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] IntegerLiteral = (* Abstract? = false *)
  | IntegerLiteral of Collation:Identifier option * LiteralType:ScriptDom.LiteralType * Value:String option  
  member this.ToCs() : ScriptDom.IntegerLiteral =
    match this with
    | IntegerLiteral(Collation=aCollation; LiteralType=aLiteralType; Value=aValue) ->
      let ret = ScriptDom.IntegerLiteral()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
       // Skipping prop LiteralType - it is Readonly
      ret.Value <- aValue |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.IntegerLiteral, fragmentMapping:FragmentMapping) : IntegerLiteral =
    let ret =
      IntegerLiteral.IntegerLiteral((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.LiteralType), (Option.ofObj (src.Value)))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] CursorOption = (* Abstract? = false *)
  | CursorOption of OptionKind:ScriptDom.CursorOptionKind  
  member this.ToCs() : ScriptDom.CursorOption =
    match this with
    | CursorOption(OptionKind=aOptionKind) ->
      let ret = ScriptDom.CursorOption()
      ret.OptionKind <- aOptionKind
      ret (* 333 *)
  static member FromCs(src:ScriptDom.CursorOption, fragmentMapping:FragmentMapping) : CursorOption =
    let ret =
      CursorOption.CursorOption((src.OptionKind))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] OutputClause = (* Abstract? = false *)
  | OutputClause of SelectColumns:(SelectElement) list  
  member this.ToCs() : ScriptDom.OutputClause =
    match this with
    | OutputClause(SelectColumns=aSelectColumns) ->
      let ret = ScriptDom.OutputClause()
      for e in aSelectColumns do ret.SelectColumns.Add (e.ToCs())
      ret (* 333 *)
  static member FromCs(src:ScriptDom.OutputClause, fragmentMapping:FragmentMapping) : OutputClause =
    let ret =
      OutputClause.OutputClause((src.SelectColumns |> Seq.map (fun x -> SelectElement.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] OutputIntoClause = (* Abstract? = false *)
  | OutputIntoClause of IntoTable:TableReference option * IntoTableColumns:(ColumnReferenceExpression) list * SelectColumns:(SelectElement) list  
  member this.ToCs() : ScriptDom.OutputIntoClause =
    match this with
    | OutputIntoClause(IntoTable=aIntoTable; IntoTableColumns=aIntoTableColumns; SelectColumns=aSelectColumns) ->
      let ret = ScriptDom.OutputIntoClause()
      ret.IntoTable <- aIntoTable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aIntoTableColumns do ret.IntoTableColumns.Add (e.ToCs())
      for e in aSelectColumns do ret.SelectColumns.Add (e.ToCs())
      ret (* 333 *)
  static member FromCs(src:ScriptDom.OutputIntoClause, fragmentMapping:FragmentMapping) : OutputIntoClause =
    let ret =
      OutputIntoClause.OutputIntoClause((src.IntoTable |> Option.ofObj |> Option.map (fun x -> TableReference.FromCs(x, fragmentMapping))), (src.IntoTableColumns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.SelectColumns |> Seq.map (fun x -> SelectElement.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] TopRowFilter = (* Abstract? = false *)
  | TopRowFilter of Expression:ScalarExpression option * Percent:bool * WithTies:bool  
  member this.ToCs() : ScriptDom.TopRowFilter =
    match this with
    | TopRowFilter(Expression=aExpression; Percent=aPercent; WithTies=aWithTies) ->
      let ret = ScriptDom.TopRowFilter()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Percent <- aPercent
      ret.WithTies <- aWithTies
      ret (* 333 *)
  static member FromCs(src:ScriptDom.TopRowFilter, fragmentMapping:FragmentMapping) : TopRowFilter =
    let ret =
      TopRowFilter.TopRowFilter((src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.Percent), (src.WithTies))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] MergeActionClause = (* Abstract? = false *)
  | MergeActionClause of Action:MergeAction option * Condition:ScriptDom.MergeCondition * SearchCondition:BooleanExpression option  
  member this.ToCs() : ScriptDom.MergeActionClause =
    match this with
    | MergeActionClause(Action=aAction; Condition=aCondition; SearchCondition=aSearchCondition) ->
      let ret = ScriptDom.MergeActionClause()
      ret.Action <- aAction |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Condition <- aCondition
      ret.SearchCondition <- aSearchCondition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.MergeActionClause, fragmentMapping:FragmentMapping) : MergeActionClause =
    let ret =
      MergeActionClause.MergeActionClause((src.Action |> Option.ofObj |> Option.map (fun x -> MergeAction.FromCs(x, fragmentMapping))), (src.Condition), (src.SearchCondition |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] FromClause = (* Abstract? = false *)
  | FromClause of TableReferences:(TableReference) list  
  member this.ToCs() : ScriptDom.FromClause =
    match this with
    | FromClause(TableReferences=aTableReferences) ->
      let ret = ScriptDom.FromClause()
      for e in aTableReferences do ret.TableReferences.Add (e.ToCs())
      ret (* 333 *)
  static member FromCs(src:ScriptDom.FromClause, fragmentMapping:FragmentMapping) : FromClause =
    let ret =
      FromClause.FromClause((src.TableReferences |> Seq.map (fun x -> TableReference.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] WhereClause = (* Abstract? = false *)
  | WhereClause of Cursor:CursorId option * SearchCondition:BooleanExpression option  
  member this.ToCs() : ScriptDom.WhereClause =
    match this with
    | WhereClause(Cursor=aCursor; SearchCondition=aSearchCondition) ->
      let ret = ScriptDom.WhereClause()
      ret.Cursor <- aCursor |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SearchCondition <- aSearchCondition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.WhereClause, fragmentMapping:FragmentMapping) : WhereClause =
    let ret =
      WhereClause.WhereClause((src.Cursor |> Option.ofObj |> Option.map (fun x -> CursorId.FromCs(x, fragmentMapping))), (src.SearchCondition |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] IdentifierOrScalarExpression = (* Abstract? = false *)
  | IdentifierOrScalarExpression of Identifier:Identifier option * ScalarExpression:ScalarExpression option  
  member this.ToCs() : ScriptDom.IdentifierOrScalarExpression =
    match this with
    | IdentifierOrScalarExpression(Identifier=aIdentifier; ScalarExpression=aScalarExpression) ->
      let ret = ScriptDom.IdentifierOrScalarExpression()
      ret.Identifier <- aIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ScalarExpression <- aScalarExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.IdentifierOrScalarExpression, fragmentMapping:FragmentMapping) : IdentifierOrScalarExpression =
    let ret =
      IdentifierOrScalarExpression.IdentifierOrScalarExpression((src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ScalarExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] CatalogCollation = (* Abstract? = false *)
  | CatalogCollation   
  member this.ToCs() : ScriptDom.CatalogCollation =
    match this with
    | CatalogCollation -> ScriptDom.CatalogCollation() (* 327 *)
  static member FromCs(src:ScriptDom.CatalogCollation, fragmentMapping:FragmentMapping) : CatalogCollation =
    let ret =
      CatalogCollation.CatalogCollation 
    ret
and [<RequireQualifiedAccess>] NonTransactedFileStreamAccess = (* Abstract? = false *)
  | NonTransactedFileStreamAccess   
  member this.ToCs() : ScriptDom.NonTransactedFileStreamAccess =
    match this with
    | NonTransactedFileStreamAccess -> ScriptDom.NonTransactedFileStreamAccess() (* 327 *)
  static member FromCs(src:ScriptDom.NonTransactedFileStreamAccess, fragmentMapping:FragmentMapping) : NonTransactedFileStreamAccess =
    let ret =
      NonTransactedFileStreamAccess.NonTransactedFileStreamAccess 
    ret
and [<RequireQualifiedAccess>] TableDefinition = (* Abstract? = false *)
  | TableDefinition of ColumnDefinitions:(ColumnDefinition) list * Indexes:(IndexDefinition) list * SystemTimePeriod:SystemTimePeriodDefinition option * TableConstraints:(ConstraintDefinition) list  
  member this.ToCs() : ScriptDom.TableDefinition =
    match this with
    | TableDefinition(ColumnDefinitions=aColumnDefinitions; Indexes=aIndexes; SystemTimePeriod=aSystemTimePeriod; TableConstraints=aTableConstraints) ->
      let ret = ScriptDom.TableDefinition()
      for e in aColumnDefinitions do ret.ColumnDefinitions.Add (e.ToCs())
      for e in aIndexes do ret.Indexes.Add (e.ToCs())
      ret.SystemTimePeriod <- aSystemTimePeriod |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aTableConstraints do ret.TableConstraints.Add (e.ToCs())
      ret (* 333 *)
  static member FromCs(src:ScriptDom.TableDefinition, fragmentMapping:FragmentMapping) : TableDefinition =
    let ret =
      TableDefinition.TableDefinition((src.ColumnDefinitions |> Seq.map (fun src -> ColumnDefinition.ColumnDefinition((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ComputedColumnExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.Constraints |> Seq.map (fun x -> ConstraintDefinition.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.DefaultConstraint |> Option.ofObj |> Option.map (fun x -> DefaultConstraintDefinition.FromCs(x, fragmentMapping))), (src.Encryption |> Option.ofObj |> Option.map (fun x -> ColumnEncryptionDefinition.FromCs(x, fragmentMapping))), (Option.ofNullable (src.GeneratedAlways)), (src.IdentityOptions |> Option.ofObj |> Option.map (fun x -> IdentityOptions.FromCs(x, fragmentMapping))), (src.Index |> Option.ofObj |> Option.map (fun x -> IndexDefinition.FromCs(x, fragmentMapping))), (src.IsHidden), (src.IsMasked), (src.IsPersisted), (src.IsRowGuidCol), (src.MaskingFunction |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))), (src.StorageOptions |> Option.ofObj |> Option.map (fun x -> ColumnStorageOptions.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.Indexes |> Seq.map (fun src -> IndexDefinition.IndexDefinition((src.Columns |> Seq.map (fun src -> ColumnWithSortOrder.ColumnWithSortOrder((src.Column |> Option.ofObj |> Option.map (fun x -> ColumnReferenceExpression.FromCs(x, fragmentMapping))), (src.SortOrder))) |> List.ofSeq), (src.FileStreamOn |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.FilterPredicate |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))), (src.IndexOptions |> Seq.map (fun x -> IndexOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.IndexType |> Option.ofObj |> Option.map (fun x -> IndexType.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.OnFileGroupOrPartitionScheme |> Option.ofObj |> Option.map (fun x -> FileGroupOrPartitionScheme.FromCs(x, fragmentMapping))), (src.Unique))) |> List.ofSeq), (src.SystemTimePeriod |> Option.ofObj |> Option.map (fun x -> SystemTimePeriodDefinition.FromCs(x, fragmentMapping))), (src.TableConstraints |> Seq.map (fun x -> ConstraintDefinition.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] NullableConstraintDefinition = (* Abstract? = false *)
  | NullableConstraintDefinition of ConstraintIdentifier:Identifier option * Nullable:bool  
  member this.ToCs() : ScriptDom.NullableConstraintDefinition =
    match this with
    | NullableConstraintDefinition(ConstraintIdentifier=aConstraintIdentifier; Nullable=aNullable) ->
      let ret = ScriptDom.NullableConstraintDefinition()
      ret.ConstraintIdentifier <- aConstraintIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Nullable <- aNullable
      ret (* 333 *)
  static member FromCs(src:ScriptDom.NullableConstraintDefinition, fragmentMapping:FragmentMapping) : NullableConstraintDefinition =
    let ret =
      NullableConstraintDefinition.NullableConstraintDefinition((src.ConstraintIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Nullable))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ChildObjectName = (* Abstract? = false *)
  | ChildObjectName of BaseIdentifier:Identifier option * ChildIdentifier:Identifier option * Count:Int32 * DatabaseIdentifier:Identifier option * Identifiers:(Identifier) list * SchemaIdentifier:Identifier option * ServerIdentifier:Identifier option  
  member this.ToCs() : ScriptDom.ChildObjectName =
    match this with
    | ChildObjectName(BaseIdentifier=aBaseIdentifier; ChildIdentifier=aChildIdentifier; Count=aCount; DatabaseIdentifier=aDatabaseIdentifier; Identifiers=aIdentifiers; SchemaIdentifier=aSchemaIdentifier; ServerIdentifier=aServerIdentifier) ->
      let ret = ScriptDom.ChildObjectName()
       // Skipping prop BaseIdentifier - it is Readonly
       // Skipping prop ChildIdentifier - it is Readonly
       // Skipping prop Count - it is Readonly
       // Skipping prop DatabaseIdentifier - it is Readonly
      for e in aIdentifiers do ret.Identifiers.Add (e.ToCs())
       // Skipping prop SchemaIdentifier - it is Readonly
       // Skipping prop ServerIdentifier - it is Readonly
      ret (* 333 *)
  static member FromCs(src:ScriptDom.ChildObjectName, fragmentMapping:FragmentMapping) : ChildObjectName =
    let ret =
      ChildObjectName.ChildObjectName((src.BaseIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ChildIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Count), (src.DatabaseIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Identifiers |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.SchemaIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ServerIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] IPv4 = (* Abstract? = false *)
  | IPv4 of OctetFour:Literal option * OctetOne:Literal option * OctetThree:Literal option * OctetTwo:Literal option  
  member this.ToCs() : ScriptDom.IPv4 =
    match this with
    | IPv4(OctetFour=aOctetFour; OctetOne=aOctetOne; OctetThree=aOctetThree; OctetTwo=aOctetTwo) ->
      let ret = ScriptDom.IPv4()
      ret.OctetFour <- aOctetFour |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OctetOne <- aOctetOne |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OctetThree <- aOctetThree |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OctetTwo <- aOctetTwo |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.IPv4, fragmentMapping:FragmentMapping) : IPv4 =
    let ret =
      IPv4.IPv4((src.OctetFour |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.OctetOne |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.OctetThree |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.OctetTwo |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] EventDeclarationSetParameter = (* Abstract? = false *)
  | EventDeclarationSetParameter of EventField:Identifier option * EventValue:ScalarExpression option  
  member this.ToCs() : ScriptDom.EventDeclarationSetParameter =
    match this with
    | EventDeclarationSetParameter(EventField=aEventField; EventValue=aEventValue) ->
      let ret = ScriptDom.EventDeclarationSetParameter()
      ret.EventField <- aEventField |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.EventValue <- aEventValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.EventDeclarationSetParameter, fragmentMapping:FragmentMapping) : EventDeclarationSetParameter =
    let ret =
      EventDeclarationSetParameter.EventDeclarationSetParameter((src.EventField |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.EventValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ExecuteParameter = (* Abstract? = false *)
  | ExecuteParameter of IsOutput:bool * ParameterValue:ScalarExpression option * Variable:VariableReference option  
  member this.ToCs() : ScriptDom.ExecuteParameter =
    match this with
    | ExecuteParameter(IsOutput=aIsOutput; ParameterValue=aParameterValue; Variable=aVariable) ->
      let ret = ScriptDom.ExecuteParameter()
      ret.IsOutput <- aIsOutput
      ret.ParameterValue <- aParameterValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Variable <- aVariable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.ExecuteParameter, fragmentMapping:FragmentMapping) : ExecuteParameter =
    let ret =
      ExecuteParameter.ExecuteParameter((src.IsOutput), (src.ParameterValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.Variable |> Option.ofObj |> Option.map (fun x -> VariableReference.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] AdHocDataSource = (* Abstract? = false *)
  | AdHocDataSource of InitString:StringLiteral option * ProviderName:StringLiteral option  
  member this.ToCs() : ScriptDom.AdHocDataSource =
    match this with
    | AdHocDataSource(InitString=aInitString; ProviderName=aProviderName) ->
      let ret = ScriptDom.AdHocDataSource()
      ret.InitString <- aInitString |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ProviderName <- aProviderName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.AdHocDataSource, fragmentMapping:FragmentMapping) : AdHocDataSource =
    let ret =
      AdHocDataSource.AdHocDataSource((src.InitString |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))), (src.ProviderName |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ProcedureReferenceName = (* Abstract? = false *)
  | ProcedureReferenceName of ProcedureReference:ProcedureReference option * ProcedureVariable:VariableReference option  
  member this.ToCs() : ScriptDom.ProcedureReferenceName =
    match this with
    | ProcedureReferenceName(ProcedureReference=aProcedureReference; ProcedureVariable=aProcedureVariable) ->
      let ret = ScriptDom.ProcedureReferenceName()
      ret.ProcedureReference <- aProcedureReference |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ProcedureVariable <- aProcedureVariable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.ProcedureReferenceName, fragmentMapping:FragmentMapping) : ProcedureReferenceName =
    let ret =
      ProcedureReferenceName.ProcedureReferenceName((src.ProcedureReference |> Option.ofObj |> Option.map (fun x -> ProcedureReference.FromCs(x, fragmentMapping))), (src.ProcedureVariable |> Option.ofObj |> Option.map (fun x -> VariableReference.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] VariableReference = (* Abstract? = false *)
  | VariableReference of Collation:Identifier option * Name:String option  
  member this.ToCs() : ScriptDom.VariableReference =
    match this with
    | VariableReference(Collation=aCollation; Name=aName) ->
      let ret = ScriptDom.VariableReference()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.VariableReference, fragmentMapping:FragmentMapping) : VariableReference =
    let ret =
      VariableReference.VariableReference((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (Option.ofObj (src.Name)))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ExecuteContext = (* Abstract? = false *)
  | ExecuteContext of Kind:ScriptDom.ExecuteAsOption * Principal:ScalarExpression option  
  member this.ToCs() : ScriptDom.ExecuteContext =
    match this with
    | ExecuteContext(Kind=aKind; Principal=aPrincipal) ->
      let ret = ScriptDom.ExecuteContext()
      ret.Kind <- aKind
      ret.Principal <- aPrincipal |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.ExecuteContext, fragmentMapping:FragmentMapping) : ExecuteContext =
    let ret =
      ExecuteContext.ExecuteContext((src.Kind), (src.Principal |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ExternalResourcePoolAffinitySpecification = (* Abstract? = false *)
  | ExternalResourcePoolAffinitySpecification of AffinityType:ScriptDom.ExternalResourcePoolAffinityType * IsAuto:bool * ParameterValue:Literal option * PoolAffinityRanges:(LiteralRange) list  
  member this.ToCs() : ScriptDom.ExternalResourcePoolAffinitySpecification =
    match this with
    | ExternalResourcePoolAffinitySpecification(AffinityType=aAffinityType; IsAuto=aIsAuto; ParameterValue=aParameterValue; PoolAffinityRanges=aPoolAffinityRanges) ->
      let ret = ScriptDom.ExternalResourcePoolAffinitySpecification()
      ret.AffinityType <- aAffinityType
      ret.IsAuto <- aIsAuto
      ret.ParameterValue <- aParameterValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aPoolAffinityRanges do ret.PoolAffinityRanges.Add (e.ToCs())
      ret (* 333 *)
  static member FromCs(src:ScriptDom.ExternalResourcePoolAffinitySpecification, fragmentMapping:FragmentMapping) : ExternalResourcePoolAffinitySpecification =
    let ret =
      ExternalResourcePoolAffinitySpecification.ExternalResourcePoolAffinitySpecification((src.AffinityType), (src.IsAuto), (src.ParameterValue |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.PoolAffinityRanges |> Seq.map (fun x -> LiteralRange.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] FileDeclaration = (* Abstract? = false *)
  | FileDeclaration of IsPrimary:bool * Options:(FileDeclarationOption) list  
  member this.ToCs() : ScriptDom.FileDeclaration =
    match this with
    | FileDeclaration(IsPrimary=aIsPrimary; Options=aOptions) ->
      let ret = ScriptDom.FileDeclaration()
      ret.IsPrimary <- aIsPrimary
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret (* 333 *)
  static member FromCs(src:ScriptDom.FileDeclaration, fragmentMapping:FragmentMapping) : FileDeclaration =
    let ret =
      FileDeclaration.FileDeclaration((src.IsPrimary), (src.Options |> Seq.map (fun x -> FileDeclarationOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] JsonForClauseOption = (* Abstract? = false *)
  | JsonForClauseOption of OptionKind:ScriptDom.JsonForClauseOptions * Value:Literal option  
  member this.ToCs() : ScriptDom.JsonForClauseOption =
    match this with
    | JsonForClauseOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.JsonForClauseOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.JsonForClauseOption, fragmentMapping:FragmentMapping) : JsonForClauseOption =
    let ret =
      JsonForClauseOption.JsonForClauseOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] XmlForClauseOption = (* Abstract? = false *)
  | XmlForClauseOption of OptionKind:ScriptDom.XmlForClauseOptions * Value:Literal option  
  member this.ToCs() : ScriptDom.XmlForClauseOption =
    match this with
    | XmlForClauseOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.XmlForClauseOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.XmlForClauseOption, fragmentMapping:FragmentMapping) : XmlForClauseOption =
    let ret =
      XmlForClauseOption.XmlForClauseOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ExecuteAsClause = (* Abstract? = false *)
  | ExecuteAsClause of ExecuteAsOption:ScriptDom.ExecuteAsOption * Literal:Literal option  
  member this.ToCs() : ScriptDom.ExecuteAsClause =
    match this with
    | ExecuteAsClause(ExecuteAsOption=aExecuteAsOption; Literal=aLiteral) ->
      let ret = ScriptDom.ExecuteAsClause()
      ret.ExecuteAsOption <- aExecuteAsOption
      ret.Literal <- aLiteral |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.ExecuteAsClause, fragmentMapping:FragmentMapping) : ExecuteAsClause =
    let ret =
      ExecuteAsClause.ExecuteAsClause((src.ExecuteAsOption), (src.Literal |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] DeclareTableVariableBody = (* Abstract? = false *)
  | DeclareTableVariableBody of AsDefined:bool * Definition:TableDefinition option * VariableName:Identifier option  
  member this.ToCs() : ScriptDom.DeclareTableVariableBody =
    match this with
    | DeclareTableVariableBody(AsDefined=aAsDefined; Definition=aDefinition; VariableName=aVariableName) ->
      let ret = ScriptDom.DeclareTableVariableBody()
      ret.AsDefined <- aAsDefined
      ret.Definition <- aDefinition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.VariableName <- aVariableName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.DeclareTableVariableBody, fragmentMapping:FragmentMapping) : DeclareTableVariableBody =
    let ret =
      DeclareTableVariableBody.DeclareTableVariableBody((src.AsDefined), (src.Definition |> Option.ofObj |> Option.map (fun x -> TableDefinition.FromCs(x, fragmentMapping))), (src.VariableName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] CompressionPartitionRange = (* Abstract? = false *)
  | CompressionPartitionRange of From:ScalarExpression option * To:ScalarExpression option  
  member this.ToCs() : ScriptDom.CompressionPartitionRange =
    match this with
    | CompressionPartitionRange(From=aFrom; To=aTo) ->
      let ret = ScriptDom.CompressionPartitionRange()
      ret.From <- aFrom |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.To <- aTo |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.CompressionPartitionRange, fragmentMapping:FragmentMapping) : CompressionPartitionRange =
    let ret =
      CompressionPartitionRange.CompressionPartitionRange((src.From |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.To |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] OnlineIndexLowPriorityLockWaitOption = (* Abstract? = false *)
  | OnlineIndexLowPriorityLockWaitOption of Options:(LowPriorityLockWaitOption) list  
  member this.ToCs() : ScriptDom.OnlineIndexLowPriorityLockWaitOption =
    match this with
    | OnlineIndexLowPriorityLockWaitOption(Options=aOptions) ->
      let ret = ScriptDom.OnlineIndexLowPriorityLockWaitOption()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret (* 333 *)
  static member FromCs(src:ScriptDom.OnlineIndexLowPriorityLockWaitOption, fragmentMapping:FragmentMapping) : OnlineIndexLowPriorityLockWaitOption =
    let ret =
      OnlineIndexLowPriorityLockWaitOption.OnlineIndexLowPriorityLockWaitOption((src.Options |> Seq.map (fun x -> LowPriorityLockWaitOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] TimeUnit = (* Abstract? = false *)
  | TimeUnit   
  member this.ToCs() : ScriptDom.TimeUnit =
    match this with
    | TimeUnit -> ScriptDom.TimeUnit() (* 327 *)
  static member FromCs(src:ScriptDom.TimeUnit, fragmentMapping:FragmentMapping) : TimeUnit =
    let ret =
      TimeUnit.TimeUnit 
    ret
and [<RequireQualifiedAccess>] IndexTypeKind = (* Abstract? = false *)
  | IndexTypeKind   
  member this.ToCs() : ScriptDom.IndexTypeKind =
    match this with
    | IndexTypeKind -> ScriptDom.IndexTypeKind() (* 327 *)
  static member FromCs(src:ScriptDom.IndexTypeKind, fragmentMapping:FragmentMapping) : IndexTypeKind =
    let ret =
      IndexTypeKind.IndexTypeKind 
    ret
and [<RequireQualifiedAccess>] ExecuteSpecification = (* Abstract? = false *)
  | ExecuteSpecification of ExecutableEntity:ExecutableEntity option * ExecuteContext:ExecuteContext option * LinkedServer:Identifier option * Variable:VariableReference option  
  member this.ToCs() : ScriptDom.ExecuteSpecification =
    match this with
    | ExecuteSpecification(ExecutableEntity=aExecutableEntity; ExecuteContext=aExecuteContext; LinkedServer=aLinkedServer; Variable=aVariable) ->
      let ret = ScriptDom.ExecuteSpecification()
      ret.ExecutableEntity <- aExecutableEntity |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ExecuteContext <- aExecuteContext |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.LinkedServer <- aLinkedServer |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Variable <- aVariable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.ExecuteSpecification, fragmentMapping:FragmentMapping) : ExecuteSpecification =
    let ret =
      ExecuteSpecification.ExecuteSpecification((src.ExecutableEntity |> Option.ofObj |> Option.map (fun x -> ExecutableEntity.FromCs(x, fragmentMapping))), (src.ExecuteContext |> Option.ofObj |> Option.map (fun x -> ExecuteContext.FromCs(x, fragmentMapping))), (src.LinkedServer |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Variable |> Option.ofObj |> Option.map (fun x -> VariableReference.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] RowValue = (* Abstract? = false *)
  | RowValue of ColumnValues:(ScalarExpression) list  
  member this.ToCs() : ScriptDom.RowValue =
    match this with
    | RowValue(ColumnValues=aColumnValues) ->
      let ret = ScriptDom.RowValue()
      for e in aColumnValues do ret.ColumnValues.Add (e.ToCs())
      ret (* 333 *)
  static member FromCs(src:ScriptDom.RowValue, fragmentMapping:FragmentMapping) : RowValue =
    let ret =
      RowValue.RowValue((src.ColumnValues |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ValuesInsertSource = (* Abstract? = false *)
  | ValuesInsertSource of IsDefaultValues:bool * RowValues:(RowValue) list  
  member this.ToCs() : ScriptDom.ValuesInsertSource =
    match this with
    | ValuesInsertSource(IsDefaultValues=aIsDefaultValues; RowValues=aRowValues) ->
      let ret = ScriptDom.ValuesInsertSource()
      ret.IsDefaultValues <- aIsDefaultValues
      for e in aRowValues do ret.RowValues.Add (e.ToCs())
      ret (* 333 *)
  static member FromCs(src:ScriptDom.ValuesInsertSource, fragmentMapping:FragmentMapping) : ValuesInsertSource =
    let ret =
      ValuesInsertSource.ValuesInsertSource((src.IsDefaultValues), (src.RowValues |> Seq.map (fun src -> RowValue.RowValue((src.ColumnValues |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq))) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] DeviceInfo = (* Abstract? = false *)
  | DeviceInfo of DeviceType:ScriptDom.DeviceType * LogicalDevice:IdentifierOrValueExpression option * PhysicalDevice:ValueExpression option  
  member this.ToCs() : ScriptDom.DeviceInfo =
    match this with
    | DeviceInfo(DeviceType=aDeviceType; LogicalDevice=aLogicalDevice; PhysicalDevice=aPhysicalDevice) ->
      let ret = ScriptDom.DeviceInfo()
      ret.DeviceType <- aDeviceType
      ret.LogicalDevice <- aLogicalDevice |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PhysicalDevice <- aPhysicalDevice |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.DeviceInfo, fragmentMapping:FragmentMapping) : DeviceInfo =
    let ret =
      DeviceInfo.DeviceInfo((src.DeviceType), (src.LogicalDevice |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.PhysicalDevice |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] VariableValuePair = (* Abstract? = false *)
  | VariableValuePair of IsForUnknown:bool * Value:ScalarExpression option * Variable:VariableReference option  
  member this.ToCs() : ScriptDom.VariableValuePair =
    match this with
    | VariableValuePair(IsForUnknown=aIsForUnknown; Value=aValue; Variable=aVariable) ->
      let ret = ScriptDom.VariableValuePair()
      ret.IsForUnknown <- aIsForUnknown
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Variable <- aVariable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.VariableValuePair, fragmentMapping:FragmentMapping) : VariableValuePair =
    let ret =
      VariableValuePair.VariableValuePair((src.IsForUnknown), (src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.Variable |> Option.ofObj |> Option.map (fun x -> VariableReference.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ExpressionWithSortOrder = (* Abstract? = false *)
  | ExpressionWithSortOrder of Expression:ScalarExpression option * SortOrder:ScriptDom.SortOrder  
  member this.ToCs() : ScriptDom.ExpressionWithSortOrder =
    match this with
    | ExpressionWithSortOrder(Expression=aExpression; SortOrder=aSortOrder) ->
      let ret = ScriptDom.ExpressionWithSortOrder()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SortOrder <- aSortOrder
      ret (* 333 *)
  static member FromCs(src:ScriptDom.ExpressionWithSortOrder, fragmentMapping:FragmentMapping) : ExpressionWithSortOrder =
    let ret =
      ExpressionWithSortOrder.ExpressionWithSortOrder((src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.SortOrder))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] OrderByClause = (* Abstract? = false *)
  | OrderByClause of OrderByElements:(ExpressionWithSortOrder) list  
  member this.ToCs() : ScriptDom.OrderByClause =
    match this with
    | OrderByClause(OrderByElements=aOrderByElements) ->
      let ret = ScriptDom.OrderByClause()
      for e in aOrderByElements do ret.OrderByElements.Add (e.ToCs())
      ret (* 333 *)
  static member FromCs(src:ScriptDom.OrderByClause, fragmentMapping:FragmentMapping) : OrderByClause =
    let ret =
      OrderByClause.OrderByClause((src.OrderByElements |> Seq.map (fun src -> ExpressionWithSortOrder.ExpressionWithSortOrder((src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.SortOrder))) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] WindowFrameClause = (* Abstract? = false *)
  | WindowFrameClause of Bottom:WindowDelimiter option * Top:WindowDelimiter option * WindowFrameType:ScriptDom.WindowFrameType  
  member this.ToCs() : ScriptDom.WindowFrameClause =
    match this with
    | WindowFrameClause(Bottom=aBottom; Top=aTop; WindowFrameType=aWindowFrameType) ->
      let ret = ScriptDom.WindowFrameClause()
      ret.Bottom <- aBottom |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Top <- aTop |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WindowFrameType <- aWindowFrameType
      ret (* 333 *)
  static member FromCs(src:ScriptDom.WindowFrameClause, fragmentMapping:FragmentMapping) : WindowFrameClause =
    let ret =
      WindowFrameClause.WindowFrameClause((src.Bottom |> Option.ofObj |> Option.map (fun x -> WindowDelimiter.FromCs(x, fragmentMapping))), (src.Top |> Option.ofObj |> Option.map (fun x -> WindowDelimiter.FromCs(x, fragmentMapping))), (src.WindowFrameType))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ProcedureReference = (* Abstract? = false *)
  | ProcedureReference of Name:SchemaObjectName option * Number:Literal option  
  member this.ToCs() : ScriptDom.ProcedureReference =
    match this with
    | ProcedureReference(Name=aName; Number=aNumber) ->
      let ret = ScriptDom.ProcedureReference()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Number <- aNumber |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.ProcedureReference, fragmentMapping:FragmentMapping) : ProcedureReference =
    let ret =
      ProcedureReference.ProcedureReference((src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.Number |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] OffsetClause = (* Abstract? = false *)
  | OffsetClause of FetchExpression:ScalarExpression option * OffsetExpression:ScalarExpression option  
  member this.ToCs() : ScriptDom.OffsetClause =
    match this with
    | OffsetClause(FetchExpression=aFetchExpression; OffsetExpression=aOffsetExpression) ->
      let ret = ScriptDom.OffsetClause()
      ret.FetchExpression <- aFetchExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OffsetExpression <- aOffsetExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.OffsetClause, fragmentMapping:FragmentMapping) : OffsetClause =
    let ret =
      OffsetClause.OffsetClause((src.FetchExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.OffsetExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] GroupByClause = (* Abstract? = false *)
  | GroupByClause of All:bool * GroupByOption:ScriptDom.GroupByOption * GroupingSpecifications:(GroupingSpecification) list  
  member this.ToCs() : ScriptDom.GroupByClause =
    match this with
    | GroupByClause(All=aAll; GroupByOption=aGroupByOption; GroupingSpecifications=aGroupingSpecifications) ->
      let ret = ScriptDom.GroupByClause()
      ret.All <- aAll
      ret.GroupByOption <- aGroupByOption
      for e in aGroupingSpecifications do ret.GroupingSpecifications.Add (e.ToCs())
      ret (* 333 *)
  static member FromCs(src:ScriptDom.GroupByClause, fragmentMapping:FragmentMapping) : GroupByClause =
    let ret =
      GroupByClause.GroupByClause((src.All), (src.GroupByOption), (src.GroupingSpecifications |> Seq.map (fun x -> GroupingSpecification.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] HavingClause = (* Abstract? = false *)
  | HavingClause of SearchCondition:BooleanExpression option  
  member this.ToCs() : ScriptDom.HavingClause =
    match this with
    | HavingClause(SearchCondition=aSearchCondition) ->
      let ret = ScriptDom.HavingClause()
      ret.SearchCondition <- aSearchCondition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.HavingClause, fragmentMapping:FragmentMapping) : HavingClause =
    let ret =
      HavingClause.HavingClause((src.SearchCondition |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ResourcePoolAffinitySpecification = (* Abstract? = false *)
  | ResourcePoolAffinitySpecification of AffinityType:ScriptDom.ResourcePoolAffinityType * IsAuto:bool * ParameterValue:Literal option * PoolAffinityRanges:(LiteralRange) list  
  member this.ToCs() : ScriptDom.ResourcePoolAffinitySpecification =
    match this with
    | ResourcePoolAffinitySpecification(AffinityType=aAffinityType; IsAuto=aIsAuto; ParameterValue=aParameterValue; PoolAffinityRanges=aPoolAffinityRanges) ->
      let ret = ScriptDom.ResourcePoolAffinitySpecification()
      ret.AffinityType <- aAffinityType
      ret.IsAuto <- aIsAuto
      ret.ParameterValue <- aParameterValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aPoolAffinityRanges do ret.PoolAffinityRanges.Add (e.ToCs())
      ret (* 333 *)
  static member FromCs(src:ScriptDom.ResourcePoolAffinitySpecification, fragmentMapping:FragmentMapping) : ResourcePoolAffinitySpecification =
    let ret =
      ResourcePoolAffinitySpecification.ResourcePoolAffinitySpecification((src.AffinityType), (src.IsAuto), (src.ParameterValue |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.PoolAffinityRanges |> Seq.map (fun x -> LiteralRange.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] FileStreamDatabaseOption = (* Abstract? = false *)
  | FileStreamDatabaseOption of DirectoryName:Literal option * NonTransactedAccess:(ScriptDom.NonTransactedFileStreamAccess) option * OptionKind:ScriptDom.DatabaseOptionKind  
  member this.ToCs() : ScriptDom.FileStreamDatabaseOption =
    match this with
    | FileStreamDatabaseOption(DirectoryName=aDirectoryName; NonTransactedAccess=aNonTransactedAccess; OptionKind=aOptionKind) ->
      let ret = ScriptDom.FileStreamDatabaseOption()
      ret.DirectoryName <- aDirectoryName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.NonTransactedAccess <- Option.toNullable aNonTransactedAccess
      ret.OptionKind <- aOptionKind
      ret (* 333 *)
  static member FromCs(src:ScriptDom.FileStreamDatabaseOption, fragmentMapping:FragmentMapping) : FileStreamDatabaseOption =
    let ret =
      FileStreamDatabaseOption.FileStreamDatabaseOption((src.DirectoryName |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (Option.ofNullable (src.NonTransactedAccess)), (src.OptionKind))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ResultColumnDefinition = (* Abstract? = false *)
  | ResultColumnDefinition of ColumnDefinition:ColumnDefinitionBase option * Nullable:NullableConstraintDefinition option  
  member this.ToCs() : ScriptDom.ResultColumnDefinition =
    match this with
    | ResultColumnDefinition(ColumnDefinition=aColumnDefinition; Nullable=aNullable) ->
      let ret = ScriptDom.ResultColumnDefinition()
      ret.ColumnDefinition <- aColumnDefinition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Nullable <- aNullable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.ResultColumnDefinition, fragmentMapping:FragmentMapping) : ResultColumnDefinition =
    let ret =
      ResultColumnDefinition.ResultColumnDefinition((src.ColumnDefinition |> Option.ofObj |> Option.map (fun x -> ColumnDefinitionBase.FromCs(x, fragmentMapping))), (src.Nullable |> Option.ofObj |> Option.map (fun x -> NullableConstraintDefinition.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] SearchedWhenClause = (* Abstract? = false *)
  | SearchedWhenClause of ThenExpression:ScalarExpression option * WhenExpression:BooleanExpression option  
  member this.ToCs() : ScriptDom.SearchedWhenClause =
    match this with
    | SearchedWhenClause(ThenExpression=aThenExpression; WhenExpression=aWhenExpression) ->
      let ret = ScriptDom.SearchedWhenClause()
      ret.ThenExpression <- aThenExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WhenExpression <- aWhenExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.SearchedWhenClause, fragmentMapping:FragmentMapping) : SearchedWhenClause =
    let ret =
      SearchedWhenClause.SearchedWhenClause((src.ThenExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.WhenExpression |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] SimpleWhenClause = (* Abstract? = false *)
  | SimpleWhenClause of ThenExpression:ScalarExpression option * WhenExpression:ScalarExpression option  
  member this.ToCs() : ScriptDom.SimpleWhenClause =
    match this with
    | SimpleWhenClause(ThenExpression=aThenExpression; WhenExpression=aWhenExpression) ->
      let ret = ScriptDom.SimpleWhenClause()
      ret.ThenExpression <- aThenExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WhenExpression <- aWhenExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.SimpleWhenClause, fragmentMapping:FragmentMapping) : SimpleWhenClause =
    let ret =
      SimpleWhenClause.SimpleWhenClause((src.ThenExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.WhenExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] OverClause = (* Abstract? = false *)
  | OverClause of OrderByClause:OrderByClause option * Partitions:(ScalarExpression) list * WindowFrameClause:WindowFrameClause option  
  member this.ToCs() : ScriptDom.OverClause =
    match this with
    | OverClause(OrderByClause=aOrderByClause; Partitions=aPartitions; WindowFrameClause=aWindowFrameClause) ->
      let ret = ScriptDom.OverClause()
      ret.OrderByClause <- aOrderByClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aPartitions do ret.Partitions.Add (e.ToCs())
      ret.WindowFrameClause <- aWindowFrameClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.OverClause, fragmentMapping:FragmentMapping) : OverClause =
    let ret =
      OverClause.OverClause((src.OrderByClause |> Option.ofObj |> Option.map (fun x -> OrderByClause.FromCs(x, fragmentMapping))), (src.Partitions |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.WindowFrameClause |> Option.ofObj |> Option.map (fun x -> WindowFrameClause.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] WithinGroupClause = (* Abstract? = false *)
  | WithinGroupClause of HasGraphPath:bool * OrderByClause:OrderByClause option  
  member this.ToCs() : ScriptDom.WithinGroupClause =
    match this with
    | WithinGroupClause(HasGraphPath=aHasGraphPath; OrderByClause=aOrderByClause) ->
      let ret = ScriptDom.WithinGroupClause()
      ret.HasGraphPath <- aHasGraphPath
      ret.OrderByClause <- aOrderByClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.WithinGroupClause, fragmentMapping:FragmentMapping) : WithinGroupClause =
    let ret =
      WithinGroupClause.WithinGroupClause((src.HasGraphPath), (src.OrderByClause |> Option.ofObj |> Option.map (fun x -> OrderByClause.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] Privilege80 = (* Abstract? = false *)
  | Privilege80 of Columns:(Identifier) list * PrivilegeType80:ScriptDom.PrivilegeType80  
  member this.ToCs() : ScriptDom.Privilege80 =
    match this with
    | Privilege80(Columns=aColumns; PrivilegeType80=aPrivilegeType80) ->
      let ret = ScriptDom.Privilege80()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.PrivilegeType80 <- aPrivilegeType80
      ret (* 333 *)
  static member FromCs(src:ScriptDom.Privilege80, fragmentMapping:FragmentMapping) : Privilege80 =
    let ret =
      Privilege80.Privilege80((src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.PrivilegeType80))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] FunctionCall = (* Abstract? = false *)
  | FunctionCall of CallTarget:CallTarget option * Collation:Identifier option * FunctionName:Identifier option * OverClause:OverClause option * Parameters:(ScalarExpression) list * UniqueRowFilter:ScriptDom.UniqueRowFilter * WithinGroupClause:WithinGroupClause option  
  member this.ToCs() : ScriptDom.FunctionCall =
    match this with
    | FunctionCall(CallTarget=aCallTarget; Collation=aCollation; FunctionName=aFunctionName; OverClause=aOverClause; Parameters=aParameters; UniqueRowFilter=aUniqueRowFilter; WithinGroupClause=aWithinGroupClause) ->
      let ret = ScriptDom.FunctionCall()
      ret.CallTarget <- aCallTarget |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FunctionName <- aFunctionName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OverClause <- aOverClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret.UniqueRowFilter <- aUniqueRowFilter
      ret.WithinGroupClause <- aWithinGroupClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.FunctionCall, fragmentMapping:FragmentMapping) : FunctionCall =
    let ret =
      FunctionCall.FunctionCall((src.CallTarget |> Option.ofObj |> Option.map (fun x -> CallTarget.FromCs(x, fragmentMapping))), (src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.FunctionName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.OverClause |> Option.ofObj |> Option.map (fun x -> OverClause.FromCs(x, fragmentMapping))), (src.Parameters |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.UniqueRowFilter), (src.WithinGroupClause |> Option.ofObj |> Option.map (fun x -> WithinGroupClause.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] SecurityTargetObjectName = (* Abstract? = false *)
  | SecurityTargetObjectName of MultiPartIdentifier:MultiPartIdentifier option  
  member this.ToCs() : ScriptDom.SecurityTargetObjectName =
    match this with
    | SecurityTargetObjectName(MultiPartIdentifier=aMultiPartIdentifier) ->
      let ret = ScriptDom.SecurityTargetObjectName()
      ret.MultiPartIdentifier <- aMultiPartIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.SecurityTargetObjectName, fragmentMapping:FragmentMapping) : SecurityTargetObjectName =
    let ret =
      SecurityTargetObjectName.SecurityTargetObjectName((src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] BoundingBoxParameter = (* Abstract? = false *)
  | BoundingBoxParameter of Parameter:ScriptDom.BoundingBoxParameterType * Value:ScalarExpression option  
  member this.ToCs() : ScriptDom.BoundingBoxParameter =
    match this with
    | BoundingBoxParameter(Parameter=aParameter; Value=aValue) ->
      let ret = ScriptDom.BoundingBoxParameter()
      ret.Parameter <- aParameter
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.BoundingBoxParameter, fragmentMapping:FragmentMapping) : BoundingBoxParameter =
    let ret =
      BoundingBoxParameter.BoundingBoxParameter((src.Parameter), (src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] GridParameter = (* Abstract? = false *)
  | GridParameter of Parameter:ScriptDom.GridParameterType * Value:ScriptDom.ImportanceParameterType  
  member this.ToCs() : ScriptDom.GridParameter =
    match this with
    | GridParameter(Parameter=aParameter; Value=aValue) ->
      let ret = ScriptDom.GridParameter()
      ret.Parameter <- aParameter
      ret.Value <- aValue
      ret (* 333 *)
  static member FromCs(src:ScriptDom.GridParameter, fragmentMapping:FragmentMapping) : GridParameter =
    let ret =
      GridParameter.GridParameter((src.Parameter), (src.Value))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] StatisticsPartitionRange = (* Abstract? = false *)
  | StatisticsPartitionRange of From:IntegerLiteral option * To:IntegerLiteral option  
  member this.ToCs() : ScriptDom.StatisticsPartitionRange =
    match this with
    | StatisticsPartitionRange(From=aFrom; To=aTo) ->
      let ret = ScriptDom.StatisticsPartitionRange()
      ret.From <- aFrom |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.To <- aTo |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.StatisticsPartitionRange, fragmentMapping:FragmentMapping) : StatisticsPartitionRange =
    let ret =
      StatisticsPartitionRange.StatisticsPartitionRange((src.From |> Option.ofObj |> Option.map (fun x -> IntegerLiteral.FromCs(x, fragmentMapping))), (src.To |> Option.ofObj |> Option.map (fun x -> IntegerLiteral.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] TSqlBatch = (* Abstract? = false *)
  | TSqlBatch of Statements:(TSqlStatement) list  
  member this.ToCs() : ScriptDom.TSqlBatch =
    match this with
    | TSqlBatch(Statements=aStatements) ->
      let ret = ScriptDom.TSqlBatch()
      for e in aStatements do ret.Statements.Add (e.ToCs())
      ret (* 333 *)
  static member FromCs(src:ScriptDom.TSqlBatch, fragmentMapping:FragmentMapping) : TSqlBatch =
    let ret =
      TSqlBatch.TSqlBatch((src.Statements |> Seq.map (fun x -> TSqlStatement.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] EndpointAffinity = (* Abstract? = false *)
  | EndpointAffinity of Kind:ScriptDom.AffinityKind * Value:Literal option  
  member this.ToCs() : ScriptDom.EndpointAffinity =
    match this with
    | EndpointAffinity(Kind=aKind; Value=aValue) ->
      let ret = ScriptDom.EndpointAffinity()
      ret.Kind <- aKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.EndpointAffinity, fragmentMapping:FragmentMapping) : EndpointAffinity =
    let ret =
      EndpointAffinity.EndpointAffinity((src.Kind), (src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ServiceContract = (* Abstract? = false *)
  | ServiceContract of Action:ScriptDom.AlterAction * Name:Identifier option  
  member this.ToCs() : ScriptDom.ServiceContract =
    match this with
    | ServiceContract(Action=aAction; Name=aName) ->
      let ret = ScriptDom.ServiceContract()
      ret.Action <- aAction
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.ServiceContract, fragmentMapping:FragmentMapping) : ServiceContract =
    let ret =
      ServiceContract.ServiceContract((src.Action), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] DatabaseConfigurationClearOption = (* Abstract? = false *)
  | DatabaseConfigurationClearOption of OptionKind:ScriptDom.DatabaseConfigClearOptionKind * PlanHandle:BinaryLiteral option  
  member this.ToCs() : ScriptDom.DatabaseConfigurationClearOption =
    match this with
    | DatabaseConfigurationClearOption(OptionKind=aOptionKind; PlanHandle=aPlanHandle) ->
      let ret = ScriptDom.DatabaseConfigurationClearOption()
      ret.OptionKind <- aOptionKind
      ret.PlanHandle <- aPlanHandle |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.DatabaseConfigurationClearOption, fragmentMapping:FragmentMapping) : DatabaseConfigurationClearOption =
    let ret =
      DatabaseConfigurationClearOption.DatabaseConfigurationClearOption((src.OptionKind), (src.PlanHandle |> Option.ofObj |> Option.map (fun x -> BinaryLiteral.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] AlterDatabaseTermination = (* Abstract? = false *)
  | AlterDatabaseTermination of ImmediateRollback:bool * NoWait:bool * RollbackAfter:Literal option  
  member this.ToCs() : ScriptDom.AlterDatabaseTermination =
    match this with
    | AlterDatabaseTermination(ImmediateRollback=aImmediateRollback; NoWait=aNoWait; RollbackAfter=aRollbackAfter) ->
      let ret = ScriptDom.AlterDatabaseTermination()
      ret.ImmediateRollback <- aImmediateRollback
      ret.NoWait <- aNoWait
      ret.RollbackAfter <- aRollbackAfter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.AlterDatabaseTermination, fragmentMapping:FragmentMapping) : AlterDatabaseTermination =
    let ret =
      AlterDatabaseTermination.AlterDatabaseTermination((src.ImmediateRollback), (src.NoWait), (src.RollbackAfter |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] FullTextStopListAction = (* Abstract? = false *)
  | FullTextStopListAction of IsAdd:bool * IsAll:bool * LanguageTerm:IdentifierOrValueExpression option * StopWord:Literal option  
  member this.ToCs() : ScriptDom.FullTextStopListAction =
    match this with
    | FullTextStopListAction(IsAdd=aIsAdd; IsAll=aIsAll; LanguageTerm=aLanguageTerm; StopWord=aStopWord) ->
      let ret = ScriptDom.FullTextStopListAction()
      ret.IsAdd <- aIsAdd
      ret.IsAll <- aIsAll
      ret.LanguageTerm <- aLanguageTerm |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StopWord <- aStopWord |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.FullTextStopListAction, fragmentMapping:FragmentMapping) : FullTextStopListAction =
    let ret =
      FullTextStopListAction.FullTextStopListAction((src.IsAdd), (src.IsAll), (src.LanguageTerm |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.StopWord |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] AlterServerConfigurationFailoverClusterPropertyOption = (* Abstract? = false *)
  | AlterServerConfigurationFailoverClusterPropertyOption of OptionKind:ScriptDom.AlterServerConfigurationFailoverClusterPropertyOptionKind * OptionValue:OptionValue option  
  member this.ToCs() : ScriptDom.AlterServerConfigurationFailoverClusterPropertyOption =
    match this with
    | AlterServerConfigurationFailoverClusterPropertyOption(OptionKind=aOptionKind; OptionValue=aOptionValue) ->
      let ret = ScriptDom.AlterServerConfigurationFailoverClusterPropertyOption()
      ret.OptionKind <- aOptionKind
      ret.OptionValue <- aOptionValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.AlterServerConfigurationFailoverClusterPropertyOption, fragmentMapping:FragmentMapping) : AlterServerConfigurationFailoverClusterPropertyOption =
    let ret =
      AlterServerConfigurationFailoverClusterPropertyOption.AlterServerConfigurationFailoverClusterPropertyOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (fun x -> OptionValue.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] AlterServerConfigurationHadrClusterOption = (* Abstract? = false *)
  | AlterServerConfigurationHadrClusterOption of IsLocal:bool * OptionKind:ScriptDom.AlterServerConfigurationHadrClusterOptionKind * OptionValue:OptionValue option  
  member this.ToCs() : ScriptDom.AlterServerConfigurationHadrClusterOption =
    match this with
    | AlterServerConfigurationHadrClusterOption(IsLocal=aIsLocal; OptionKind=aOptionKind; OptionValue=aOptionValue) ->
      let ret = ScriptDom.AlterServerConfigurationHadrClusterOption()
      ret.IsLocal <- aIsLocal
      ret.OptionKind <- aOptionKind
      ret.OptionValue <- aOptionValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.AlterServerConfigurationHadrClusterOption, fragmentMapping:FragmentMapping) : AlterServerConfigurationHadrClusterOption =
    let ret =
      AlterServerConfigurationHadrClusterOption.AlterServerConfigurationHadrClusterOption((src.IsLocal), (src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (fun x -> OptionValue.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] AlterServerConfigurationSoftNumaOption = (* Abstract? = false *)
  | AlterServerConfigurationSoftNumaOption of OptionKind:ScriptDom.AlterServerConfigurationSoftNumaOptionKind * OptionValue:OptionValue option  
  member this.ToCs() : ScriptDom.AlterServerConfigurationSoftNumaOption =
    match this with
    | AlterServerConfigurationSoftNumaOption(OptionKind=aOptionKind; OptionValue=aOptionValue) ->
      let ret = ScriptDom.AlterServerConfigurationSoftNumaOption()
      ret.OptionKind <- aOptionKind
      ret.OptionValue <- aOptionValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.AlterServerConfigurationSoftNumaOption, fragmentMapping:FragmentMapping) : AlterServerConfigurationSoftNumaOption =
    let ret =
      AlterServerConfigurationSoftNumaOption.AlterServerConfigurationSoftNumaOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (fun x -> OptionValue.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ProcessAffinityRange = (* Abstract? = false *)
  | ProcessAffinityRange of From:Literal option * To:Literal option  
  member this.ToCs() : ScriptDom.ProcessAffinityRange =
    match this with
    | ProcessAffinityRange(From=aFrom; To=aTo) ->
      let ret = ScriptDom.ProcessAffinityRange()
      ret.From <- aFrom |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.To <- aTo |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.ProcessAffinityRange, fragmentMapping:FragmentMapping) : ProcessAffinityRange =
    let ret =
      ProcessAffinityRange.ProcessAffinityRange((src.From |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.To |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] AlterTableDropTableElement = (* Abstract? = false *)
  | AlterTableDropTableElement of DropClusteredConstraintOptions:(DropClusteredConstraintOption) list * IsIfExists:bool * Name:Identifier option * TableElementType:ScriptDom.TableElementType  
  member this.ToCs() : ScriptDom.AlterTableDropTableElement =
    match this with
    | AlterTableDropTableElement(DropClusteredConstraintOptions=aDropClusteredConstraintOptions; IsIfExists=aIsIfExists; Name=aName; TableElementType=aTableElementType) ->
      let ret = ScriptDom.AlterTableDropTableElement()
      for e in aDropClusteredConstraintOptions do ret.DropClusteredConstraintOptions.Add (e.ToCs())
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TableElementType <- aTableElementType
      ret (* 333 *)
  static member FromCs(src:ScriptDom.AlterTableDropTableElement, fragmentMapping:FragmentMapping) : AlterTableDropTableElement =
    let ret =
      AlterTableDropTableElement.AlterTableDropTableElement((src.DropClusteredConstraintOptions |> Seq.map (fun x -> DropClusteredConstraintOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.TableElementType))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] PartitionSpecifier = (* Abstract? = false *)
  | PartitionSpecifier of All:bool * Number:ScalarExpression option  
  member this.ToCs() : ScriptDom.PartitionSpecifier =
    match this with
    | PartitionSpecifier(All=aAll; Number=aNumber) ->
      let ret = ScriptDom.PartitionSpecifier()
      ret.All <- aAll
      ret.Number <- aNumber |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.PartitionSpecifier, fragmentMapping:FragmentMapping) : PartitionSpecifier =
    let ret =
      PartitionSpecifier.PartitionSpecifier((src.All), (src.Number |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ApplicationRoleOption = (* Abstract? = false *)
  | ApplicationRoleOption of OptionKind:ScriptDom.ApplicationRoleOptionKind * Value:IdentifierOrValueExpression option  
  member this.ToCs() : ScriptDom.ApplicationRoleOption =
    match this with
    | ApplicationRoleOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.ApplicationRoleOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.ApplicationRoleOption, fragmentMapping:FragmentMapping) : ApplicationRoleOption =
    let ret =
      ApplicationRoleOption.ApplicationRoleOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] AddFileSpec = (* Abstract? = false *)
  | AddFileSpec of File:ScalarExpression option * FileName:Literal option  
  member this.ToCs() : ScriptDom.AddFileSpec =
    match this with
    | AddFileSpec(File=aFile; FileName=aFileName) ->
      let ret = ScriptDom.AddFileSpec()
      ret.File <- aFile |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FileName <- aFileName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.AddFileSpec, fragmentMapping:FragmentMapping) : AddFileSpec =
    let ret =
      AddFileSpec.AddFileSpec((src.File |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.FileName |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] AuditSpecificationPart = (* Abstract? = false *)
  | AuditSpecificationPart of Details:AuditSpecificationDetail option * IsDrop:bool  
  member this.ToCs() : ScriptDom.AuditSpecificationPart =
    match this with
    | AuditSpecificationPart(Details=aDetails; IsDrop=aIsDrop) ->
      let ret = ScriptDom.AuditSpecificationPart()
      ret.Details <- aDetails |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsDrop <- aIsDrop
      ret (* 333 *)
  static member FromCs(src:ScriptDom.AuditSpecificationPart, fragmentMapping:FragmentMapping) : AuditSpecificationPart =
    let ret =
      AuditSpecificationPart.AuditSpecificationPart((src.Details |> Option.ofObj |> Option.map (fun x -> AuditSpecificationDetail.FromCs(x, fragmentMapping))), (src.IsDrop))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] AvailabilityReplica = (* Abstract? = false *)
  | AvailabilityReplica of Options:(AvailabilityReplicaOption) list * ServerName:StringLiteral option  
  member this.ToCs() : ScriptDom.AvailabilityReplica =
    match this with
    | AvailabilityReplica(Options=aOptions; ServerName=aServerName) ->
      let ret = ScriptDom.AvailabilityReplica()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.ServerName <- aServerName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.AvailabilityReplica, fragmentMapping:FragmentMapping) : AvailabilityReplica =
    let ret =
      AvailabilityReplica.AvailabilityReplica((src.Options |> Seq.map (fun x -> AvailabilityReplicaOption.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.ServerName |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] MirrorToClause = (* Abstract? = false *)
  | MirrorToClause of Devices:(DeviceInfo) list  
  member this.ToCs() : ScriptDom.MirrorToClause =
    match this with
    | MirrorToClause(Devices=aDevices) ->
      let ret = ScriptDom.MirrorToClause()
      for e in aDevices do ret.Devices.Add (e.ToCs())
      ret (* 333 *)
  static member FromCs(src:ScriptDom.MirrorToClause, fragmentMapping:FragmentMapping) : MirrorToClause =
    let ret =
      MirrorToClause.MirrorToClause((src.Devices |> Seq.map (fun src -> DeviceInfo.DeviceInfo((src.DeviceType), (src.LogicalDevice |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))), (src.PhysicalDevice |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] BackupRestoreFileInfo = (* Abstract? = false *)
  | BackupRestoreFileInfo of ItemKind:ScriptDom.BackupRestoreItemKind * Items:(ValueExpression) list  
  member this.ToCs() : ScriptDom.BackupRestoreFileInfo =
    match this with
    | BackupRestoreFileInfo(ItemKind=aItemKind; Items=aItems) ->
      let ret = ScriptDom.BackupRestoreFileInfo()
      ret.ItemKind <- aItemKind
      for e in aItems do ret.Items.Add (e.ToCs())
      ret (* 333 *)
  static member FromCs(src:ScriptDom.BackupRestoreFileInfo, fragmentMapping:FragmentMapping) : BackupRestoreFileInfo =
    let ret =
      BackupRestoreFileInfo.BackupRestoreFileInfo((src.ItemKind), (src.Items |> Seq.map (fun x -> ValueExpression.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] BrokerPriorityParameter = (* Abstract? = false *)
  | BrokerPriorityParameter of IsDefaultOrAny:ScriptDom.BrokerPriorityParameterSpecialType * ParameterType:ScriptDom.BrokerPriorityParameterType * ParameterValue:IdentifierOrValueExpression option  
  member this.ToCs() : ScriptDom.BrokerPriorityParameter =
    match this with
    | BrokerPriorityParameter(IsDefaultOrAny=aIsDefaultOrAny; ParameterType=aParameterType; ParameterValue=aParameterValue) ->
      let ret = ScriptDom.BrokerPriorityParameter()
      ret.IsDefaultOrAny <- aIsDefaultOrAny
      ret.ParameterType <- aParameterType
      ret.ParameterValue <- aParameterValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.BrokerPriorityParameter, fragmentMapping:FragmentMapping) : BrokerPriorityParameter =
    let ret =
      BrokerPriorityParameter.BrokerPriorityParameter((src.IsDefaultOrAny), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] InsertBulkColumnDefinition = (* Abstract? = false *)
  | InsertBulkColumnDefinition of Column:ColumnDefinitionBase option * NullNotNull:ScriptDom.NullNotNull  
  member this.ToCs() : ScriptDom.InsertBulkColumnDefinition =
    match this with
    | InsertBulkColumnDefinition(Column=aColumn; NullNotNull=aNullNotNull) ->
      let ret = ScriptDom.InsertBulkColumnDefinition()
      ret.Column <- aColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.NullNotNull <- aNullNotNull
      ret (* 333 *)
  static member FromCs(src:ScriptDom.InsertBulkColumnDefinition, fragmentMapping:FragmentMapping) : InsertBulkColumnDefinition =
    let ret =
      InsertBulkColumnDefinition.InsertBulkColumnDefinition((src.Column |> Option.ofObj |> Option.map (fun x -> ColumnDefinitionBase.FromCs(x, fragmentMapping))), (src.NullNotNull))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] CertificateOption = (* Abstract? = false *)
  | CertificateOption of Kind:ScriptDom.CertificateOptionKinds * Value:Literal option  
  member this.ToCs() : ScriptDom.CertificateOption =
    match this with
    | CertificateOption(Kind=aKind; Value=aValue) ->
      let ret = ScriptDom.CertificateOption()
      ret.Kind <- aKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.CertificateOption, fragmentMapping:FragmentMapping) : CertificateOption =
    let ret =
      CertificateOption.CertificateOption((src.Kind), (src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ColumnEncryptionKeyValue = (* Abstract? = false *)
  | ColumnEncryptionKeyValue of Parameters:(ColumnEncryptionKeyValueParameter) list  
  member this.ToCs() : ScriptDom.ColumnEncryptionKeyValue =
    match this with
    | ColumnEncryptionKeyValue(Parameters=aParameters) ->
      let ret = ScriptDom.ColumnEncryptionKeyValue()
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret (* 333 *)
  static member FromCs(src:ScriptDom.ColumnEncryptionKeyValue, fragmentMapping:FragmentMapping) : ColumnEncryptionKeyValue =
    let ret =
      ColumnEncryptionKeyValue.ColumnEncryptionKeyValue((src.Parameters |> Seq.map (fun x -> ColumnEncryptionKeyValueParameter.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] CopyOption = (* Abstract? = false *)
  | CopyOption of Kind:ScriptDom.CopyOptionKind * Value:CopyStatementOptionBase option  
  member this.ToCs() : ScriptDom.CopyOption =
    match this with
    | CopyOption(Kind=aKind; Value=aValue) ->
      let ret = ScriptDom.CopyOption()
      ret.Kind <- aKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.CopyOption, fragmentMapping:FragmentMapping) : CopyOption =
    let ret =
      CopyOption.CopyOption((src.Kind), (src.Value |> Option.ofObj |> Option.map (fun x -> CopyStatementOptionBase.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] AssemblyName = (* Abstract? = false *)
  | AssemblyName of ClassName:Identifier option * Name:Identifier option  
  member this.ToCs() : ScriptDom.AssemblyName =
    match this with
    | AssemblyName(ClassName=aClassName; Name=aName) ->
      let ret = ScriptDom.AssemblyName()
      ret.ClassName <- aClassName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.AssemblyName, fragmentMapping:FragmentMapping) : AssemblyName =
    let ret =
      AssemblyName.AssemblyName((src.ClassName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ProcedureParameter = (* Abstract? = false *)
  | ProcedureParameter of DataType:DataTypeReference option * IsVarying:bool * Modifier:ScriptDom.ParameterModifier * Nullable:NullableConstraintDefinition option * Value:ScalarExpression option * VariableName:Identifier option  
  member this.ToCs() : ScriptDom.ProcedureParameter =
    match this with
    | ProcedureParameter(DataType=aDataType; IsVarying=aIsVarying; Modifier=aModifier; Nullable=aNullable; Value=aValue; VariableName=aVariableName) ->
      let ret = ScriptDom.ProcedureParameter()
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsVarying <- aIsVarying
      ret.Modifier <- aModifier
      ret.Nullable <- aNullable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.VariableName <- aVariableName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.ProcedureParameter, fragmentMapping:FragmentMapping) : ProcedureParameter =
    let ret =
      ProcedureParameter.ProcedureParameter((src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.IsVarying), (src.Modifier), (src.Nullable |> Option.ofObj |> Option.map (fun x -> NullableConstraintDefinition.FromCs(x, fragmentMapping))), (src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.VariableName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ContractMessage = (* Abstract? = false *)
  | ContractMessage of Name:Identifier option * SentBy:ScriptDom.MessageSender  
  member this.ToCs() : ScriptDom.ContractMessage =
    match this with
    | ContractMessage(Name=aName; SentBy=aSentBy) ->
      let ret = ScriptDom.ContractMessage()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SentBy <- aSentBy
      ret (* 333 *)
  static member FromCs(src:ScriptDom.ContractMessage, fragmentMapping:FragmentMapping) : ContractMessage =
    let ret =
      ContractMessage.ContractMessage((src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.SentBy))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ContainmentDatabaseOption = (* Abstract? = false *)
  | ContainmentDatabaseOption of OptionKind:ScriptDom.DatabaseOptionKind * Value:ScriptDom.ContainmentOptionKind  
  member this.ToCs() : ScriptDom.ContainmentDatabaseOption =
    match this with
    | ContainmentDatabaseOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.ContainmentDatabaseOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret (* 333 *)
  static member FromCs(src:ScriptDom.ContainmentDatabaseOption, fragmentMapping:FragmentMapping) : ContainmentDatabaseOption =
    let ret =
      ContainmentDatabaseOption.ContainmentDatabaseOption((src.OptionKind), (src.Value))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] FileGroupDefinition = (* Abstract? = false *)
  | FileGroupDefinition of ContainsFileStream:bool * ContainsMemoryOptimizedData:bool * FileDeclarations:(FileDeclaration) list * IsDefault:bool * Name:Identifier option  
  member this.ToCs() : ScriptDom.FileGroupDefinition =
    match this with
    | FileGroupDefinition(ContainsFileStream=aContainsFileStream; ContainsMemoryOptimizedData=aContainsMemoryOptimizedData; FileDeclarations=aFileDeclarations; IsDefault=aIsDefault; Name=aName) ->
      let ret = ScriptDom.FileGroupDefinition()
      ret.ContainsFileStream <- aContainsFileStream
      ret.ContainsMemoryOptimizedData <- aContainsMemoryOptimizedData
      for e in aFileDeclarations do ret.FileDeclarations.Add (e.ToCs())
      ret.IsDefault <- aIsDefault
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.FileGroupDefinition, fragmentMapping:FragmentMapping) : FileGroupDefinition =
    let ret =
      FileGroupDefinition.FileGroupDefinition((src.ContainsFileStream), (src.ContainsMemoryOptimizedData), (src.FileDeclarations |> Seq.map (fun src -> FileDeclaration.FileDeclaration((src.IsPrimary), (src.Options |> Seq.map (fun x -> FileDeclarationOption.FromCs(x, fragmentMapping)) |> List.ofSeq))) |> List.ofSeq), (src.IsDefault), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] EventNotificationObjectScope = (* Abstract? = false *)
  | EventNotificationObjectScope of QueueName:SchemaObjectName option * Target:ScriptDom.EventNotificationTarget  
  member this.ToCs() : ScriptDom.EventNotificationObjectScope =
    match this with
    | EventNotificationObjectScope(QueueName=aQueueName; Target=aTarget) ->
      let ret = ScriptDom.EventNotificationObjectScope()
      ret.QueueName <- aQueueName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Target <- aTarget
      ret (* 333 *)
  static member FromCs(src:ScriptDom.EventNotificationObjectScope, fragmentMapping:FragmentMapping) : EventNotificationObjectScope =
    let ret =
      EventNotificationObjectScope.EventNotificationObjectScope((src.QueueName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.Target))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] FullTextCatalogAndFileGroup = (* Abstract? = false *)
  | FullTextCatalogAndFileGroup of CatalogName:Identifier option * FileGroupIsFirst:bool * FileGroupName:Identifier option  
  member this.ToCs() : ScriptDom.FullTextCatalogAndFileGroup =
    match this with
    | FullTextCatalogAndFileGroup(CatalogName=aCatalogName; FileGroupIsFirst=aFileGroupIsFirst; FileGroupName=aFileGroupName) ->
      let ret = ScriptDom.FullTextCatalogAndFileGroup()
      ret.CatalogName <- aCatalogName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FileGroupIsFirst <- aFileGroupIsFirst
      ret.FileGroupName <- aFileGroupName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.FullTextCatalogAndFileGroup, fragmentMapping:FragmentMapping) : FullTextCatalogAndFileGroup =
    let ret =
      FullTextCatalogAndFileGroup.FullTextCatalogAndFileGroup((src.CatalogName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.FileGroupIsFirst), (src.FileGroupName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] PartitionParameterType = (* Abstract? = false *)
  | PartitionParameterType of Collation:Identifier option * DataType:DataTypeReference option  
  member this.ToCs() : ScriptDom.PartitionParameterType =
    match this with
    | PartitionParameterType(Collation=aCollation; DataType=aDataType) ->
      let ret = ScriptDom.PartitionParameterType()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.PartitionParameterType, fragmentMapping:FragmentMapping) : PartitionParameterType =
    let ret =
      PartitionParameterType.PartitionParameterType((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] FederationScheme = (* Abstract? = false *)
  | FederationScheme of ColumnName:Identifier option * DistributionName:Identifier option  
  member this.ToCs() : ScriptDom.FederationScheme =
    match this with
    | FederationScheme(ColumnName=aColumnName; DistributionName=aDistributionName) ->
      let ret = ScriptDom.FederationScheme()
      ret.ColumnName <- aColumnName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DistributionName <- aDistributionName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.FederationScheme, fragmentMapping:FragmentMapping) : FederationScheme =
    let ret =
      FederationScheme.FederationScheme((src.ColumnName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.DistributionName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] CursorId = (* Abstract? = false *)
  | CursorId of IsGlobal:bool * Name:IdentifierOrValueExpression option  
  member this.ToCs() : ScriptDom.CursorId =
    match this with
    | CursorId(IsGlobal=aIsGlobal; Name=aName) ->
      let ret = ScriptDom.CursorId()
      ret.IsGlobal <- aIsGlobal
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.CursorId, fragmentMapping:FragmentMapping) : CursorId =
    let ret =
      CursorId.CursorId((src.IsGlobal), (src.Name |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] FetchType = (* Abstract? = false *)
  | FetchType of Orientation:ScriptDom.FetchOrientation * RowOffset:ScalarExpression option  
  member this.ToCs() : ScriptDom.FetchType =
    match this with
    | FetchType(Orientation=aOrientation; RowOffset=aRowOffset) ->
      let ret = ScriptDom.FetchType()
      ret.Orientation <- aOrientation
      ret.RowOffset <- aRowOffset |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.FetchType, fragmentMapping:FragmentMapping) : FetchType =
    let ret =
      FetchType.FetchType((src.Orientation), (src.RowOffset |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] DbccNamedLiteral = (* Abstract? = false *)
  | DbccNamedLiteral of Name:String option * Value:ScalarExpression option  
  member this.ToCs() : ScriptDom.DbccNamedLiteral =
    match this with
    | DbccNamedLiteral(Name=aName; Value=aValue) ->
      let ret = ScriptDom.DbccNamedLiteral()
      ret.Name <- aName |> Option.toObj
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.DbccNamedLiteral, fragmentMapping:FragmentMapping) : DbccNamedLiteral =
    let ret =
      DbccNamedLiteral.DbccNamedLiteral((Option.ofObj (src.Name)), (src.Value |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] DbccOption = (* Abstract? = false *)
  | DbccOption of OptionKind:ScriptDom.DbccOptionKind  
  member this.ToCs() : ScriptDom.DbccOption =
    match this with
    | DbccOption(OptionKind=aOptionKind) ->
      let ret = ScriptDom.DbccOption()
      ret.OptionKind <- aOptionKind
      ret (* 333 *)
  static member FromCs(src:ScriptDom.DbccOption, fragmentMapping:FragmentMapping) : DbccOption =
    let ret =
      DbccOption.DbccOption((src.OptionKind))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] CursorDefinition = (* Abstract? = false *)
  | CursorDefinition of Options:(CursorOption) list * Select:SelectStatement option  
  member this.ToCs() : ScriptDom.CursorDefinition =
    match this with
    | CursorDefinition(Options=aOptions; Select=aSelect) ->
      let ret = ScriptDom.CursorDefinition()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.Select <- aSelect |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.CursorDefinition, fragmentMapping:FragmentMapping) : CursorDefinition =
    let ret =
      CursorDefinition.CursorDefinition((src.Options |> Seq.map (fun src -> CursorOption.CursorOption((src.OptionKind))) |> List.ofSeq), (src.Select |> Option.ofObj |> Option.map (fun x -> SelectStatement.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] DiskStatementOption = (* Abstract? = false *)
  | DiskStatementOption of OptionKind:ScriptDom.DiskStatementOptionKind * Value:IdentifierOrValueExpression option  
  member this.ToCs() : ScriptDom.DiskStatementOption =
    match this with
    | DiskStatementOption(OptionKind=aOptionKind; Value=aValue) ->
      let ret = ScriptDom.DiskStatementOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.DiskStatementOption, fragmentMapping:FragmentMapping) : DiskStatementOption =
    let ret =
      DiskStatementOption.DiskStatementOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (fun x -> IdentifierOrValueExpression.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] TriggerObject = (* Abstract? = false *)
  | TriggerObject of Name:SchemaObjectName option * TriggerScope:ScriptDom.TriggerScope  
  member this.ToCs() : ScriptDom.TriggerObject =
    match this with
    | TriggerObject(Name=aName; TriggerScope=aTriggerScope) ->
      let ret = ScriptDom.TriggerObject()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TriggerScope <- aTriggerScope
      ret (* 333 *)
  static member FromCs(src:ScriptDom.TriggerObject, fragmentMapping:FragmentMapping) : TriggerObject =
    let ret =
      TriggerObject.TriggerObject((src.Name |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.TriggerScope))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] EventDeclaration = (* Abstract? = false *)
  | EventDeclaration of EventDeclarationActionParameters:(EventSessionObjectName) list * EventDeclarationPredicateParameter:BooleanExpression option * EventDeclarationSetParameters:(EventDeclarationSetParameter) list * ObjectName:EventSessionObjectName option  
  member this.ToCs() : ScriptDom.EventDeclaration =
    match this with
    | EventDeclaration(EventDeclarationActionParameters=aEventDeclarationActionParameters; EventDeclarationPredicateParameter=aEventDeclarationPredicateParameter; EventDeclarationSetParameters=aEventDeclarationSetParameters; ObjectName=aObjectName) ->
      let ret = ScriptDom.EventDeclaration()
      for e in aEventDeclarationActionParameters do ret.EventDeclarationActionParameters.Add (e.ToCs())
      ret.EventDeclarationPredicateParameter <- aEventDeclarationPredicateParameter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aEventDeclarationSetParameters do ret.EventDeclarationSetParameters.Add (e.ToCs())
      ret.ObjectName <- aObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.EventDeclaration, fragmentMapping:FragmentMapping) : EventDeclaration =
    let ret =
      EventDeclaration.EventDeclaration((src.EventDeclarationActionParameters |> Seq.map (fun src -> EventSessionObjectName.EventSessionObjectName((src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.EventDeclarationPredicateParameter |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))), (src.EventDeclarationSetParameters |> Seq.map (fun src -> EventDeclarationSetParameter.EventDeclarationSetParameter((src.EventField |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.EventValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.ObjectName |> Option.ofObj |> Option.map (fun x -> EventSessionObjectName.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] TargetDeclaration = (* Abstract? = false *)
  | TargetDeclaration of ObjectName:EventSessionObjectName option * TargetDeclarationParameters:(EventDeclarationSetParameter) list  
  member this.ToCs() : ScriptDom.TargetDeclaration =
    match this with
    | TargetDeclaration(ObjectName=aObjectName; TargetDeclarationParameters=aTargetDeclarationParameters) ->
      let ret = ScriptDom.TargetDeclaration()
      ret.ObjectName <- aObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aTargetDeclarationParameters do ret.TargetDeclarationParameters.Add (e.ToCs())
      ret (* 333 *)
  static member FromCs(src:ScriptDom.TargetDeclaration, fragmentMapping:FragmentMapping) : TargetDeclaration =
    let ret =
      TargetDeclaration.TargetDeclaration((src.ObjectName |> Option.ofObj |> Option.map (fun x -> EventSessionObjectName.FromCs(x, fragmentMapping))), (src.TargetDeclarationParameters |> Seq.map (fun src -> EventDeclarationSetParameter.EventDeclarationSetParameter((src.EventField |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.EventValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ExternalResourcePoolParameter = (* Abstract? = false *)
  | ExternalResourcePoolParameter of AffinitySpecification:ExternalResourcePoolAffinitySpecification option * ParameterType:ScriptDom.ExternalResourcePoolParameterType * ParameterValue:Literal option  
  member this.ToCs() : ScriptDom.ExternalResourcePoolParameter =
    match this with
    | ExternalResourcePoolParameter(AffinitySpecification=aAffinitySpecification; ParameterType=aParameterType; ParameterValue=aParameterValue) ->
      let ret = ScriptDom.ExternalResourcePoolParameter()
      ret.AffinitySpecification <- aAffinitySpecification |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ParameterType <- aParameterType
      ret.ParameterValue <- aParameterValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.ExternalResourcePoolParameter, fragmentMapping:FragmentMapping) : ExternalResourcePoolParameter =
    let ret =
      ExternalResourcePoolParameter.ExternalResourcePoolParameter((src.AffinitySpecification |> Option.ofObj |> Option.map (fun x -> ExternalResourcePoolAffinitySpecification.FromCs(x, fragmentMapping))), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ExternalTableColumnDefinition = (* Abstract? = false *)
  | ExternalTableColumnDefinition of ColumnDefinition:ColumnDefinitionBase option * NullableConstraint:NullableConstraintDefinition option  
  member this.ToCs() : ScriptDom.ExternalTableColumnDefinition =
    match this with
    | ExternalTableColumnDefinition(ColumnDefinition=aColumnDefinition; NullableConstraint=aNullableConstraint) ->
      let ret = ScriptDom.ExternalTableColumnDefinition()
      ret.ColumnDefinition <- aColumnDefinition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.NullableConstraint <- aNullableConstraint |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.ExternalTableColumnDefinition, fragmentMapping:FragmentMapping) : ExternalTableColumnDefinition =
    let ret =
      ExternalTableColumnDefinition.ExternalTableColumnDefinition((src.ColumnDefinition |> Option.ofObj |> Option.map (fun x -> ColumnDefinitionBase.FromCs(x, fragmentMapping))), (src.NullableConstraint |> Option.ofObj |> Option.map (fun x -> NullableConstraintDefinition.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] SelectiveXmlIndexPromotedPath = (* Abstract? = false *)
  | SelectiveXmlIndexPromotedPath of IsSingleton:bool * MaxLength:IntegerLiteral option * Name:Identifier option * Path:Literal option * SQLDataType:DataTypeReference option * XQueryDataType:Literal option  
  member this.ToCs() : ScriptDom.SelectiveXmlIndexPromotedPath =
    match this with
    | SelectiveXmlIndexPromotedPath(IsSingleton=aIsSingleton; MaxLength=aMaxLength; Name=aName; Path=aPath; SQLDataType=aSQLDataType; XQueryDataType=aXQueryDataType) ->
      let ret = ScriptDom.SelectiveXmlIndexPromotedPath()
      ret.IsSingleton <- aIsSingleton
      ret.MaxLength <- aMaxLength |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Path <- aPath |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SQLDataType <- aSQLDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.XQueryDataType <- aXQueryDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.SelectiveXmlIndexPromotedPath, fragmentMapping:FragmentMapping) : SelectiveXmlIndexPromotedPath =
    let ret =
      SelectiveXmlIndexPromotedPath.SelectiveXmlIndexPromotedPath((src.IsSingleton), (src.MaxLength |> Option.ofObj |> Option.map (fun x -> IntegerLiteral.FromCs(x, fragmentMapping))), (src.Name |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Path |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.SQLDataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.XQueryDataType |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] XmlNamespaces = (* Abstract? = false *)
  | XmlNamespaces of XmlNamespacesElements:(XmlNamespacesElement) list  
  member this.ToCs() : ScriptDom.XmlNamespaces =
    match this with
    | XmlNamespaces(XmlNamespacesElements=aXmlNamespacesElements) ->
      let ret = ScriptDom.XmlNamespaces()
      for e in aXmlNamespacesElements do ret.XmlNamespacesElements.Add (e.ToCs())
      ret (* 333 *)
  static member FromCs(src:ScriptDom.XmlNamespaces, fragmentMapping:FragmentMapping) : XmlNamespaces =
    let ret =
      XmlNamespaces.XmlNamespaces((src.XmlNamespacesElements |> Seq.map (fun x -> XmlNamespacesElement.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] MethodSpecifier = (* Abstract? = false *)
  | MethodSpecifier of AssemblyName:Identifier option * ClassName:Identifier option * MethodName:Identifier option  
  member this.ToCs() : ScriptDom.MethodSpecifier =
    match this with
    | MethodSpecifier(AssemblyName=aAssemblyName; ClassName=aClassName; MethodName=aMethodName) ->
      let ret = ScriptDom.MethodSpecifier()
      ret.AssemblyName <- aAssemblyName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ClassName <- aClassName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.MethodName <- aMethodName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.MethodSpecifier, fragmentMapping:FragmentMapping) : MethodSpecifier =
    let ret =
      MethodSpecifier.MethodSpecifier((src.AssemblyName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ClassName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.MethodName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] OrderBulkInsertOption = (* Abstract? = false *)
  | OrderBulkInsertOption of Columns:(ColumnWithSortOrder) list * IsUnique:bool * OptionKind:ScriptDom.BulkInsertOptionKind  
  member this.ToCs() : ScriptDom.OrderBulkInsertOption =
    match this with
    | OrderBulkInsertOption(Columns=aColumns; IsUnique=aIsUnique; OptionKind=aOptionKind) ->
      let ret = ScriptDom.OrderBulkInsertOption()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.IsUnique <- aIsUnique
      ret.OptionKind <- aOptionKind
      ret (* 333 *)
  static member FromCs(src:ScriptDom.OrderBulkInsertOption, fragmentMapping:FragmentMapping) : OrderBulkInsertOption =
    let ret =
      OrderBulkInsertOption.OrderBulkInsertOption((src.Columns |> Seq.map (fun src -> ColumnWithSortOrder.ColumnWithSortOrder((src.Column |> Option.ofObj |> Option.map (fun x -> ColumnReferenceExpression.FromCs(x, fragmentMapping))), (src.SortOrder))) |> List.ofSeq), (src.IsUnique), (src.OptionKind))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] SeparatorType = (* Abstract? = false *)
  | SeparatorType   
  member this.ToCs() : ScriptDom.SeparatorType =
    match this with
    | SeparatorType -> ScriptDom.SeparatorType() (* 327 *)
  static member FromCs(src:ScriptDom.SeparatorType, fragmentMapping:FragmentMapping) : SeparatorType =
    let ret =
      SeparatorType.SeparatorType 
    ret
and [<RequireQualifiedAccess>] ResourcePoolParameter = (* Abstract? = false *)
  | ResourcePoolParameter of AffinitySpecification:ResourcePoolAffinitySpecification option * ParameterType:ScriptDom.ResourcePoolParameterType * ParameterValue:Literal option  
  member this.ToCs() : ScriptDom.ResourcePoolParameter =
    match this with
    | ResourcePoolParameter(AffinitySpecification=aAffinitySpecification; ParameterType=aParameterType; ParameterValue=aParameterValue) ->
      let ret = ScriptDom.ResourcePoolParameter()
      ret.AffinitySpecification <- aAffinitySpecification |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ParameterType <- aParameterType
      ret.ParameterValue <- aParameterValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.ResourcePoolParameter, fragmentMapping:FragmentMapping) : ResourcePoolParameter =
    let ret =
      ResourcePoolParameter.ResourcePoolParameter((src.AffinitySpecification |> Option.ofObj |> Option.map (fun x -> ResourcePoolAffinitySpecification.FromCs(x, fragmentMapping))), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] RouteOption = (* Abstract? = false *)
  | RouteOption of Literal:Literal option * OptionKind:ScriptDom.RouteOptionKind  
  member this.ToCs() : ScriptDom.RouteOption =
    match this with
    | RouteOption(Literal=aLiteral; OptionKind=aOptionKind) ->
      let ret = ScriptDom.RouteOption()
      ret.Literal <- aLiteral |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret (* 333 *)
  static member FromCs(src:ScriptDom.RouteOption, fragmentMapping:FragmentMapping) : RouteOption =
    let ret =
      RouteOption.RouteOption((src.Literal |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))), (src.OptionKind))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] SecurityPolicyOption = (* Abstract? = false *)
  | SecurityPolicyOption of OptionKind:ScriptDom.SecurityPolicyOptionKind * OptionState:ScriptDom.OptionState  
  member this.ToCs() : ScriptDom.SecurityPolicyOption =
    match this with
    | SecurityPolicyOption(OptionKind=aOptionKind; OptionState=aOptionState) ->
      let ret = ScriptDom.SecurityPolicyOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret (* 333 *)
  static member FromCs(src:ScriptDom.SecurityPolicyOption, fragmentMapping:FragmentMapping) : SecurityPolicyOption =
    let ret =
      SecurityPolicyOption.SecurityPolicyOption((src.OptionKind), (src.OptionState))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] SecurityPredicateAction = (* Abstract? = false *)
  | SecurityPredicateAction of ActionType:ScriptDom.SecurityPredicateActionType * FunctionCall:FunctionCall option * SecurityPredicateOperation:ScriptDom.SecurityPredicateOperation * SecurityPredicateType:ScriptDom.SecurityPredicateType * TargetObjectName:SchemaObjectName option  
  member this.ToCs() : ScriptDom.SecurityPredicateAction =
    match this with
    | SecurityPredicateAction(ActionType=aActionType; FunctionCall=aFunctionCall; SecurityPredicateOperation=aSecurityPredicateOperation; SecurityPredicateType=aSecurityPredicateType; TargetObjectName=aTargetObjectName) ->
      let ret = ScriptDom.SecurityPredicateAction()
      ret.ActionType <- aActionType
      ret.FunctionCall <- aFunctionCall |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SecurityPredicateOperation <- aSecurityPredicateOperation
      ret.SecurityPredicateType <- aSecurityPredicateType
      ret.TargetObjectName <- aTargetObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.SecurityPredicateAction, fragmentMapping:FragmentMapping) : SecurityPredicateAction =
    let ret =
      SecurityPredicateAction.SecurityPredicateAction((src.ActionType), (src.FunctionCall |> Option.ofObj |> Option.map (fun x -> FunctionCall.FromCs(x, fragmentMapping))), (src.SecurityPredicateOperation), (src.SecurityPredicateType), (src.TargetObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] Permission = (* Abstract? = false *)
  | Permission of Columns:(Identifier) list * Identifiers:(Identifier) list  
  member this.ToCs() : ScriptDom.Permission =
    match this with
    | Permission(Columns=aColumns; Identifiers=aIdentifiers) ->
      let ret = ScriptDom.Permission()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      for e in aIdentifiers do ret.Identifiers.Add (e.ToCs())
      ret (* 333 *)
  static member FromCs(src:ScriptDom.Permission, fragmentMapping:FragmentMapping) : Permission =
    let ret =
      Permission.Permission((src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Identifiers |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] SecurityUserClause80 = (* Abstract? = false *)
  | SecurityUserClause80 of UserType80:ScriptDom.UserType80 * Users:(Identifier) list  
  member this.ToCs() : ScriptDom.SecurityUserClause80 =
    match this with
    | SecurityUserClause80(UserType80=aUserType80; Users=aUsers) ->
      let ret = ScriptDom.SecurityUserClause80()
      ret.UserType80 <- aUserType80
      for e in aUsers do ret.Users.Add (e.ToCs())
      ret (* 333 *)
  static member FromCs(src:ScriptDom.SecurityUserClause80, fragmentMapping:FragmentMapping) : SecurityUserClause80 =
    let ret =
      SecurityUserClause80.SecurityUserClause80((src.UserType80), (src.Users |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] SensitivityClassificationOption = (* Abstract? = false *)
  | SensitivityClassificationOption of Type:ScriptDom.SensitivityClassification.OptionType * Value:Literal option  
  member this.ToCs() : ScriptDom.SensitivityClassificationOption =
    match this with
    | SensitivityClassificationOption(Type=aType; Value=aValue) ->
      let ret = ScriptDom.SensitivityClassificationOption()
      ret.Type <- aType
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.SensitivityClassificationOption, fragmentMapping:FragmentMapping) : SensitivityClassificationOption =
    let ret =
      SensitivityClassificationOption.SensitivityClassificationOption((src.Type), (src.Value |> Option.ofObj |> Option.map (fun x -> Literal.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] AuditTarget = (* Abstract? = false *)
  | AuditTarget of TargetKind:ScriptDom.AuditTargetKind * TargetOptions:(AuditTargetOption) list  
  member this.ToCs() : ScriptDom.AuditTarget =
    match this with
    | AuditTarget(TargetKind=aTargetKind; TargetOptions=aTargetOptions) ->
      let ret = ScriptDom.AuditTarget()
      ret.TargetKind <- aTargetKind
      for e in aTargetOptions do ret.TargetOptions.Add (e.ToCs())
      ret (* 333 *)
  static member FromCs(src:ScriptDom.AuditTarget, fragmentMapping:FragmentMapping) : AuditTarget =
    let ret =
      AuditTarget.AuditTarget((src.TargetKind), (src.TargetOptions |> Seq.map (fun x -> AuditTargetOption.FromCs(x, fragmentMapping)) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] WithCtesAndXmlNamespaces = (* Abstract? = false *)
  | WithCtesAndXmlNamespaces of ChangeTrackingContext:ValueExpression option * CommonTableExpressions:(CommonTableExpression) list * XmlNamespaces:XmlNamespaces option  
  member this.ToCs() : ScriptDom.WithCtesAndXmlNamespaces =
    match this with
    | WithCtesAndXmlNamespaces(ChangeTrackingContext=aChangeTrackingContext; CommonTableExpressions=aCommonTableExpressions; XmlNamespaces=aXmlNamespaces) ->
      let ret = ScriptDom.WithCtesAndXmlNamespaces()
      ret.ChangeTrackingContext <- aChangeTrackingContext |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aCommonTableExpressions do ret.CommonTableExpressions.Add (e.ToCs())
      ret.XmlNamespaces <- aXmlNamespaces |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.WithCtesAndXmlNamespaces, fragmentMapping:FragmentMapping) : WithCtesAndXmlNamespaces =
    let ret =
      WithCtesAndXmlNamespaces.WithCtesAndXmlNamespaces((src.ChangeTrackingContext |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))), (src.CommonTableExpressions |> Seq.map (fun src -> CommonTableExpression.CommonTableExpression((src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.ExpressionName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.QueryExpression |> Option.ofObj |> Option.map (fun x -> QueryExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.XmlNamespaces |> Option.ofObj |> Option.map (fun x -> XmlNamespaces.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] DeleteSpecification = (* Abstract? = false *)
  | DeleteSpecification of FromClause:FromClause option * OutputClause:OutputClause option * OutputIntoClause:OutputIntoClause option * Target:TableReference option * TopRowFilter:TopRowFilter option * WhereClause:WhereClause option  
  member this.ToCs() : ScriptDom.DeleteSpecification =
    match this with
    | DeleteSpecification(FromClause=aFromClause; OutputClause=aOutputClause; OutputIntoClause=aOutputIntoClause; Target=aTarget; TopRowFilter=aTopRowFilter; WhereClause=aWhereClause) ->
      let ret = ScriptDom.DeleteSpecification()
      ret.FromClause <- aFromClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OutputClause <- aOutputClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OutputIntoClause <- aOutputIntoClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Target <- aTarget |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TopRowFilter <- aTopRowFilter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WhereClause <- aWhereClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.DeleteSpecification, fragmentMapping:FragmentMapping) : DeleteSpecification =
    let ret =
      DeleteSpecification.DeleteSpecification((src.FromClause |> Option.ofObj |> Option.map (fun x -> FromClause.FromCs(x, fragmentMapping))), (src.OutputClause |> Option.ofObj |> Option.map (fun x -> OutputClause.FromCs(x, fragmentMapping))), (src.OutputIntoClause |> Option.ofObj |> Option.map (fun x -> OutputIntoClause.FromCs(x, fragmentMapping))), (src.Target |> Option.ofObj |> Option.map (fun x -> TableReference.FromCs(x, fragmentMapping))), (src.TopRowFilter |> Option.ofObj |> Option.map (fun x -> TopRowFilter.FromCs(x, fragmentMapping))), (src.WhereClause |> Option.ofObj |> Option.map (fun x -> WhereClause.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] InsertSpecification = (* Abstract? = false *)
  | InsertSpecification of Columns:(ColumnReferenceExpression) list * InsertOption:ScriptDom.InsertOption * InsertSource:InsertSource option * OutputClause:OutputClause option * OutputIntoClause:OutputIntoClause option * Target:TableReference option * TopRowFilter:TopRowFilter option  
  member this.ToCs() : ScriptDom.InsertSpecification =
    match this with
    | InsertSpecification(Columns=aColumns; InsertOption=aInsertOption; InsertSource=aInsertSource; OutputClause=aOutputClause; OutputIntoClause=aOutputIntoClause; Target=aTarget; TopRowFilter=aTopRowFilter) ->
      let ret = ScriptDom.InsertSpecification()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.InsertOption <- aInsertOption
      ret.InsertSource <- aInsertSource |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OutputClause <- aOutputClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OutputIntoClause <- aOutputIntoClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Target <- aTarget |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TopRowFilter <- aTopRowFilter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.InsertSpecification, fragmentMapping:FragmentMapping) : InsertSpecification =
    let ret =
      InsertSpecification.InsertSpecification((src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (fun x -> MultiPartIdentifier.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.InsertOption), (src.InsertSource |> Option.ofObj |> Option.map (fun x -> InsertSource.FromCs(x, fragmentMapping))), (src.OutputClause |> Option.ofObj |> Option.map (fun x -> OutputClause.FromCs(x, fragmentMapping))), (src.OutputIntoClause |> Option.ofObj |> Option.map (fun x -> OutputIntoClause.FromCs(x, fragmentMapping))), (src.Target |> Option.ofObj |> Option.map (fun x -> TableReference.FromCs(x, fragmentMapping))), (src.TopRowFilter |> Option.ofObj |> Option.map (fun x -> TopRowFilter.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] MergeSpecification = (* Abstract? = false *)
  | MergeSpecification of ActionClauses:(MergeActionClause) list * OutputClause:OutputClause option * OutputIntoClause:OutputIntoClause option * SearchCondition:BooleanExpression option * TableAlias:Identifier option * TableReference:TableReference option * Target:TableReference option * TopRowFilter:TopRowFilter option  
  member this.ToCs() : ScriptDom.MergeSpecification =
    match this with
    | MergeSpecification(ActionClauses=aActionClauses; OutputClause=aOutputClause; OutputIntoClause=aOutputIntoClause; SearchCondition=aSearchCondition; TableAlias=aTableAlias; TableReference=aTableReference; Target=aTarget; TopRowFilter=aTopRowFilter) ->
      let ret = ScriptDom.MergeSpecification()
      for e in aActionClauses do ret.ActionClauses.Add (e.ToCs())
      ret.OutputClause <- aOutputClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OutputIntoClause <- aOutputIntoClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SearchCondition <- aSearchCondition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TableAlias <- aTableAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TableReference <- aTableReference |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Target <- aTarget |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TopRowFilter <- aTopRowFilter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.MergeSpecification, fragmentMapping:FragmentMapping) : MergeSpecification =
    let ret =
      MergeSpecification.MergeSpecification((src.ActionClauses |> Seq.map (fun src -> MergeActionClause.MergeActionClause((src.Action |> Option.ofObj |> Option.map (fun x -> MergeAction.FromCs(x, fragmentMapping))), (src.Condition), (src.SearchCondition |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq), (src.OutputClause |> Option.ofObj |> Option.map (fun x -> OutputClause.FromCs(x, fragmentMapping))), (src.OutputIntoClause |> Option.ofObj |> Option.map (fun x -> OutputIntoClause.FromCs(x, fragmentMapping))), (src.SearchCondition |> Option.ofObj |> Option.map (fun x -> BooleanExpression.FromCs(x, fragmentMapping))), (src.TableAlias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.TableReference |> Option.ofObj |> Option.map (fun x -> TableReference.FromCs(x, fragmentMapping))), (src.Target |> Option.ofObj |> Option.map (fun x -> TableReference.FromCs(x, fragmentMapping))), (src.TopRowFilter |> Option.ofObj |> Option.map (fun x -> TopRowFilter.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] UpdateSpecification = (* Abstract? = false *)
  | UpdateSpecification of FromClause:FromClause option * OutputClause:OutputClause option * OutputIntoClause:OutputIntoClause option * SetClauses:(SetClause) list * Target:TableReference option * TopRowFilter:TopRowFilter option * WhereClause:WhereClause option  
  member this.ToCs() : ScriptDom.UpdateSpecification =
    match this with
    | UpdateSpecification(FromClause=aFromClause; OutputClause=aOutputClause; OutputIntoClause=aOutputIntoClause; SetClauses=aSetClauses; Target=aTarget; TopRowFilter=aTopRowFilter; WhereClause=aWhereClause) ->
      let ret = ScriptDom.UpdateSpecification()
      ret.FromClause <- aFromClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OutputClause <- aOutputClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OutputIntoClause <- aOutputIntoClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aSetClauses do ret.SetClauses.Add (e.ToCs())
      ret.Target <- aTarget |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TopRowFilter <- aTopRowFilter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WhereClause <- aWhereClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.UpdateSpecification, fragmentMapping:FragmentMapping) : UpdateSpecification =
    let ret =
      UpdateSpecification.UpdateSpecification((src.FromClause |> Option.ofObj |> Option.map (fun x -> FromClause.FromCs(x, fragmentMapping))), (src.OutputClause |> Option.ofObj |> Option.map (fun x -> OutputClause.FromCs(x, fragmentMapping))), (src.OutputIntoClause |> Option.ofObj |> Option.map (fun x -> OutputIntoClause.FromCs(x, fragmentMapping))), (src.SetClauses |> Seq.map (fun x -> SetClause.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Target |> Option.ofObj |> Option.map (fun x -> TableReference.FromCs(x, fragmentMapping))), (src.TopRowFilter |> Option.ofObj |> Option.map (fun x -> TopRowFilter.FromCs(x, fragmentMapping))), (src.WhereClause |> Option.ofObj |> Option.map (fun x -> WhereClause.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ComputeClause = (* Abstract? = false *)
  | ComputeClause of ByExpressions:(ScalarExpression) list * ComputeFunctions:(ComputeFunction) list  
  member this.ToCs() : ScriptDom.ComputeClause =
    match this with
    | ComputeClause(ByExpressions=aByExpressions; ComputeFunctions=aComputeFunctions) ->
      let ret = ScriptDom.ComputeClause()
      for e in aByExpressions do ret.ByExpressions.Add (e.ToCs())
      for e in aComputeFunctions do ret.ComputeFunctions.Add (e.ToCs())
      ret (* 333 *)
  static member FromCs(src:ScriptDom.ComputeClause, fragmentMapping:FragmentMapping) : ComputeClause =
    let ret =
      ComputeClause.ComputeClause((src.ByExpressions |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.ComputeFunctions |> Seq.map (fun src -> ComputeFunction.ComputeFunction((src.ComputeFunctionType), (src.Expression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] TriggerAction = (* Abstract? = false *)
  | TriggerAction of EventTypeGroup:EventTypeGroupContainer option * TriggerActionType:ScriptDom.TriggerActionType  
  member this.ToCs() : ScriptDom.TriggerAction =
    match this with
    | TriggerAction(EventTypeGroup=aEventTypeGroup; TriggerActionType=aTriggerActionType) ->
      let ret = ScriptDom.TriggerAction()
      ret.EventTypeGroup <- aEventTypeGroup |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TriggerActionType <- aTriggerActionType
      ret (* 333 *)
  static member FromCs(src:ScriptDom.TriggerAction, fragmentMapping:FragmentMapping) : TriggerAction =
    let ret =
      TriggerAction.TriggerAction((src.EventTypeGroup |> Option.ofObj |> Option.map (fun x -> EventTypeGroupContainer.FromCs(x, fragmentMapping))), (src.TriggerActionType))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] UserLoginOption = (* Abstract? = false *)
  | UserLoginOption of Identifier:Identifier option * UserLoginOptionType:ScriptDom.UserLoginOptionType  
  member this.ToCs() : ScriptDom.UserLoginOption =
    match this with
    | UserLoginOption(Identifier=aIdentifier; UserLoginOptionType=aUserLoginOptionType) ->
      let ret = ScriptDom.UserLoginOption()
      ret.Identifier <- aIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UserLoginOptionType <- aUserLoginOptionType
      ret (* 333 *)
  static member FromCs(src:ScriptDom.UserLoginOption, fragmentMapping:FragmentMapping) : UserLoginOption =
    let ret =
      UserLoginOption.UserLoginOption((src.Identifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.UserLoginOptionType))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] VariableTableReference = (* Abstract? = false *)
  | VariableTableReference of Alias:Identifier option * Variable:VariableReference option  
  member this.ToCs() : ScriptDom.VariableTableReference =
    match this with
    | VariableTableReference(Alias=aAlias; Variable=aVariable) ->
      let ret = ScriptDom.VariableTableReference()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Variable <- aVariable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.VariableTableReference, fragmentMapping:FragmentMapping) : VariableTableReference =
    let ret =
      VariableTableReference.VariableTableReference((src.Alias |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.Variable |> Option.ofObj |> Option.map (fun x -> VariableReference.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] ColumnDefinition = (* Abstract? = false *)
  | ColumnDefinition of Collation:Identifier option * ColumnIdentifier:Identifier option * ComputedColumnExpression:ScalarExpression option * Constraints:(ConstraintDefinition) list * DataType:DataTypeReference option * DefaultConstraint:DefaultConstraintDefinition option * Encryption:ColumnEncryptionDefinition option * GeneratedAlways:(ScriptDom.GeneratedAlwaysType) option * IdentityOptions:IdentityOptions option * Index:IndexDefinition option * IsHidden:bool * IsMasked:bool * IsPersisted:bool * IsRowGuidCol:bool * MaskingFunction:StringLiteral option * StorageOptions:ColumnStorageOptions option  
  member this.ToCs() : ScriptDom.ColumnDefinition =
    match this with
    | ColumnDefinition(Collation=aCollation; ColumnIdentifier=aColumnIdentifier; ComputedColumnExpression=aComputedColumnExpression; Constraints=aConstraints; DataType=aDataType; DefaultConstraint=aDefaultConstraint; Encryption=aEncryption; GeneratedAlways=aGeneratedAlways; IdentityOptions=aIdentityOptions; Index=aIndex; IsHidden=aIsHidden; IsMasked=aIsMasked; IsPersisted=aIsPersisted; IsRowGuidCol=aIsRowGuidCol; MaskingFunction=aMaskingFunction; StorageOptions=aStorageOptions) ->
      let ret = ScriptDom.ColumnDefinition()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ColumnIdentifier <- aColumnIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ComputedColumnExpression <- aComputedColumnExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aConstraints do ret.Constraints.Add (e.ToCs())
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DefaultConstraint <- aDefaultConstraint |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Encryption <- aEncryption |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.GeneratedAlways <- Option.toNullable aGeneratedAlways
      ret.IdentityOptions <- aIdentityOptions |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Index <- aIndex |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsHidden <- aIsHidden
      ret.IsMasked <- aIsMasked
      ret.IsPersisted <- aIsPersisted
      ret.IsRowGuidCol <- aIsRowGuidCol
      ret.MaskingFunction <- aMaskingFunction |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StorageOptions <- aStorageOptions |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.ColumnDefinition, fragmentMapping:FragmentMapping) : ColumnDefinition =
    let ret =
      ColumnDefinition.ColumnDefinition((src.Collation |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ColumnIdentifier |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.ComputedColumnExpression |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.Constraints |> Seq.map (fun x -> ConstraintDefinition.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.DataType |> Option.ofObj |> Option.map (fun x -> DataTypeReference.FromCs(x, fragmentMapping))), (src.DefaultConstraint |> Option.ofObj |> Option.map (fun x -> DefaultConstraintDefinition.FromCs(x, fragmentMapping))), (src.Encryption |> Option.ofObj |> Option.map (fun x -> ColumnEncryptionDefinition.FromCs(x, fragmentMapping))), (Option.ofNullable (src.GeneratedAlways)), (src.IdentityOptions |> Option.ofObj |> Option.map (fun x -> IdentityOptions.FromCs(x, fragmentMapping))), (src.Index |> Option.ofObj |> Option.map (fun x -> IndexDefinition.FromCs(x, fragmentMapping))), (src.IsHidden), (src.IsMasked), (src.IsPersisted), (src.IsRowGuidCol), (src.MaskingFunction |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))), (src.StorageOptions |> Option.ofObj |> Option.map (fun x -> ColumnStorageOptions.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] SystemTimePeriodDefinition = (* Abstract? = false *)
  | SystemTimePeriodDefinition of EndTimeColumn:Identifier option * StartTimeColumn:Identifier option  
  member this.ToCs() : ScriptDom.SystemTimePeriodDefinition =
    match this with
    | SystemTimePeriodDefinition(EndTimeColumn=aEndTimeColumn; StartTimeColumn=aStartTimeColumn) ->
      let ret = ScriptDom.SystemTimePeriodDefinition()
      ret.EndTimeColumn <- aEndTimeColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StartTimeColumn <- aStartTimeColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.SystemTimePeriodDefinition, fragmentMapping:FragmentMapping) : SystemTimePeriodDefinition =
    let ret =
      SystemTimePeriodDefinition.SystemTimePeriodDefinition((src.EndTimeColumn |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.StartTimeColumn |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] RetentionPeriodDefinition = (* Abstract? = false *)
  | RetentionPeriodDefinition of Duration:IntegerLiteral option * IsInfinity:bool * Units:ScriptDom.TemporalRetentionPeriodUnit  
  member this.ToCs() : ScriptDom.RetentionPeriodDefinition =
    match this with
    | RetentionPeriodDefinition(Duration=aDuration; IsInfinity=aIsInfinity; Units=aUnits) ->
      let ret = ScriptDom.RetentionPeriodDefinition()
      ret.Duration <- aDuration |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsInfinity <- aIsInfinity
      ret.Units <- aUnits
      ret (* 333 *)
  static member FromCs(src:ScriptDom.RetentionPeriodDefinition, fragmentMapping:FragmentMapping) : RetentionPeriodDefinition =
    let ret =
      RetentionPeriodDefinition.RetentionPeriodDefinition((src.Duration |> Option.ofObj |> Option.map (fun x -> IntegerLiteral.FromCs(x, fragmentMapping))), (src.IsInfinity), (src.Units))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] DataCompressionOption = (* Abstract? = false *)
  | DataCompressionOption of CompressionLevel:ScriptDom.DataCompressionLevel * OptionKind:ScriptDom.IndexOptionKind * PartitionRanges:(CompressionPartitionRange) list  
  member this.ToCs() : ScriptDom.DataCompressionOption =
    match this with
    | DataCompressionOption(CompressionLevel=aCompressionLevel; OptionKind=aOptionKind; PartitionRanges=aPartitionRanges) ->
      let ret = ScriptDom.DataCompressionOption()
      ret.CompressionLevel <- aCompressionLevel
      ret.OptionKind <- aOptionKind
      for e in aPartitionRanges do ret.PartitionRanges.Add (e.ToCs())
      ret (* 333 *)
  static member FromCs(src:ScriptDom.DataCompressionOption, fragmentMapping:FragmentMapping) : DataCompressionOption =
    let ret =
      DataCompressionOption.DataCompressionOption((src.CompressionLevel), (src.OptionKind), (src.PartitionRanges |> Seq.map (fun src -> CompressionPartitionRange.CompressionPartitionRange((src.From |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.To |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))))) |> List.ofSeq))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] TablePartitionOptionSpecifications = (* Abstract? = false *)
  | TablePartitionOptionSpecifications of BoundaryValues:(ScalarExpression) list * Range:ScriptDom.PartitionTableOptionRange  
  member this.ToCs() : ScriptDom.TablePartitionOptionSpecifications =
    match this with
    | TablePartitionOptionSpecifications(BoundaryValues=aBoundaryValues; Range=aRange) ->
      let ret = ScriptDom.TablePartitionOptionSpecifications()
      for e in aBoundaryValues do ret.BoundaryValues.Add (e.ToCs())
      ret.Range <- aRange
      ret (* 333 *)
  static member FromCs(src:ScriptDom.TablePartitionOptionSpecifications, fragmentMapping:FragmentMapping) : TablePartitionOptionSpecifications =
    let ret =
      TablePartitionOptionSpecifications.TablePartitionOptionSpecifications((src.BoundaryValues |> Seq.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.Range))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] SchemaObjectNameOrValueExpression = (* Abstract? = false *)
  | SchemaObjectNameOrValueExpression of SchemaObjectName:SchemaObjectName option * ValueExpression:ValueExpression option  
  member this.ToCs() : ScriptDom.SchemaObjectNameOrValueExpression =
    match this with
    | SchemaObjectNameOrValueExpression(SchemaObjectName=aSchemaObjectName; ValueExpression=aValueExpression) ->
      let ret = ScriptDom.SchemaObjectNameOrValueExpression()
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ValueExpression <- aValueExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.SchemaObjectNameOrValueExpression, fragmentMapping:FragmentMapping) : SchemaObjectNameOrValueExpression =
    let ret =
      SchemaObjectNameOrValueExpression.SchemaObjectNameOrValueExpression((src.SchemaObjectName |> Option.ofObj |> Option.map (fun x -> SchemaObjectName.FromCs(x, fragmentMapping))), (src.ValueExpression |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] TableSampleClause = (* Abstract? = false *)
  | TableSampleClause of RepeatSeed:ScalarExpression option * SampleNumber:ScalarExpression option * System:bool * TableSampleClauseOption:ScriptDom.TableSampleClauseOption  
  member this.ToCs() : ScriptDom.TableSampleClause =
    match this with
    | TableSampleClause(RepeatSeed=aRepeatSeed; SampleNumber=aSampleNumber; System=aSystem; TableSampleClauseOption=aTableSampleClauseOption) ->
      let ret = ScriptDom.TableSampleClause()
      ret.RepeatSeed <- aRepeatSeed |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SampleNumber <- aSampleNumber |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.System <- aSystem
      ret.TableSampleClauseOption <- aTableSampleClauseOption
      ret (* 333 *)
  static member FromCs(src:ScriptDom.TableSampleClause, fragmentMapping:FragmentMapping) : TableSampleClause =
    let ret =
      TableSampleClause.TableSampleClause((src.RepeatSeed |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.SampleNumber |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.System), (src.TableSampleClauseOption))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] TemporalClause = (* Abstract? = false *)
  | TemporalClause of EndTime:ScalarExpression option * StartTime:ScalarExpression option * TemporalClauseType:ScriptDom.TemporalClauseType  
  member this.ToCs() : ScriptDom.TemporalClause =
    match this with
    | TemporalClause(EndTime=aEndTime; StartTime=aStartTime; TemporalClauseType=aTemporalClauseType) ->
      let ret = ScriptDom.TemporalClause()
      ret.EndTime <- aEndTime |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StartTime <- aStartTime |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TemporalClauseType <- aTemporalClauseType
      ret (* 333 *)
  static member FromCs(src:ScriptDom.TemporalClause, fragmentMapping:FragmentMapping) : TemporalClause =
    let ret =
      TemporalClause.TemporalClause((src.EndTime |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.StartTime |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.TemporalClauseType))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] SchemaDeclarationItemOpenjson = (* Abstract? = false *)
  | SchemaDeclarationItemOpenjson of AsJson:bool * ColumnDefinition:ColumnDefinitionBase option * Mapping:ValueExpression option  
  member this.ToCs() : ScriptDom.SchemaDeclarationItemOpenjson =
    match this with
    | SchemaDeclarationItemOpenjson(AsJson=aAsJson; ColumnDefinition=aColumnDefinition; Mapping=aMapping) ->
      let ret = ScriptDom.SchemaDeclarationItemOpenjson()
      ret.AsJson <- aAsJson
      ret.ColumnDefinition <- aColumnDefinition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Mapping <- aMapping |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.SchemaDeclarationItemOpenjson, fragmentMapping:FragmentMapping) : SchemaDeclarationItemOpenjson =
    let ret =
      SchemaDeclarationItemOpenjson.SchemaDeclarationItemOpenjson((src.AsJson), (src.ColumnDefinition |> Option.ofObj |> Option.map (fun x -> ColumnDefinitionBase.FromCs(x, fragmentMapping))), (src.Mapping |> Option.ofObj |> Option.map (fun x -> ValueExpression.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] WindowDelimiter = (* Abstract? = false *)
  | WindowDelimiter of OffsetValue:ScalarExpression option * WindowDelimiterType:ScriptDom.WindowDelimiterType  
  member this.ToCs() : ScriptDom.WindowDelimiter =
    match this with
    | WindowDelimiter(OffsetValue=aOffsetValue; WindowDelimiterType=aWindowDelimiterType) ->
      let ret = ScriptDom.WindowDelimiter()
      ret.OffsetValue <- aOffsetValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WindowDelimiterType <- aWindowDelimiterType
      ret (* 333 *)
  static member FromCs(src:ScriptDom.WindowDelimiter, fragmentMapping:FragmentMapping) : WindowDelimiter =
    let ret =
      WindowDelimiter.WindowDelimiter((src.OffsetValue |> Option.ofObj |> Option.map (fun x -> ScalarExpression.FromCs(x, fragmentMapping))), (src.WindowDelimiterType))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] CommonTableExpression = (* Abstract? = false *)
  | CommonTableExpression of Columns:(Identifier) list * ExpressionName:Identifier option * QueryExpression:QueryExpression option  
  member this.ToCs() : ScriptDom.CommonTableExpression =
    match this with
    | CommonTableExpression(Columns=aColumns; ExpressionName=aExpressionName; QueryExpression=aQueryExpression) ->
      let ret = ScriptDom.CommonTableExpression()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.ExpressionName <- aExpressionName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.QueryExpression <- aQueryExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.CommonTableExpression, fragmentMapping:FragmentMapping) : CommonTableExpression =
    let ret =
      CommonTableExpression.CommonTableExpression((src.Columns |> Seq.map (fun x -> Identifier.FromCs(x, fragmentMapping)) |> List.ofSeq), (src.ExpressionName |> Option.ofObj |> Option.map (fun x -> Identifier.FromCs(x, fragmentMapping))), (src.QueryExpression |> Option.ofObj |> Option.map (fun x -> QueryExpression.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
and [<RequireQualifiedAccess>] WlmTimeLiteral = (* Abstract? = false *)
  | WlmTimeLiteral of TimeString:StringLiteral option  
  member this.ToCs() : ScriptDom.WlmTimeLiteral =
    match this with
    | WlmTimeLiteral(TimeString=aTimeString) ->
      let ret = ScriptDom.WlmTimeLiteral()
      ret.TimeString <- aTimeString |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 333 *)
  static member FromCs(src:ScriptDom.WlmTimeLiteral, fragmentMapping:FragmentMapping) : WlmTimeLiteral =
    let ret =
      WlmTimeLiteral.WlmTimeLiteral((src.TimeString |> Option.ofObj |> Option.map (fun x -> StringLiteral.FromCs(x, fragmentMapping))))
    if not (obj.ReferenceEquals(fragmentMapping, null)) then fragmentMapping.[ret] <- src
    ret
